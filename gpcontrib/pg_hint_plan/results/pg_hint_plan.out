SET search_path TO public;
SET client_min_messages TO log;
\set SHOW_CONTEXT always
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id;
LOG:  statement: EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id;
                QUERY PLAN                
------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t1.id = t2.id)
         ->  Seq Scan on t1
         ->  Hash
               ->  Seq Scan on t2
 Optimizer: Postgres query optimizer
(7 rows)

EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.val = t2.val;
LOG:  statement: EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.val = t2.val;
                          QUERY PLAN                           
---------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t1.val = t2.val)
         ->  Seq Scan on t1
         ->  Hash
               ->  Broadcast Motion 3:3  (slice2; segments: 3)
                     ->  Seq Scan on t2
 Optimizer: Postgres query optimizer
(8 rows)

LOAD 'pg_hint_plan';
LOG:  statement: LOAD 'pg_hint_plan';
SET pg_hint_plan.debug_print TO on;
LOG:  statement: SET pg_hint_plan.debug_print TO on;
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id;
LOG:  statement: EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id;
                QUERY PLAN                
------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t1.id = t2.id)
         ->  Seq Scan on t1
         ->  Hash
               ->  Seq Scan on t2
 Optimizer: Postgres query optimizer
(7 rows)

EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.val = t2.val;
LOG:  statement: EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.val = t2.val;
                          QUERY PLAN                           
---------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t1.val = t2.val)
         ->  Seq Scan on t1
         ->  Hash
               ->  Broadcast Motion 3:3  (slice2; segments: 3)
                     ->  Seq Scan on t2
 Optimizer: Postgres query optimizer
(8 rows)

/*+ Test (t1 t2) */
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id;
LOG:  statement: /*+ Test (t1 t2) */
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id;
INFO:  pg_hint_plan: hint syntax error at or near "Test (t1 t2) "
DETAIL:  Unrecognized hint keyword "Test".
                QUERY PLAN                
------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t1.id = t2.id)
         ->  Seq Scan on t1
         ->  Hash
               ->  Seq Scan on t2
 Optimizer: Postgres query optimizer
(7 rows)

SET pg_hint_plan.enable_hint TO off;
LOG:  statement: SET pg_hint_plan.enable_hint TO off;
/*+ Test (t1 t2) */
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id;
LOG:  statement: /*+ Test (t1 t2) */
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id;
                QUERY PLAN                
------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t1.id = t2.id)
         ->  Seq Scan on t1
         ->  Hash
               ->  Seq Scan on t2
 Optimizer: Postgres query optimizer
(7 rows)

SET pg_hint_plan.enable_hint TO on;
LOG:  statement: SET pg_hint_plan.enable_hint TO on;
/*Set(enable_indexscan off)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id;
LOG:  statement: /*Set(enable_indexscan off)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id;
                QUERY PLAN                
------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t1.id = t2.id)
         ->  Seq Scan on t1
         ->  Hash
               ->  Seq Scan on t2
 Optimizer: Postgres query optimizer
(7 rows)

--+Set(enable_indexscan off)
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id;
LOG:  statement: EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id;
                QUERY PLAN                
------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t1.id = t2.id)
         ->  Seq Scan on t1
         ->  Hash
               ->  Seq Scan on t2
 Optimizer: Postgres query optimizer
(7 rows)

/*+Set(enable_indexscan off) /* nest comment */ */
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id;
LOG:  statement: /*+Set(enable_indexscan off) /* nest comment */ */
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id;
INFO:  pg_hint_plan: hint syntax error at or near "/* nest comment */ */
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id;"
DETAIL:  Nested block comments are not supported.
                QUERY PLAN                
------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t1.id = t2.id)
         ->  Seq Scan on t1
         ->  Hash
               ->  Seq Scan on t2
 Optimizer: Postgres query optimizer
(7 rows)

/*+Set(enable_indexscan off)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id;
LOG:  statement: /*+Set(enable_indexscan off)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id;
LOG:  pg_hint_plan:
used hint:
Set(enable_indexscan off)
not used hint:
duplication hint:
error hint:
                QUERY PLAN                
------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t1.id = t2.id)
         ->  Seq Scan on t1
         ->  Hash
               ->  Seq Scan on t2
 Optimizer: Postgres query optimizer
(7 rows)

EXPLAIN (COSTS false) /*+Set(enable_indexscan off)*/
 SELECT * FROM t1, t2 WHERE t1.id = t2.id;
LOG:  statement: EXPLAIN (COSTS false) /*+Set(enable_indexscan off)*/
 SELECT * FROM t1, t2 WHERE t1.id = t2.id;
LOG:  pg_hint_plan:
used hint:
Set(enable_indexscan off)
not used hint:
duplication hint:
error hint:
                QUERY PLAN                
------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t1.id = t2.id)
         ->  Seq Scan on t1
         ->  Hash
               ->  Seq Scan on t2
 Optimizer: Postgres query optimizer
(7 rows)

/*+ Set(enable_indexscan off) Set(enable_hashjoin off) */
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id;
LOG:  statement: /*+ Set(enable_indexscan off) Set(enable_hashjoin off) */
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id;
LOG:  pg_hint_plan:
used hint:
Set(enable_hashjoin off)
Set(enable_indexscan off)
not used hint:
duplication hint:
error hint:
                QUERY PLAN                
------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Merge Join
         Merge Cond: (t1.id = t2.id)
         ->  Sort
               Sort Key: t1.id
               ->  Seq Scan on t1
         ->  Sort
               Sort Key: t2.id
               ->  Seq Scan on t2
 Optimizer: Postgres query optimizer
(10 rows)

/*+ 	 Set 	 ( 	 enable_indexscan 	 off 	 ) 	 */
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id;
LOG:  statement: /*+ 	 Set 	 ( 	 enable_indexscan 	 off 	 ) 	 */
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id;
LOG:  pg_hint_plan:
used hint:
Set(enable_indexscan off)
not used hint:
duplication hint:
error hint:
                QUERY PLAN                
------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t1.id = t2.id)
         ->  Seq Scan on t1
         ->  Hash
               ->  Seq Scan on t2
 Optimizer: Postgres query optimizer
(7 rows)

/*+ 	 
	 	Set 	 
	 	( 	 
	 	enable_indexscan 	 
	 	off 	 
	 	) 	 
	 	*/	 	
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id;
LOG:  statement: /*+ 	 
	 	Set 	 
	 	( 	 
	 	enable_indexscan 	 
	 	off 	 
	 	) 	 
	 	*/	 	
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id;
LOG:  pg_hint_plan:
used hint:
Set(enable_indexscan off)
not used hint:
duplication hint:
error hint:
                QUERY PLAN                
------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t1.id = t2.id)
         ->  Seq Scan on t1
         ->  Hash
               ->  Seq Scan on t2
 Optimizer: Postgres query optimizer
(7 rows)

/*+ Set(enable_indexscan off)Set(enable_nestloop off)Set(enable_mergejoin off)	 	
	 	Set(enable_seqscan off)
	 	*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id;
LOG:  statement: /*+ Set(enable_indexscan off)Set(enable_nestloop off)Set(enable_mergejoin off)	 	
	 	Set(enable_seqscan off)
	 	*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id;
LOG:  pg_hint_plan:
used hint:
Set(enable_indexscan off)
Set(enable_mergejoin off)
Set(enable_nestloop off)
Set(enable_seqscan off)
not used hint:
duplication hint:
error hint:
                      QUERY PLAN                      
------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t1.id = t2.id)
         ->  Bitmap Heap Scan on t1
               ->  Bitmap Index Scan on t1_pkey
         ->  Hash
               ->  Bitmap Heap Scan on t2
                     ->  Bitmap Index Scan on t2_pkey
 Optimizer: Postgres query optimizer
(9 rows)

/*+Set(work_mem "1M")*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id;
LOG:  statement: /*+Set(work_mem "1M")*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id;
WARNING:  "work_mem": setting is deprecated, and may be removed in a future release.
INFO:  invalid value for parameter "work_mem": "1M"
HINT:  Valid units for this parameter are "B", "kB", "MB", "GB", and "TB".
LOG:  pg_hint_plan:
used hint:
not used hint:
duplication hint:
error hint:
Set(work_mem 1M)
                QUERY PLAN                
------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t1.id = t2.id)
         ->  Seq Scan on t1
         ->  Hash
               ->  Seq Scan on t2
 Optimizer: Postgres query optimizer
(7 rows)

/*+Set(work_mem "1MB")*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id;
LOG:  statement: /*+Set(work_mem "1MB")*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id;
WARNING:  "work_mem": setting is deprecated, and may be removed in a future release.
LOG:  pg_hint_plan:
used hint:
Set(work_mem 1MB)
not used hint:
duplication hint:
error hint:
                QUERY PLAN                
------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t1.id = t2.id)
         ->  Seq Scan on t1
         ->  Hash
               ->  Seq Scan on t2
 Optimizer: Postgres query optimizer
(7 rows)

/*+Set(work_mem TO "1MB")*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id;
LOG:  statement: /*+Set(work_mem TO "1MB")*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id;
INFO:  pg_hint_plan: hint syntax error at or near "Set(work_mem TO "1MB")"
DETAIL:  Set hint requires name and value of GUC parameter.
LOG:  pg_hint_plan:
used hint:
not used hint:
duplication hint:
error hint:
Set(work_mem TO 1MB)
                QUERY PLAN                
------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t1.id = t2.id)
         ->  Seq Scan on t1
         ->  Hash
               ->  Seq Scan on t2
 Optimizer: Postgres query optimizer
(7 rows)

/*+SeqScan() */ SELECT 1;
LOG:  statement: /*+SeqScan() */ SELECT 1;
INFO:  pg_hint_plan: hint syntax error at or near " "
DETAIL:  SeqScan hint requires a relation.
LOG:  pg_hint_plan:
used hint:
not used hint:
duplication hint:
error hint:
SeqScan()
 ?column? 
----------
        1
(1 row)

/*+SeqScan(t1 t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id;
LOG:  statement: /*+SeqScan(t1 t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id;
INFO:  pg_hint_plan: hint syntax error at or near ""
DETAIL:  SeqScan hint accepts only one relation.
LOG:  pg_hint_plan:
used hint:
not used hint:
duplication hint:
error hint:
SeqScan(t1 t2)
                QUERY PLAN                
------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t1.id = t2.id)
         ->  Seq Scan on t1
         ->  Hash
               ->  Seq Scan on t2
 Optimizer: Postgres query optimizer
(7 rows)

/*+SeqScan(t1)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id;
LOG:  statement: /*+SeqScan(t1)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id;
LOG:  pg_hint_plan:
used hint:
SeqScan(t1)
not used hint:
duplication hint:
error hint:
                QUERY PLAN                
------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t1.id = t2.id)
         ->  Seq Scan on t1
         ->  Hash
               ->  Seq Scan on t2
 Optimizer: Postgres query optimizer
(7 rows)

/*+SeqScan(t1)IndexScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id;
LOG:  statement: /*+SeqScan(t1)IndexScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id;
LOG:  pg_hint_plan:
used hint:
SeqScan(t1)
IndexScan(t2)
not used hint:
duplication hint:
error hint:
                    QUERY PLAN                    
--------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t1.id = t2.id)
         ->  Seq Scan on t1
         ->  Hash
               ->  Index Scan using t2_pkey on t2
 Optimizer: Postgres query optimizer
(7 rows)

/*+BitmapScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id;
LOG:  statement: /*+BitmapScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id;
LOG:  pg_hint_plan:
used hint:
BitmapScan(t2)
not used hint:
duplication hint:
error hint:
                      QUERY PLAN                      
------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t1.id = t2.id)
         ->  Seq Scan on t1
         ->  Hash
               ->  Bitmap Heap Scan on t2
                     ->  Bitmap Index Scan on t2_pkey
 Optimizer: Postgres query optimizer
(8 rows)

/*+BitmapScan(t2)NoSeqScan(t1)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id;
LOG:  statement: /*+BitmapScan(t2)NoSeqScan(t1)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id;
LOG:  pg_hint_plan:
used hint:
NoSeqScan(t1)
BitmapScan(t2)
not used hint:
duplication hint:
error hint:
                      QUERY PLAN                      
------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t1.id = t2.id)
         ->  Bitmap Heap Scan on t1
               ->  Bitmap Index Scan on t1_pkey
         ->  Hash
               ->  Bitmap Heap Scan on t2
                     ->  Bitmap Index Scan on t2_pkey
 Optimizer: Postgres query optimizer
(9 rows)

/*+NoIndexScan(t1)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id;
LOG:  statement: /*+NoIndexScan(t1)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id;
LOG:  pg_hint_plan:
used hint:
NoIndexScan(t1)
not used hint:
duplication hint:
error hint:
                QUERY PLAN                
------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t1.id = t2.id)
         ->  Seq Scan on t1
         ->  Hash
               ->  Seq Scan on t2
 Optimizer: Postgres query optimizer
(7 rows)

/*+NoBitmapScan(t1)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t4 WHERE t1.val < 10;
LOG:  statement: /*+NoBitmapScan(t1)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t4 WHERE t1.val < 10;
LOG:  pg_hint_plan:
used hint:
NoBitmapScan(t1)
not used hint:
duplication hint:
error hint:
                          QUERY PLAN                           
---------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Nested Loop
         ->  Index Scan using t1_val on t1
               Index Cond: (val < 10)
         ->  Materialize
               ->  Broadcast Motion 3:3  (slice2; segments: 3)
                     ->  Seq Scan on t4
 Optimizer: Postgres query optimizer
(8 rows)

/*+TidScan(t4)*/
EXPLAIN (COSTS false) SELECT * FROM t3, t4 WHERE t3.id = t4.id AND t4.ctid = '(1,1)';
LOG:  statement: /*+TidScan(t4)*/
EXPLAIN (COSTS false) SELECT * FROM t3, t4 WHERE t3.id = t4.id AND t4.ctid = '(1,1)';
NOTICE:  SELECT uses system-defined column "t4.ctid" without the necessary companion column "t4.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  pg_hint_plan:
used hint:
TidScan(t4)
not used hint:
duplication hint:
error hint:
                     QUERY PLAN                      
-----------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t3.id = t4.id)
         ->  Seq Scan on t3
         ->  Hash
               ->  Tid Scan on t4
                     TID Cond: (ctid = '(1,1)'::tid)
 Optimizer: Postgres query optimizer
(8 rows)

/*+NoTidScan(t1)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)';
LOG:  statement: /*+NoTidScan(t1)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)';
NOTICE:  SELECT uses system-defined column "t1.ctid" without the necessary companion column "t1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  pg_hint_plan:
used hint:
NoTidScan(t1)
not used hint:
duplication hint:
error hint:
                    QUERY PLAN                     
---------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t2.id = t1.id)
         ->  Seq Scan on t2
         ->  Hash
               ->  Seq Scan on t1
                     Filter: (ctid = '(1,1)'::tid)
 Optimizer: Postgres query optimizer
(8 rows)

/*+ NestLoop() */ SELECT 1;
LOG:  statement: /*+ NestLoop() */ SELECT 1;
INFO:  pg_hint_plan: hint syntax error at or near " "
DETAIL:  NestLoop hint requires at least two relations.
LOG:  pg_hint_plan:
used hint:
not used hint:
duplication hint:
error hint:
NestLoop()
 ?column? 
----------
        1
(1 row)

/*+ NestLoop(x) */ SELECT 1;
LOG:  statement: /*+ NestLoop(x) */ SELECT 1;
INFO:  pg_hint_plan: hint syntax error at or near " "
DETAIL:  NestLoop hint requires at least two relations.
LOG:  pg_hint_plan:
used hint:
not used hint:
duplication hint:
error hint:
NestLoop(x)
 ?column? 
----------
        1
(1 row)

/*+HashJoin(t1 t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id;
LOG:  statement: /*+HashJoin(t1 t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id;
WARNING:  "work_mem": setting is deprecated, and may be removed in a future release.
LOG:  pg_hint_plan:
used hint:
HashJoin(t1 t2)
not used hint:
duplication hint:
error hint:
                QUERY PLAN                
------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t1.id = t2.id)
         ->  Seq Scan on t1
         ->  Hash
               ->  Seq Scan on t2
 Optimizer: Postgres query optimizer
(7 rows)

/*+NestLoop(t1 t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id;
LOG:  statement: /*+NestLoop(t1 t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id;
LOG:  pg_hint_plan:
used hint:
NestLoop(t1 t2)
not used hint:
duplication hint:
error hint:
                 QUERY PLAN                 
--------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Nested Loop
         ->  Seq Scan on t2
         ->  Index Scan using t1_pkey on t1
               Index Cond: (id = t2.id)
 Optimizer: Postgres query optimizer
(6 rows)

/*+NoMergeJoin(t1 t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id;
LOG:  statement: /*+NoMergeJoin(t1 t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id;
LOG:  pg_hint_plan:
used hint:
NoMergeJoin(t1 t2)
not used hint:
duplication hint:
error hint:
                QUERY PLAN                
------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t1.id = t2.id)
         ->  Seq Scan on t1
         ->  Hash
               ->  Seq Scan on t2
 Optimizer: Postgres query optimizer
(7 rows)

/*+MergeJoin(t1 t3)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t3 WHERE t1.val = t3.val;
LOG:  statement: /*+MergeJoin(t1 t3)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t3 WHERE t1.val = t3.val;
LOG:  pg_hint_plan:
used hint:
MergeJoin(t1 t3)
not used hint:
duplication hint:
error hint:
                          QUERY PLAN                           
---------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Merge Join
         Merge Cond: (t1.val = t3.val)
         ->  Index Scan using t1_val on t1
         ->  Sort
               Sort Key: t3.val
               ->  Broadcast Motion 3:3  (slice2; segments: 3)
                     ->  Seq Scan on t3
 Optimizer: Postgres query optimizer
(9 rows)

/*+NestLoop(t1 t3)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t3 WHERE t1.val = t3.val;
LOG:  statement: /*+NestLoop(t1 t3)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t3 WHERE t1.val = t3.val;
LOG:  pg_hint_plan:
used hint:
NestLoop(t1 t3)
not used hint:
duplication hint:
error hint:
                       QUERY PLAN                        
---------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Nested Loop
         ->  Broadcast Motion 3:3  (slice2; segments: 3)
               ->  Seq Scan on t3
         ->  Index Scan using t1_val on t1
               Index Cond: (val = t3.val)
 Optimizer: Postgres query optimizer
(7 rows)

/*+NoHashJoin(t1 t3)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t3 WHERE t1.val = t3.val;
LOG:  statement: /*+NoHashJoin(t1 t3)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t3 WHERE t1.val = t3.val;
LOG:  pg_hint_plan:
used hint:
NoHashJoin(t1 t3)
not used hint:
duplication hint:
error hint:
                          QUERY PLAN                           
---------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Merge Join
         Merge Cond: (t1.val = t3.val)
         ->  Index Scan using t1_val on t1
         ->  Sort
               Sort Key: t3.val
               ->  Broadcast Motion 3:3  (slice2; segments: 3)
                     ->  Seq Scan on t3
 Optimizer: Postgres query optimizer
(9 rows)

/*+MergeJoin(t4 t1 t2 t3)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2, t3, t4 WHERE t1.id = t2.id AND t1.id = t3.id AND t1.id = t4.id;
LOG:  statement: /*+MergeJoin(t4 t1 t2 t3)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2, t3, t4 WHERE t1.id = t2.id AND t1.id = t3.id AND t1.id = t4.id;
LOG:  pg_hint_plan:
used hint:
MergeJoin(t1 t2 t3 t4)
not used hint:
duplication hint:
error hint:
                         QUERY PLAN                         
------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Merge Join
         Merge Cond: (t1.id = t2.id)
         ->  Index Scan using t1_pkey on t1
         ->  Sort
               Sort Key: t2.id
               ->  Hash Join
                     Hash Cond: (t2.id = t3.id)
                     ->  Seq Scan on t2
                     ->  Hash
                           ->  Hash Join
                                 Hash Cond: (t3.id = t4.id)
                                 ->  Seq Scan on t3
                                 ->  Hash
                                       ->  Seq Scan on t4
 Optimizer: Postgres query optimizer
(16 rows)

/*+HashJoin(t3 t4 t1 t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2, t3, t4 WHERE t1.id = t2.id AND t1.id = t3.id AND t1.id = t4.id;
LOG:  statement: /*+HashJoin(t3 t4 t1 t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2, t3, t4 WHERE t1.id = t2.id AND t1.id = t3.id AND t1.id = t4.id;
WARNING:  "work_mem": setting is deprecated, and may be removed in a future release.
WARNING:  "work_mem": setting is deprecated, and may be removed in a future release.
WARNING:  "work_mem": setting is deprecated, and may be removed in a future release.
WARNING:  "work_mem": setting is deprecated, and may be removed in a future release.
WARNING:  "work_mem": setting is deprecated, and may be removed in a future release.
WARNING:  "work_mem": setting is deprecated, and may be removed in a future release.
WARNING:  "work_mem": setting is deprecated, and may be removed in a future release.
LOG:  pg_hint_plan:
used hint:
HashJoin(t1 t2 t3 t4)
not used hint:
duplication hint:
error hint:
                         QUERY PLAN                         
------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t1.id = t2.id)
         ->  Seq Scan on t1
         ->  Hash
               ->  Hash Join
                     Hash Cond: (t2.id = t3.id)
                     ->  Seq Scan on t2
                     ->  Hash
                           ->  Hash Join
                                 Hash Cond: (t3.id = t4.id)
                                 ->  Seq Scan on t3
                                 ->  Hash
                                       ->  Seq Scan on t4
 Optimizer: Postgres query optimizer
(15 rows)

/*+NestLoop(t2 t3 t4 t1) IndexScan(t3)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2, t3, t4 WHERE t1.id = t2.id AND t1.id = t3.id AND t1.id = t4.id;
LOG:  statement: /*+NestLoop(t2 t3 t4 t1) IndexScan(t3)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2, t3, t4 WHERE t1.id = t2.id AND t1.id = t3.id AND t1.id = t4.id;
LOG:  pg_hint_plan:
used hint:
IndexScan(t3)
NestLoop(t1 t2 t3 t4)
not used hint:
duplication hint:
error hint:
                      QUERY PLAN                      
------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Nested Loop
         ->  Hash Join
               Hash Cond: (t3.id = t2.id)
               ->  Index Scan using t3_pkey on t3
               ->  Hash
                     ->  Hash Join
                           Hash Cond: (t2.id = t4.id)
                           ->  Seq Scan on t2
                           ->  Hash
                                 ->  Seq Scan on t4
         ->  Index Scan using t1_pkey on t1
               Index Cond: (id = t2.id)
 Optimizer: Postgres query optimizer
(14 rows)

/*+NoNestLoop(t4 t1 t3 t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2, t3, t4 WHERE t1.id = t2.id AND t1.id = t3.id AND t1.id = t4.id;
LOG:  statement: /*+NoNestLoop(t4 t1 t3 t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2, t3, t4 WHERE t1.id = t2.id AND t1.id = t3.id AND t1.id = t4.id;
LOG:  pg_hint_plan:
used hint:
NoNestLoop(t1 t2 t3 t4)
not used hint:
duplication hint:
error hint:
                         QUERY PLAN                         
------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t1.id = t2.id)
         ->  Seq Scan on t1
         ->  Hash
               ->  Hash Join
                     Hash Cond: (t2.id = t3.id)
                     ->  Seq Scan on t2
                     ->  Hash
                           ->  Hash Join
                                 Hash Cond: (t3.id = t4.id)
                                 ->  Seq Scan on t3
                                 ->  Hash
                                       ->  Seq Scan on t4
 Optimizer: Postgres query optimizer
(15 rows)

/*+Leading( */
EXPLAIN (COSTS false) SELECT * FROM t1, t2, t3, t4 WHERE t1.id = t2.id AND t1.id = t3.id AND t1.id = t4.id;
LOG:  statement: /*+Leading( */
EXPLAIN (COSTS false) SELECT * FROM t1, t2, t3, t4 WHERE t1.id = t2.id AND t1.id = t3.id AND t1.id = t4.id;
INFO:  pg_hint_plan: hint syntax error at or near ""
DETAIL:  Closing parenthesis is necessary.
                         QUERY PLAN                         
------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t1.id = t2.id)
         ->  Seq Scan on t1
         ->  Hash
               ->  Hash Join
                     Hash Cond: (t2.id = t3.id)
                     ->  Seq Scan on t2
                     ->  Hash
                           ->  Hash Join
                                 Hash Cond: (t3.id = t4.id)
                                 ->  Seq Scan on t3
                                 ->  Hash
                                       ->  Seq Scan on t4
 Optimizer: Postgres query optimizer
(15 rows)

/*+Leading( )*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2, t3, t4 WHERE t1.id = t2.id AND t1.id = t3.id AND t1.id = t4.id;
LOG:  statement: /*+Leading( )*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2, t3, t4 WHERE t1.id = t2.id AND t1.id = t3.id AND t1.id = t4.id;
INFO:  pg_hint_plan: hint syntax error at or near "Leading( )"
DETAIL:  Leading hint requires at least two relations.
LOG:  pg_hint_plan:
used hint:
not used hint:
duplication hint:
error hint:
Leading()
                         QUERY PLAN                         
------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t1.id = t2.id)
         ->  Seq Scan on t1
         ->  Hash
               ->  Hash Join
                     Hash Cond: (t2.id = t3.id)
                     ->  Seq Scan on t2
                     ->  Hash
                           ->  Hash Join
                                 Hash Cond: (t3.id = t4.id)
                                 ->  Seq Scan on t3
                                 ->  Hash
                                       ->  Seq Scan on t4
 Optimizer: Postgres query optimizer
(15 rows)

/*+Leading( t3 )*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2, t3, t4 WHERE t1.id = t2.id AND t1.id = t3.id AND t1.id = t4.id;
LOG:  statement: /*+Leading( t3 )*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2, t3, t4 WHERE t1.id = t2.id AND t1.id = t3.id AND t1.id = t4.id;
INFO:  pg_hint_plan: hint syntax error at or near "Leading( t3 )"
DETAIL:  Leading hint requires at least two relations.
LOG:  pg_hint_plan:
used hint:
not used hint:
duplication hint:
error hint:
Leading(t3)
                         QUERY PLAN                         
------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t1.id = t2.id)
         ->  Seq Scan on t1
         ->  Hash
               ->  Hash Join
                     Hash Cond: (t2.id = t3.id)
                     ->  Seq Scan on t2
                     ->  Hash
                           ->  Hash Join
                                 Hash Cond: (t3.id = t4.id)
                                 ->  Seq Scan on t3
                                 ->  Hash
                                       ->  Seq Scan on t4
 Optimizer: Postgres query optimizer
(15 rows)

/*+Leading( t3 t4 )*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2, t3, t4 WHERE t1.id = t2.id AND t1.id = t3.id AND t1.id = t4.id;
LOG:  statement: /*+Leading( t3 t4 )*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2, t3, t4 WHERE t1.id = t2.id AND t1.id = t3.id AND t1.id = t4.id;
WARNING:  "work_mem": setting is deprecated, and may be removed in a future release.
LOG:  pg_hint_plan:
used hint:
Leading(t3 t4)
not used hint:
duplication hint:
error hint:
                      QUERY PLAN                      
------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Nested Loop
         ->  Merge Join
               Merge Cond: (t1.id = t3.id)
               ->  Index Scan using t1_pkey on t1
               ->  Sort
                     Sort Key: t3.id
                     ->  Hash Join
                           Hash Cond: (t3.id = t4.id)
                           ->  Seq Scan on t3
                           ->  Hash
                                 ->  Seq Scan on t4
         ->  Index Scan using t2_pkey on t2
               Index Cond: (id = t1.id)
 Optimizer: Postgres query optimizer
(15 rows)

/*+Leading(t3 t4 t1)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2, t3, t4 WHERE t1.id = t2.id AND t1.id = t3.id AND t1.id = t4.id;
LOG:  statement: /*+Leading(t3 t4 t1)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2, t3, t4 WHERE t1.id = t2.id AND t1.id = t3.id AND t1.id = t4.id;
WARNING:  "work_mem": setting is deprecated, and may be removed in a future release.
LOG:  pg_hint_plan:
used hint:
Leading(t3 t4 t1)
not used hint:
duplication hint:
error hint:
                      QUERY PLAN                      
------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Nested Loop
         ->  Hash Join
               Hash Cond: (t1.id = t3.id)
               ->  Seq Scan on t1
               ->  Hash
                     ->  Hash Join
                           Hash Cond: (t3.id = t4.id)
                           ->  Seq Scan on t3
                           ->  Hash
                                 ->  Seq Scan on t4
         ->  Index Scan using t2_pkey on t2
               Index Cond: (id = t1.id)
 Optimizer: Postgres query optimizer
(14 rows)

/*+Leading(t3 t4 t1 t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2, t3, t4 WHERE t1.id = t2.id AND t1.id = t3.id AND t1.id = t4.id;
LOG:  statement: /*+Leading(t3 t4 t1 t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2, t3, t4 WHERE t1.id = t2.id AND t1.id = t3.id AND t1.id = t4.id;
WARNING:  "work_mem": setting is deprecated, and may be removed in a future release.
LOG:  pg_hint_plan:
used hint:
Leading(t3 t4 t1 t2)
not used hint:
duplication hint:
error hint:
                         QUERY PLAN                         
------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t2.id = t1.id)
         ->  Seq Scan on t2
         ->  Hash
               ->  Hash Join
                     Hash Cond: (t1.id = t3.id)
                     ->  Seq Scan on t1
                     ->  Hash
                           ->  Hash Join
                                 Hash Cond: (t3.id = t4.id)
                                 ->  Seq Scan on t3
                                 ->  Hash
                                       ->  Seq Scan on t4
 Optimizer: Postgres query optimizer
(15 rows)

/*+Leading(t3 t4 t1 t2 t1)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2, t3, t4 WHERE t1.id = t2.id AND t1.id = t3.id AND t1.id = t4.id;
LOG:  statement: /*+Leading(t3 t4 t1 t2 t1)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2, t3, t4 WHERE t1.id = t2.id AND t1.id = t3.id AND t1.id = t4.id;
INFO:  pg_hint_plan: hint syntax error at or near "Leading(t3 t4 t1 t2 t1)"
DETAIL:  Relation name "t1" is duplicated.
LOG:  pg_hint_plan:
used hint:
not used hint:
duplication hint:
error hint:
Leading(t3 t4 t1 t2 t1)
                         QUERY PLAN                         
------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t1.id = t2.id)
         ->  Seq Scan on t1
         ->  Hash
               ->  Hash Join
                     Hash Cond: (t2.id = t3.id)
                     ->  Seq Scan on t2
                     ->  Hash
                           ->  Hash Join
                                 Hash Cond: (t3.id = t4.id)
                                 ->  Seq Scan on t3
                                 ->  Hash
                                       ->  Seq Scan on t4
 Optimizer: Postgres query optimizer
(15 rows)

/*+Leading(t3 t4 t4)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2, t3, t4 WHERE t1.id = t2.id AND t1.id = t3.id AND t1.id = t4.id;
LOG:  statement: /*+Leading(t3 t4 t4)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2, t3, t4 WHERE t1.id = t2.id AND t1.id = t3.id AND t1.id = t4.id;
INFO:  pg_hint_plan: hint syntax error at or near "Leading(t3 t4 t4)"
DETAIL:  Relation name "t4" is duplicated.
LOG:  pg_hint_plan:
used hint:
not used hint:
duplication hint:
error hint:
Leading(t3 t4 t4)
                         QUERY PLAN                         
------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t1.id = t2.id)
         ->  Seq Scan on t1
         ->  Hash
               ->  Hash Join
                     Hash Cond: (t2.id = t3.id)
                     ->  Seq Scan on t2
                     ->  Hash
                           ->  Hash Join
                                 Hash Cond: (t3.id = t4.id)
                                 ->  Seq Scan on t3
                                 ->  Hash
                                       ->  Seq Scan on t4
 Optimizer: Postgres query optimizer
(15 rows)

EXPLAIN (COSTS false) SELECT * FROM t1, (VALUES(1,1),(2,2),(3,3)) AS t2(id,val) WHERE t1.id = t2.id;
LOG:  statement: EXPLAIN (COSTS false) SELECT * FROM t1, (VALUES(1,1),(2,2),(3,3)) AS t2(id,val) WHERE t1.id = t2.id;
                   QUERY PLAN                    
-------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t1.id = "*VALUES*".column1)
         ->  Seq Scan on t1
         ->  Hash
               ->  Values Scan on "*VALUES*"
 Optimizer: Postgres query optimizer
(7 rows)

/*+HashJoin(t1 t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, (VALUES(1,1),(2,2),(3,3)) AS t2(id,val) WHERE t1.id = t2.id;
LOG:  statement: /*+HashJoin(t1 t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, (VALUES(1,1),(2,2),(3,3)) AS t2(id,val) WHERE t1.id = t2.id;
LOG:  pg_hint_plan:
used hint:
not used hint:
HashJoin(t1 t2)
duplication hint:
error hint:
                   QUERY PLAN                    
-------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t1.id = "*VALUES*".column1)
         ->  Seq Scan on t1
         ->  Hash
               ->  Values Scan on "*VALUES*"
 Optimizer: Postgres query optimizer
(7 rows)

/*+HashJoin(t1 *VALUES*)*/
EXPLAIN (COSTS false) SELECT * FROM t1, (VALUES(1,1),(2,2),(3,3)) AS t2(id,val) WHERE t1.id = t2.id;
LOG:  statement: /*+HashJoin(t1 *VALUES*)*/
EXPLAIN (COSTS false) SELECT * FROM t1, (VALUES(1,1),(2,2),(3,3)) AS t2(id,val) WHERE t1.id = t2.id;
WARNING:  "work_mem": setting is deprecated, and may be removed in a future release.
LOG:  pg_hint_plan:
used hint:
HashJoin(*VALUES* t1)
not used hint:
duplication hint:
error hint:
                   QUERY PLAN                    
-------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t1.id = "*VALUES*".column1)
         ->  Seq Scan on t1
         ->  Hash
               ->  Values Scan on "*VALUES*"
 Optimizer: Postgres query optimizer
(7 rows)

/*+HashJoin(t1 *VALUES*) IndexScan(t1) IndexScan(*VALUES*)*/
EXPLAIN (COSTS false) SELECT * FROM t1, (VALUES(1,1),(2,2),(3,3)) AS t2(id,val) WHERE t1.id = t2.id;
LOG:  statement: /*+HashJoin(t1 *VALUES*) IndexScan(t1) IndexScan(*VALUES*)*/
EXPLAIN (COSTS false) SELECT * FROM t1, (VALUES(1,1),(2,2),(3,3)) AS t2(id,val) WHERE t1.id = t2.id;
WARNING:  "work_mem": setting is deprecated, and may be removed in a future release.
LOG:  pg_hint_plan:
used hint:
IndexScan(t1)
HashJoin(*VALUES* t1)
not used hint:
IndexScan(*VALUES*)
duplication hint:
error hint:
                   QUERY PLAN                    
-------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t1.id = "*VALUES*".column1)
         ->  Index Scan using t1_pkey on t1
         ->  Hash
               ->  Values Scan on "*VALUES*"
 Optimizer: Postgres query optimizer
(7 rows)

-- single table scan hint test
EXPLAIN (COSTS false) SELECT (SELECT max(id) FROM t1 v_1 WHERE id < 10), id FROM v1 WHERE v1.id = (SELECT max(id) FROM t1 v_2 WHERE id < 10);
LOG:  statement: EXPLAIN (COSTS false) SELECT (SELECT max(id) FROM t1 v_1 WHERE id < 10), id FROM v1 WHERE v1.id = (SELECT max(id) FROM t1 v_2 WHERE id < 10);
                                  QUERY PLAN                                  
------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   InitPlan 2 (returns $1)  (slice2)
     ->  Result
           InitPlan 1 (returns $0)  (slice3)
             ->  Limit
                   ->  Gather Motion 3:1  (slice4; segments: 3)
                         Merge Key: v_1.id
                         ->  Index Only Scan Backward using t1_pkey on t1 v_1
                               Index Cond: ((id IS NOT NULL) AND (id < 10))
   InitPlan 4 (returns $3)  (slice5)
     ->  Result
           InitPlan 3 (returns $2)  (slice6)
             ->  Limit
                   ->  Gather Motion 3:1  (slice7; segments: 3)
                         Merge Key: v_2.id
                         ->  Index Only Scan Backward using t1_pkey on t1 v_2
                               Index Cond: ((id IS NOT NULL) AND (id < 10))
   ->  Index Only Scan using t1_pkey on t1
         Index Cond: (id = $3)
 Optimizer: Postgres query optimizer
(20 rows)

/*+BitmapScan(v_1)*/
EXPLAIN (COSTS false) SELECT (SELECT max(id) FROM t1 v_1 WHERE id < 10), id FROM v1 WHERE v1.id = (SELECT max(id) FROM t1 v_2 WHERE id < 10);
LOG:  statement: /*+BitmapScan(v_1)*/
EXPLAIN (COSTS false) SELECT (SELECT max(id) FROM t1 v_1 WHERE id < 10), id FROM v1 WHERE v1.id = (SELECT max(id) FROM t1 v_2 WHERE id < 10);
LOG:  pg_hint_plan:
used hint:
BitmapScan(v_1)
not used hint:
duplication hint:
error hint:
                                  QUERY PLAN                                  
------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   InitPlan 1 (returns $1)  (slice2)
     ->  Finalize Aggregate
           ->  Gather Motion 3:1  (slice3; segments: 3)
                 ->  Partial Aggregate
                       ->  Bitmap Heap Scan on t1 v_1
                             Recheck Cond: (id < 10)
                             ->  Bitmap Index Scan on t1_pkey
                                   Index Cond: (id < 10)
   InitPlan 3 (returns $3)  (slice4)
     ->  Result
           InitPlan 2 (returns $2)  (slice5)
             ->  Limit
                   ->  Gather Motion 3:1  (slice6; segments: 3)
                         Merge Key: v_2.id
                         ->  Index Only Scan Backward using t1_pkey on t1 v_2
                               Index Cond: ((id IS NOT NULL) AND (id < 10))
   ->  Index Only Scan using t1_pkey on t1
         Index Cond: (id = $3)
 Optimizer: Postgres query optimizer
(20 rows)

/*+BitmapScan(v_2)*/
EXPLAIN (COSTS false) SELECT (SELECT max(id) FROM t1 v_1 WHERE id < 10), id FROM v1 WHERE v1.id = (SELECT max(id) FROM t1 v_2 WHERE id < 10);
LOG:  statement: /*+BitmapScan(v_2)*/
EXPLAIN (COSTS false) SELECT (SELECT max(id) FROM t1 v_1 WHERE id < 10), id FROM v1 WHERE v1.id = (SELECT max(id) FROM t1 v_2 WHERE id < 10);
LOG:  pg_hint_plan:
used hint:
BitmapScan(v_2)
not used hint:
duplication hint:
error hint:
                                  QUERY PLAN                                  
------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   InitPlan 2 (returns $1)  (slice2)
     ->  Result
           InitPlan 1 (returns $0)  (slice3)
             ->  Limit
                   ->  Gather Motion 3:1  (slice4; segments: 3)
                         Merge Key: v_1.id
                         ->  Index Only Scan Backward using t1_pkey on t1 v_1
                               Index Cond: ((id IS NOT NULL) AND (id < 10))
   InitPlan 3 (returns $3)  (slice5)
     ->  Finalize Aggregate
           ->  Gather Motion 3:1  (slice6; segments: 3)
                 ->  Partial Aggregate
                       ->  Bitmap Heap Scan on t1 v_2
                             Recheck Cond: (id < 10)
                             ->  Bitmap Index Scan on t1_pkey
                                   Index Cond: (id < 10)
   ->  Index Only Scan using t1_pkey on t1
         Index Cond: (id = $3)
 Optimizer: Postgres query optimizer
(20 rows)

/*+BitmapScan(t1)*/
EXPLAIN (COSTS false) SELECT (SELECT max(id) FROM t1 v_1 WHERE id < 10), id FROM v1 WHERE v1.id = (SELECT max(id) FROM t1 v_2 WHERE id < 10);
LOG:  statement: /*+BitmapScan(t1)*/
EXPLAIN (COSTS false) SELECT (SELECT max(id) FROM t1 v_1 WHERE id < 10), id FROM v1 WHERE v1.id = (SELECT max(id) FROM t1 v_2 WHERE id < 10);
LOG:  pg_hint_plan:
used hint:
BitmapScan(t1)
not used hint:
duplication hint:
error hint:
                                  QUERY PLAN                                  
------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   InitPlan 2 (returns $1)  (slice2)
     ->  Result
           InitPlan 1 (returns $0)  (slice3)
             ->  Limit
                   ->  Gather Motion 3:1  (slice4; segments: 3)
                         Merge Key: v_1.id
                         ->  Index Only Scan Backward using t1_pkey on t1 v_1
                               Index Cond: ((id IS NOT NULL) AND (id < 10))
   InitPlan 4 (returns $3)  (slice5)
     ->  Result
           InitPlan 3 (returns $2)  (slice6)
             ->  Limit
                   ->  Gather Motion 3:1  (slice7; segments: 3)
                         Merge Key: v_2.id
                         ->  Index Only Scan Backward using t1_pkey on t1 v_2
                               Index Cond: ((id IS NOT NULL) AND (id < 10))
   ->  Bitmap Heap Scan on t1
         Recheck Cond: (id = $3)
         ->  Bitmap Index Scan on t1_pkey
               Index Cond: (id = $3)
 Optimizer: Postgres query optimizer
(22 rows)

/*+BitmapScan(v_1)BitmapScan(v_2)*/
EXPLAIN (COSTS false) SELECT (SELECT max(id) FROM t1 v_1 WHERE id < 10), id FROM v1 WHERE v1.id = (SELECT max(id) FROM t1 v_2 WHERE id < 10);
LOG:  statement: /*+BitmapScan(v_1)BitmapScan(v_2)*/
EXPLAIN (COSTS false) SELECT (SELECT max(id) FROM t1 v_1 WHERE id < 10), id FROM v1 WHERE v1.id = (SELECT max(id) FROM t1 v_2 WHERE id < 10);
LOG:  pg_hint_plan:
used hint:
BitmapScan(v_1)
BitmapScan(v_2)
not used hint:
duplication hint:
error hint:
                          QUERY PLAN                          
--------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   InitPlan 1 (returns $1)  (slice2)
     ->  Finalize Aggregate
           ->  Gather Motion 3:1  (slice3; segments: 3)
                 ->  Partial Aggregate
                       ->  Bitmap Heap Scan on t1 v_1
                             Recheck Cond: (id < 10)
                             ->  Bitmap Index Scan on t1_pkey
                                   Index Cond: (id < 10)
   InitPlan 2 (returns $3)  (slice4)
     ->  Finalize Aggregate
           ->  Gather Motion 3:1  (slice5; segments: 3)
                 ->  Partial Aggregate
                       ->  Bitmap Heap Scan on t1 v_2
                             Recheck Cond: (id < 10)
                             ->  Bitmap Index Scan on t1_pkey
                                   Index Cond: (id < 10)
   ->  Index Only Scan using t1_pkey on t1
         Index Cond: (id = $3)
 Optimizer: Postgres query optimizer
(20 rows)

/*+BitmapScan(v_1)BitmapScan(t1)*/
EXPLAIN (COSTS false) SELECT (SELECT max(id) FROM t1 v_1 WHERE id < 10), id FROM v1 WHERE v1.id = (SELECT max(id) FROM t1 v_2 WHERE id < 10);
LOG:  statement: /*+BitmapScan(v_1)BitmapScan(t1)*/
EXPLAIN (COSTS false) SELECT (SELECT max(id) FROM t1 v_1 WHERE id < 10), id FROM v1 WHERE v1.id = (SELECT max(id) FROM t1 v_2 WHERE id < 10);
LOG:  pg_hint_plan:
used hint:
BitmapScan(t1)
BitmapScan(v_1)
not used hint:
duplication hint:
error hint:
                                  QUERY PLAN                                  
------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   InitPlan 1 (returns $1)  (slice2)
     ->  Finalize Aggregate
           ->  Gather Motion 3:1  (slice3; segments: 3)
                 ->  Partial Aggregate
                       ->  Bitmap Heap Scan on t1 v_1
                             Recheck Cond: (id < 10)
                             ->  Bitmap Index Scan on t1_pkey
                                   Index Cond: (id < 10)
   InitPlan 3 (returns $3)  (slice4)
     ->  Result
           InitPlan 2 (returns $2)  (slice5)
             ->  Limit
                   ->  Gather Motion 3:1  (slice6; segments: 3)
                         Merge Key: v_2.id
                         ->  Index Only Scan Backward using t1_pkey on t1 v_2
                               Index Cond: ((id IS NOT NULL) AND (id < 10))
   ->  Bitmap Heap Scan on t1
         Recheck Cond: (id = $3)
         ->  Bitmap Index Scan on t1_pkey
               Index Cond: (id = $3)
 Optimizer: Postgres query optimizer
(22 rows)

/*+BitmapScan(v_2)BitmapScan(t1)*/
EXPLAIN (COSTS false) SELECT (SELECT max(id) FROM t1 v_1 WHERE id < 10), id FROM v1 WHERE v1.id = (SELECT max(id) FROM t1 v_2 WHERE id < 10);
LOG:  statement: /*+BitmapScan(v_2)BitmapScan(t1)*/
EXPLAIN (COSTS false) SELECT (SELECT max(id) FROM t1 v_1 WHERE id < 10), id FROM v1 WHERE v1.id = (SELECT max(id) FROM t1 v_2 WHERE id < 10);
LOG:  pg_hint_plan:
used hint:
BitmapScan(t1)
BitmapScan(v_2)
not used hint:
duplication hint:
error hint:
                                  QUERY PLAN                                  
------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   InitPlan 2 (returns $1)  (slice2)
     ->  Result
           InitPlan 1 (returns $0)  (slice3)
             ->  Limit
                   ->  Gather Motion 3:1  (slice4; segments: 3)
                         Merge Key: v_1.id
                         ->  Index Only Scan Backward using t1_pkey on t1 v_1
                               Index Cond: ((id IS NOT NULL) AND (id < 10))
   InitPlan 3 (returns $3)  (slice5)
     ->  Finalize Aggregate
           ->  Gather Motion 3:1  (slice6; segments: 3)
                 ->  Partial Aggregate
                       ->  Bitmap Heap Scan on t1 v_2
                             Recheck Cond: (id < 10)
                             ->  Bitmap Index Scan on t1_pkey
                                   Index Cond: (id < 10)
   ->  Bitmap Heap Scan on t1
         Recheck Cond: (id = $3)
         ->  Bitmap Index Scan on t1_pkey
               Index Cond: (id = $3)
 Optimizer: Postgres query optimizer
(22 rows)

/*+BitmapScan(v_1)BitmapScan(v_2)BitmapScan(t1)*/
EXPLAIN (COSTS false) SELECT (SELECT max(id) FROM t1 v_1 WHERE id < 10), id FROM v1 WHERE v1.id = (SELECT max(id) FROM t1 v_2 WHERE id < 10);
LOG:  statement: /*+BitmapScan(v_1)BitmapScan(v_2)BitmapScan(t1)*/
EXPLAIN (COSTS false) SELECT (SELECT max(id) FROM t1 v_1 WHERE id < 10), id FROM v1 WHERE v1.id = (SELECT max(id) FROM t1 v_2 WHERE id < 10);
LOG:  pg_hint_plan:
used hint:
BitmapScan(t1)
BitmapScan(v_1)
BitmapScan(v_2)
not used hint:
duplication hint:
error hint:
                          QUERY PLAN                          
--------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   InitPlan 1 (returns $1)  (slice2)
     ->  Finalize Aggregate
           ->  Gather Motion 3:1  (slice3; segments: 3)
                 ->  Partial Aggregate
                       ->  Bitmap Heap Scan on t1 v_1
                             Recheck Cond: (id < 10)
                             ->  Bitmap Index Scan on t1_pkey
                                   Index Cond: (id < 10)
   InitPlan 2 (returns $3)  (slice4)
     ->  Finalize Aggregate
           ->  Gather Motion 3:1  (slice5; segments: 3)
                 ->  Partial Aggregate
                       ->  Bitmap Heap Scan on t1 v_2
                             Recheck Cond: (id < 10)
                             ->  Bitmap Index Scan on t1_pkey
                                   Index Cond: (id < 10)
   ->  Bitmap Heap Scan on t1
         Recheck Cond: (id = $3)
         ->  Bitmap Index Scan on t1_pkey
               Index Cond: (id = $3)
 Optimizer: Postgres query optimizer
(22 rows)

-- full scan hint pattern test
EXPLAIN (COSTS false) SELECT * FROM t1 WHERE id < 10 AND ctid = '(1,1)';
LOG:  statement: EXPLAIN (COSTS false) SELECT * FROM t1 WHERE id < 10 AND ctid = '(1,1)';
NOTICE:  SELECT uses system-defined column "t1.ctid" without the necessary companion column "t1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
                QUERY PLAN                
------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Tid Scan on t1
         TID Cond: (ctid = '(1,1)'::tid)
         Filter: (id < 10)
 Optimizer: Postgres query optimizer
(5 rows)

/*+SeqScan(t1)*/
EXPLAIN (COSTS false) SELECT * FROM t1 WHERE id < 10 AND ctid = '(1,1)';
LOG:  statement: /*+SeqScan(t1)*/
EXPLAIN (COSTS false) SELECT * FROM t1 WHERE id < 10 AND ctid = '(1,1)';
NOTICE:  SELECT uses system-defined column "t1.ctid" without the necessary companion column "t1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  pg_hint_plan:
used hint:
SeqScan(t1)
not used hint:
duplication hint:
error hint:
                      QUERY PLAN                       
-------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Seq Scan on t1
         Filter: ((id < 10) AND (ctid = '(1,1)'::tid))
 Optimizer: Postgres query optimizer
(4 rows)

/*+IndexScan(t1)*/
EXPLAIN (COSTS false) SELECT * FROM t1 WHERE id < 10 AND ctid = '(1,1)';
LOG:  statement: /*+IndexScan(t1)*/
EXPLAIN (COSTS false) SELECT * FROM t1 WHERE id < 10 AND ctid = '(1,1)';
NOTICE:  SELECT uses system-defined column "t1.ctid" without the necessary companion column "t1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  pg_hint_plan:
used hint:
IndexScan(t1)
not used hint:
duplication hint:
error hint:
                QUERY PLAN                
------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Index Scan using t1_pkey on t1
         Index Cond: (id < 10)
         Filter: (ctid = '(1,1)'::tid)
 Optimizer: Postgres query optimizer
(5 rows)

/*+BitmapScan(t1)*/
EXPLAIN (COSTS false) SELECT * FROM t1 WHERE id < 10 AND ctid = '(1,1)';
LOG:  statement: /*+BitmapScan(t1)*/
EXPLAIN (COSTS false) SELECT * FROM t1 WHERE id < 10 AND ctid = '(1,1)';
NOTICE:  SELECT uses system-defined column "t1.ctid" without the necessary companion column "t1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  pg_hint_plan:
used hint:
BitmapScan(t1)
not used hint:
duplication hint:
error hint:
                QUERY PLAN                
------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Bitmap Heap Scan on t1
         Recheck Cond: (id < 10)
         Filter: (ctid = '(1,1)'::tid)
         ->  Bitmap Index Scan on t1_pkey
               Index Cond: (id < 10)
 Optimizer: Postgres query optimizer
(7 rows)

/*+TidScan(t1)*/
EXPLAIN (COSTS false) SELECT * FROM t1 WHERE id < 10 AND ctid = '(1,1)';
LOG:  statement: /*+TidScan(t1)*/
EXPLAIN (COSTS false) SELECT * FROM t1 WHERE id < 10 AND ctid = '(1,1)';
NOTICE:  SELECT uses system-defined column "t1.ctid" without the necessary companion column "t1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  pg_hint_plan:
used hint:
TidScan(t1)
not used hint:
duplication hint:
error hint:
                QUERY PLAN                
------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Tid Scan on t1
         TID Cond: (ctid = '(1,1)'::tid)
         Filter: (id < 10)
 Optimizer: Postgres query optimizer
(5 rows)

/*+NoSeqScan(t1)*/
EXPLAIN (COSTS false) SELECT * FROM t1 WHERE id < 10 AND ctid = '(1,1)';
LOG:  statement: /*+NoSeqScan(t1)*/
EXPLAIN (COSTS false) SELECT * FROM t1 WHERE id < 10 AND ctid = '(1,1)';
NOTICE:  SELECT uses system-defined column "t1.ctid" without the necessary companion column "t1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  pg_hint_plan:
used hint:
NoSeqScan(t1)
not used hint:
duplication hint:
error hint:
                QUERY PLAN                
------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Tid Scan on t1
         TID Cond: (ctid = '(1,1)'::tid)
         Filter: (id < 10)
 Optimizer: Postgres query optimizer
(5 rows)

/*+NoIndexScan(t1)*/
EXPLAIN (COSTS false) SELECT * FROM t1 WHERE id < 10 AND ctid = '(1,1)';
LOG:  statement: /*+NoIndexScan(t1)*/
EXPLAIN (COSTS false) SELECT * FROM t1 WHERE id < 10 AND ctid = '(1,1)';
NOTICE:  SELECT uses system-defined column "t1.ctid" without the necessary companion column "t1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  pg_hint_plan:
used hint:
NoIndexScan(t1)
not used hint:
duplication hint:
error hint:
                QUERY PLAN                
------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Tid Scan on t1
         TID Cond: (ctid = '(1,1)'::tid)
         Filter: (id < 10)
 Optimizer: Postgres query optimizer
(5 rows)

/*+NoBitmapScan(t1)*/
EXPLAIN (COSTS false) SELECT * FROM t1 WHERE id < 10 AND ctid = '(1,1)';
LOG:  statement: /*+NoBitmapScan(t1)*/
EXPLAIN (COSTS false) SELECT * FROM t1 WHERE id < 10 AND ctid = '(1,1)';
NOTICE:  SELECT uses system-defined column "t1.ctid" without the necessary companion column "t1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  pg_hint_plan:
used hint:
NoBitmapScan(t1)
not used hint:
duplication hint:
error hint:
                QUERY PLAN                
------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Tid Scan on t1
         TID Cond: (ctid = '(1,1)'::tid)
         Filter: (id < 10)
 Optimizer: Postgres query optimizer
(5 rows)

/*+NoTidScan(t1)*/
EXPLAIN (COSTS false) SELECT * FROM t1 WHERE id < 10 AND ctid = '(1,1)';
LOG:  statement: /*+NoTidScan(t1)*/
EXPLAIN (COSTS false) SELECT * FROM t1 WHERE id < 10 AND ctid = '(1,1)';
NOTICE:  SELECT uses system-defined column "t1.ctid" without the necessary companion column "t1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  pg_hint_plan:
used hint:
NoTidScan(t1)
not used hint:
duplication hint:
error hint:
                QUERY PLAN                
------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Bitmap Heap Scan on t1
         Recheck Cond: (id < 10)
         Filter: (ctid = '(1,1)'::tid)
         ->  Bitmap Index Scan on t1_pkey
               Index Cond: (id < 10)
 Optimizer: Postgres query optimizer
(7 rows)

EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
LOG:  statement: EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
NOTICE:  SELECT uses system-defined column "t1.ctid" without the necessary companion column "t1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
NOTICE:  SELECT uses system-defined column "t2.ctid" without the necessary companion column "t2.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
                     QUERY PLAN                      
-----------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t1.id = t2.id)
         ->  Tid Scan on t1
               TID Cond: (ctid = '(1,1)'::tid)
         ->  Hash
               ->  Tid Scan on t2
                     TID Cond: (ctid = '(1,1)'::tid)
 Optimizer: Postgres query optimizer
(9 rows)

/*+SeqScan(t1)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
LOG:  statement: /*+SeqScan(t1)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
NOTICE:  SELECT uses system-defined column "t1.ctid" without the necessary companion column "t1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
NOTICE:  SELECT uses system-defined column "t2.ctid" without the necessary companion column "t2.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  pg_hint_plan:
used hint:
SeqScan(t1)
not used hint:
duplication hint:
error hint:
                     QUERY PLAN                      
-----------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t1.id = t2.id)
         ->  Seq Scan on t1
               Filter: (ctid = '(1,1)'::tid)
         ->  Hash
               ->  Tid Scan on t2
                     TID Cond: (ctid = '(1,1)'::tid)
 Optimizer: Postgres query optimizer
(9 rows)

/*+SeqScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
LOG:  statement: /*+SeqScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
NOTICE:  SELECT uses system-defined column "t1.ctid" without the necessary companion column "t1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
NOTICE:  SELECT uses system-defined column "t2.ctid" without the necessary companion column "t2.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  pg_hint_plan:
used hint:
SeqScan(t2)
not used hint:
duplication hint:
error hint:
                     QUERY PLAN                      
-----------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t2.id = t1.id)
         ->  Seq Scan on t2
               Filter: (ctid = '(1,1)'::tid)
         ->  Hash
               ->  Tid Scan on t1
                     TID Cond: (ctid = '(1,1)'::tid)
 Optimizer: Postgres query optimizer
(9 rows)

/*+SeqScan(t1) SeqScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
LOG:  statement: /*+SeqScan(t1) SeqScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
NOTICE:  SELECT uses system-defined column "t1.ctid" without the necessary companion column "t1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
NOTICE:  SELECT uses system-defined column "t2.ctid" without the necessary companion column "t2.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  pg_hint_plan:
used hint:
SeqScan(t1)
SeqScan(t2)
not used hint:
duplication hint:
error hint:
                    QUERY PLAN                     
---------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t1.id = t2.id)
         ->  Seq Scan on t1
               Filter: (ctid = '(1,1)'::tid)
         ->  Hash
               ->  Seq Scan on t2
                     Filter: (ctid = '(1,1)'::tid)
 Optimizer: Postgres query optimizer
(9 rows)

/*+SeqScan(t1) IndexScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
LOG:  statement: /*+SeqScan(t1) IndexScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
NOTICE:  SELECT uses system-defined column "t1.ctid" without the necessary companion column "t1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
NOTICE:  SELECT uses system-defined column "t2.ctid" without the necessary companion column "t2.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  pg_hint_plan:
used hint:
SeqScan(t1)
IndexScan(t2)
not used hint:
duplication hint:
error hint:
                    QUERY PLAN                     
---------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t1.id = t2.id)
         ->  Seq Scan on t1
               Filter: (ctid = '(1,1)'::tid)
         ->  Hash
               ->  Index Scan using t2_pkey on t2
                     Filter: (ctid = '(1,1)'::tid)
 Optimizer: Postgres query optimizer
(9 rows)

/*+SeqScan(t1) BitmapScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
LOG:  statement: /*+SeqScan(t1) BitmapScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
NOTICE:  SELECT uses system-defined column "t1.ctid" without the necessary companion column "t1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
NOTICE:  SELECT uses system-defined column "t2.ctid" without the necessary companion column "t2.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  pg_hint_plan:
used hint:
SeqScan(t1)
BitmapScan(t2)
not used hint:
duplication hint:
error hint:
                      QUERY PLAN                      
------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t1.id = t2.id)
         ->  Seq Scan on t1
               Filter: (ctid = '(1,1)'::tid)
         ->  Hash
               ->  Bitmap Heap Scan on t2
                     Filter: (ctid = '(1,1)'::tid)
                     ->  Bitmap Index Scan on t2_pkey
 Optimizer: Postgres query optimizer
(10 rows)

/*+SeqScan(t1) TidScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
LOG:  statement: /*+SeqScan(t1) TidScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
NOTICE:  SELECT uses system-defined column "t1.ctid" without the necessary companion column "t1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
NOTICE:  SELECT uses system-defined column "t2.ctid" without the necessary companion column "t2.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  pg_hint_plan:
used hint:
SeqScan(t1)
TidScan(t2)
not used hint:
duplication hint:
error hint:
                     QUERY PLAN                      
-----------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t1.id = t2.id)
         ->  Seq Scan on t1
               Filter: (ctid = '(1,1)'::tid)
         ->  Hash
               ->  Tid Scan on t2
                     TID Cond: (ctid = '(1,1)'::tid)
 Optimizer: Postgres query optimizer
(9 rows)

/*+SeqScan(t1) NoSeqScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
LOG:  statement: /*+SeqScan(t1) NoSeqScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
NOTICE:  SELECT uses system-defined column "t1.ctid" without the necessary companion column "t1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
NOTICE:  SELECT uses system-defined column "t2.ctid" without the necessary companion column "t2.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  pg_hint_plan:
used hint:
SeqScan(t1)
NoSeqScan(t2)
not used hint:
duplication hint:
error hint:
                     QUERY PLAN                      
-----------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t1.id = t2.id)
         ->  Seq Scan on t1
               Filter: (ctid = '(1,1)'::tid)
         ->  Hash
               ->  Tid Scan on t2
                     TID Cond: (ctid = '(1,1)'::tid)
 Optimizer: Postgres query optimizer
(9 rows)

/*+SeqScan(t1) NoIndexScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
LOG:  statement: /*+SeqScan(t1) NoIndexScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
NOTICE:  SELECT uses system-defined column "t1.ctid" without the necessary companion column "t1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
NOTICE:  SELECT uses system-defined column "t2.ctid" without the necessary companion column "t2.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  pg_hint_plan:
used hint:
SeqScan(t1)
NoIndexScan(t2)
not used hint:
duplication hint:
error hint:
                     QUERY PLAN                      
-----------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t1.id = t2.id)
         ->  Seq Scan on t1
               Filter: (ctid = '(1,1)'::tid)
         ->  Hash
               ->  Tid Scan on t2
                     TID Cond: (ctid = '(1,1)'::tid)
 Optimizer: Postgres query optimizer
(9 rows)

/*+SeqScan(t1) NoBitmapScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
LOG:  statement: /*+SeqScan(t1) NoBitmapScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
NOTICE:  SELECT uses system-defined column "t1.ctid" without the necessary companion column "t1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
NOTICE:  SELECT uses system-defined column "t2.ctid" without the necessary companion column "t2.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  pg_hint_plan:
used hint:
SeqScan(t1)
NoBitmapScan(t2)
not used hint:
duplication hint:
error hint:
                     QUERY PLAN                      
-----------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t1.id = t2.id)
         ->  Seq Scan on t1
               Filter: (ctid = '(1,1)'::tid)
         ->  Hash
               ->  Tid Scan on t2
                     TID Cond: (ctid = '(1,1)'::tid)
 Optimizer: Postgres query optimizer
(9 rows)

/*+SeqScan(t1) NoTidScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
LOG:  statement: /*+SeqScan(t1) NoTidScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
NOTICE:  SELECT uses system-defined column "t1.ctid" without the necessary companion column "t1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
NOTICE:  SELECT uses system-defined column "t2.ctid" without the necessary companion column "t2.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  pg_hint_plan:
used hint:
SeqScan(t1)
NoTidScan(t2)
not used hint:
duplication hint:
error hint:
                    QUERY PLAN                     
---------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t1.id = t2.id)
         ->  Seq Scan on t1
               Filter: (ctid = '(1,1)'::tid)
         ->  Hash
               ->  Seq Scan on t2
                     Filter: (ctid = '(1,1)'::tid)
 Optimizer: Postgres query optimizer
(9 rows)

/*+IndexScan(t1)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
LOG:  statement: /*+IndexScan(t1)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
NOTICE:  SELECT uses system-defined column "t1.ctid" without the necessary companion column "t1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
NOTICE:  SELECT uses system-defined column "t2.ctid" without the necessary companion column "t2.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  pg_hint_plan:
used hint:
IndexScan(t1)
not used hint:
duplication hint:
error hint:
                     QUERY PLAN                      
-----------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t1.id = t2.id)
         ->  Index Scan using t1_pkey on t1
               Filter: (ctid = '(1,1)'::tid)
         ->  Hash
               ->  Tid Scan on t2
                     TID Cond: (ctid = '(1,1)'::tid)
 Optimizer: Postgres query optimizer
(9 rows)

/*+IndexScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
LOG:  statement: /*+IndexScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
NOTICE:  SELECT uses system-defined column "t1.ctid" without the necessary companion column "t1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
NOTICE:  SELECT uses system-defined column "t2.ctid" without the necessary companion column "t2.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  pg_hint_plan:
used hint:
IndexScan(t2)
not used hint:
duplication hint:
error hint:
                     QUERY PLAN                      
-----------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t2.id = t1.id)
         ->  Index Scan using t2_pkey on t2
               Filter: (ctid = '(1,1)'::tid)
         ->  Hash
               ->  Tid Scan on t1
                     TID Cond: (ctid = '(1,1)'::tid)
 Optimizer: Postgres query optimizer
(9 rows)

/*+IndexScan(t1) SeqScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
LOG:  statement: /*+IndexScan(t1) SeqScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
NOTICE:  SELECT uses system-defined column "t1.ctid" without the necessary companion column "t1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
NOTICE:  SELECT uses system-defined column "t2.ctid" without the necessary companion column "t2.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  pg_hint_plan:
used hint:
IndexScan(t1)
SeqScan(t2)
not used hint:
duplication hint:
error hint:
                    QUERY PLAN                     
---------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t1.id = t2.id)
         ->  Index Scan using t1_pkey on t1
               Filter: (ctid = '(1,1)'::tid)
         ->  Hash
               ->  Seq Scan on t2
                     Filter: (ctid = '(1,1)'::tid)
 Optimizer: Postgres query optimizer
(9 rows)

/*+IndexScan(t1) IndexScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
LOG:  statement: /*+IndexScan(t1) IndexScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
NOTICE:  SELECT uses system-defined column "t1.ctid" without the necessary companion column "t1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
NOTICE:  SELECT uses system-defined column "t2.ctid" without the necessary companion column "t2.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  pg_hint_plan:
used hint:
IndexScan(t1)
IndexScan(t2)
not used hint:
duplication hint:
error hint:
                    QUERY PLAN                     
---------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t1.id = t2.id)
         ->  Index Scan using t1_pkey on t1
               Filter: (ctid = '(1,1)'::tid)
         ->  Hash
               ->  Index Scan using t2_pkey on t2
                     Filter: (ctid = '(1,1)'::tid)
 Optimizer: Postgres query optimizer
(9 rows)

/*+IndexScan(t1) BitmapScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
LOG:  statement: /*+IndexScan(t1) BitmapScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
NOTICE:  SELECT uses system-defined column "t1.ctid" without the necessary companion column "t1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
NOTICE:  SELECT uses system-defined column "t2.ctid" without the necessary companion column "t2.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  pg_hint_plan:
used hint:
IndexScan(t1)
BitmapScan(t2)
not used hint:
duplication hint:
error hint:
                      QUERY PLAN                      
------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t1.id = t2.id)
         ->  Index Scan using t1_pkey on t1
               Filter: (ctid = '(1,1)'::tid)
         ->  Hash
               ->  Bitmap Heap Scan on t2
                     Filter: (ctid = '(1,1)'::tid)
                     ->  Bitmap Index Scan on t2_pkey
 Optimizer: Postgres query optimizer
(10 rows)

/*+IndexScan(t1) TidScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
LOG:  statement: /*+IndexScan(t1) TidScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
NOTICE:  SELECT uses system-defined column "t1.ctid" without the necessary companion column "t1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
NOTICE:  SELECT uses system-defined column "t2.ctid" without the necessary companion column "t2.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  pg_hint_plan:
used hint:
IndexScan(t1)
TidScan(t2)
not used hint:
duplication hint:
error hint:
                     QUERY PLAN                      
-----------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t1.id = t2.id)
         ->  Index Scan using t1_pkey on t1
               Filter: (ctid = '(1,1)'::tid)
         ->  Hash
               ->  Tid Scan on t2
                     TID Cond: (ctid = '(1,1)'::tid)
 Optimizer: Postgres query optimizer
(9 rows)

/*+IndexScan(t1) NoSeqScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
LOG:  statement: /*+IndexScan(t1) NoSeqScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
NOTICE:  SELECT uses system-defined column "t1.ctid" without the necessary companion column "t1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
NOTICE:  SELECT uses system-defined column "t2.ctid" without the necessary companion column "t2.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  pg_hint_plan:
used hint:
IndexScan(t1)
NoSeqScan(t2)
not used hint:
duplication hint:
error hint:
                     QUERY PLAN                      
-----------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t1.id = t2.id)
         ->  Index Scan using t1_pkey on t1
               Filter: (ctid = '(1,1)'::tid)
         ->  Hash
               ->  Tid Scan on t2
                     TID Cond: (ctid = '(1,1)'::tid)
 Optimizer: Postgres query optimizer
(9 rows)

/*+IndexScan(t1) NoIndexScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
LOG:  statement: /*+IndexScan(t1) NoIndexScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
NOTICE:  SELECT uses system-defined column "t1.ctid" without the necessary companion column "t1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
NOTICE:  SELECT uses system-defined column "t2.ctid" without the necessary companion column "t2.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  pg_hint_plan:
used hint:
IndexScan(t1)
NoIndexScan(t2)
not used hint:
duplication hint:
error hint:
                     QUERY PLAN                      
-----------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t1.id = t2.id)
         ->  Index Scan using t1_pkey on t1
               Filter: (ctid = '(1,1)'::tid)
         ->  Hash
               ->  Tid Scan on t2
                     TID Cond: (ctid = '(1,1)'::tid)
 Optimizer: Postgres query optimizer
(9 rows)

/*+IndexScan(t1) NoBitmapScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
LOG:  statement: /*+IndexScan(t1) NoBitmapScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
NOTICE:  SELECT uses system-defined column "t1.ctid" without the necessary companion column "t1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
NOTICE:  SELECT uses system-defined column "t2.ctid" without the necessary companion column "t2.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  pg_hint_plan:
used hint:
IndexScan(t1)
NoBitmapScan(t2)
not used hint:
duplication hint:
error hint:
                     QUERY PLAN                      
-----------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t1.id = t2.id)
         ->  Index Scan using t1_pkey on t1
               Filter: (ctid = '(1,1)'::tid)
         ->  Hash
               ->  Tid Scan on t2
                     TID Cond: (ctid = '(1,1)'::tid)
 Optimizer: Postgres query optimizer
(9 rows)

/*+IndexScan(t1) NoTidScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
LOG:  statement: /*+IndexScan(t1) NoTidScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
NOTICE:  SELECT uses system-defined column "t1.ctid" without the necessary companion column "t1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
NOTICE:  SELECT uses system-defined column "t2.ctid" without the necessary companion column "t2.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  pg_hint_plan:
used hint:
IndexScan(t1)
NoTidScan(t2)
not used hint:
duplication hint:
error hint:
                    QUERY PLAN                     
---------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t1.id = t2.id)
         ->  Index Scan using t1_pkey on t1
               Filter: (ctid = '(1,1)'::tid)
         ->  Hash
               ->  Seq Scan on t2
                     Filter: (ctid = '(1,1)'::tid)
 Optimizer: Postgres query optimizer
(9 rows)

/*+BitmapScan(t1)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
LOG:  statement: /*+BitmapScan(t1)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
NOTICE:  SELECT uses system-defined column "t1.ctid" without the necessary companion column "t1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
NOTICE:  SELECT uses system-defined column "t2.ctid" without the necessary companion column "t2.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  pg_hint_plan:
used hint:
BitmapScan(t1)
not used hint:
duplication hint:
error hint:
                     QUERY PLAN                      
-----------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t1.id = t2.id)
         ->  Bitmap Heap Scan on t1
               Filter: (ctid = '(1,1)'::tid)
               ->  Bitmap Index Scan on t1_pkey
         ->  Hash
               ->  Tid Scan on t2
                     TID Cond: (ctid = '(1,1)'::tid)
 Optimizer: Postgres query optimizer
(10 rows)

/*+BitmapScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
LOG:  statement: /*+BitmapScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
NOTICE:  SELECT uses system-defined column "t1.ctid" without the necessary companion column "t1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
NOTICE:  SELECT uses system-defined column "t2.ctid" without the necessary companion column "t2.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  pg_hint_plan:
used hint:
BitmapScan(t2)
not used hint:
duplication hint:
error hint:
                     QUERY PLAN                      
-----------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t2.id = t1.id)
         ->  Bitmap Heap Scan on t2
               Filter: (ctid = '(1,1)'::tid)
               ->  Bitmap Index Scan on t2_pkey
         ->  Hash
               ->  Tid Scan on t1
                     TID Cond: (ctid = '(1,1)'::tid)
 Optimizer: Postgres query optimizer
(10 rows)

/*+BitmapScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
LOG:  statement: /*+BitmapScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
NOTICE:  SELECT uses system-defined column "t1.ctid" without the necessary companion column "t1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
NOTICE:  SELECT uses system-defined column "t2.ctid" without the necessary companion column "t2.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  pg_hint_plan:
used hint:
BitmapScan(t2)
not used hint:
duplication hint:
error hint:
                     QUERY PLAN                      
-----------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t2.id = t1.id)
         ->  Bitmap Heap Scan on t2
               Filter: (ctid = '(1,1)'::tid)
               ->  Bitmap Index Scan on t2_pkey
         ->  Hash
               ->  Tid Scan on t1
                     TID Cond: (ctid = '(1,1)'::tid)
 Optimizer: Postgres query optimizer
(10 rows)

/*+BitmapScan(t1) SeqScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
LOG:  statement: /*+BitmapScan(t1) SeqScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
NOTICE:  SELECT uses system-defined column "t1.ctid" without the necessary companion column "t1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
NOTICE:  SELECT uses system-defined column "t2.ctid" without the necessary companion column "t2.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  pg_hint_plan:
used hint:
BitmapScan(t1)
SeqScan(t2)
not used hint:
duplication hint:
error hint:
                    QUERY PLAN                     
---------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t1.id = t2.id)
         ->  Bitmap Heap Scan on t1
               Filter: (ctid = '(1,1)'::tid)
               ->  Bitmap Index Scan on t1_pkey
         ->  Hash
               ->  Seq Scan on t2
                     Filter: (ctid = '(1,1)'::tid)
 Optimizer: Postgres query optimizer
(10 rows)

/*+BitmapScan(t1) IndexScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
LOG:  statement: /*+BitmapScan(t1) IndexScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
NOTICE:  SELECT uses system-defined column "t1.ctid" without the necessary companion column "t1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
NOTICE:  SELECT uses system-defined column "t2.ctid" without the necessary companion column "t2.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  pg_hint_plan:
used hint:
BitmapScan(t1)
IndexScan(t2)
not used hint:
duplication hint:
error hint:
                    QUERY PLAN                     
---------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t1.id = t2.id)
         ->  Bitmap Heap Scan on t1
               Filter: (ctid = '(1,1)'::tid)
               ->  Bitmap Index Scan on t1_pkey
         ->  Hash
               ->  Index Scan using t2_pkey on t2
                     Filter: (ctid = '(1,1)'::tid)
 Optimizer: Postgres query optimizer
(10 rows)

/*+BitmapScan(t1) BitmapScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
LOG:  statement: /*+BitmapScan(t1) BitmapScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
NOTICE:  SELECT uses system-defined column "t1.ctid" without the necessary companion column "t1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
NOTICE:  SELECT uses system-defined column "t2.ctid" without the necessary companion column "t2.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  pg_hint_plan:
used hint:
BitmapScan(t1)
BitmapScan(t2)
not used hint:
duplication hint:
error hint:
                      QUERY PLAN                      
------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t1.id = t2.id)
         ->  Bitmap Heap Scan on t1
               Filter: (ctid = '(1,1)'::tid)
               ->  Bitmap Index Scan on t1_pkey
         ->  Hash
               ->  Bitmap Heap Scan on t2
                     Filter: (ctid = '(1,1)'::tid)
                     ->  Bitmap Index Scan on t2_pkey
 Optimizer: Postgres query optimizer
(11 rows)

/*+BitmapScan(t1) TidScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
LOG:  statement: /*+BitmapScan(t1) TidScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
NOTICE:  SELECT uses system-defined column "t1.ctid" without the necessary companion column "t1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
NOTICE:  SELECT uses system-defined column "t2.ctid" without the necessary companion column "t2.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  pg_hint_plan:
used hint:
BitmapScan(t1)
TidScan(t2)
not used hint:
duplication hint:
error hint:
                     QUERY PLAN                      
-----------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t1.id = t2.id)
         ->  Bitmap Heap Scan on t1
               Filter: (ctid = '(1,1)'::tid)
               ->  Bitmap Index Scan on t1_pkey
         ->  Hash
               ->  Tid Scan on t2
                     TID Cond: (ctid = '(1,1)'::tid)
 Optimizer: Postgres query optimizer
(10 rows)

/*+BitmapScan(t1) NoSeqScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
LOG:  statement: /*+BitmapScan(t1) NoSeqScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
NOTICE:  SELECT uses system-defined column "t1.ctid" without the necessary companion column "t1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
NOTICE:  SELECT uses system-defined column "t2.ctid" without the necessary companion column "t2.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  pg_hint_plan:
used hint:
BitmapScan(t1)
NoSeqScan(t2)
not used hint:
duplication hint:
error hint:
                     QUERY PLAN                      
-----------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t1.id = t2.id)
         ->  Bitmap Heap Scan on t1
               Filter: (ctid = '(1,1)'::tid)
               ->  Bitmap Index Scan on t1_pkey
         ->  Hash
               ->  Tid Scan on t2
                     TID Cond: (ctid = '(1,1)'::tid)
 Optimizer: Postgres query optimizer
(10 rows)

/*+BitmapScan(t1) NoIndexScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
LOG:  statement: /*+BitmapScan(t1) NoIndexScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
NOTICE:  SELECT uses system-defined column "t1.ctid" without the necessary companion column "t1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
NOTICE:  SELECT uses system-defined column "t2.ctid" without the necessary companion column "t2.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  pg_hint_plan:
used hint:
BitmapScan(t1)
NoIndexScan(t2)
not used hint:
duplication hint:
error hint:
                     QUERY PLAN                      
-----------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t1.id = t2.id)
         ->  Bitmap Heap Scan on t1
               Filter: (ctid = '(1,1)'::tid)
               ->  Bitmap Index Scan on t1_pkey
         ->  Hash
               ->  Tid Scan on t2
                     TID Cond: (ctid = '(1,1)'::tid)
 Optimizer: Postgres query optimizer
(10 rows)

/*+BitmapScan(t1) NoBitmapScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
LOG:  statement: /*+BitmapScan(t1) NoBitmapScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
NOTICE:  SELECT uses system-defined column "t1.ctid" without the necessary companion column "t1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
NOTICE:  SELECT uses system-defined column "t2.ctid" without the necessary companion column "t2.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  pg_hint_plan:
used hint:
BitmapScan(t1)
NoBitmapScan(t2)
not used hint:
duplication hint:
error hint:
                     QUERY PLAN                      
-----------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t1.id = t2.id)
         ->  Bitmap Heap Scan on t1
               Filter: (ctid = '(1,1)'::tid)
               ->  Bitmap Index Scan on t1_pkey
         ->  Hash
               ->  Tid Scan on t2
                     TID Cond: (ctid = '(1,1)'::tid)
 Optimizer: Postgres query optimizer
(10 rows)

/*+BitmapScan(t1) NoTidScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
LOG:  statement: /*+BitmapScan(t1) NoTidScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
NOTICE:  SELECT uses system-defined column "t1.ctid" without the necessary companion column "t1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
NOTICE:  SELECT uses system-defined column "t2.ctid" without the necessary companion column "t2.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  pg_hint_plan:
used hint:
BitmapScan(t1)
NoTidScan(t2)
not used hint:
duplication hint:
error hint:
                    QUERY PLAN                     
---------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t1.id = t2.id)
         ->  Bitmap Heap Scan on t1
               Filter: (ctid = '(1,1)'::tid)
               ->  Bitmap Index Scan on t1_pkey
         ->  Hash
               ->  Seq Scan on t2
                     Filter: (ctid = '(1,1)'::tid)
 Optimizer: Postgres query optimizer
(10 rows)

/*+TidScan(t1)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
LOG:  statement: /*+TidScan(t1)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
NOTICE:  SELECT uses system-defined column "t1.ctid" without the necessary companion column "t1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
NOTICE:  SELECT uses system-defined column "t2.ctid" without the necessary companion column "t2.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  pg_hint_plan:
used hint:
TidScan(t1)
not used hint:
duplication hint:
error hint:
                     QUERY PLAN                      
-----------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t2.id = t1.id)
         ->  Tid Scan on t2
               TID Cond: (ctid = '(1,1)'::tid)
         ->  Hash
               ->  Tid Scan on t1
                     TID Cond: (ctid = '(1,1)'::tid)
 Optimizer: Postgres query optimizer
(9 rows)

/*+TidScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
LOG:  statement: /*+TidScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
NOTICE:  SELECT uses system-defined column "t1.ctid" without the necessary companion column "t1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
NOTICE:  SELECT uses system-defined column "t2.ctid" without the necessary companion column "t2.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  pg_hint_plan:
used hint:
TidScan(t2)
not used hint:
duplication hint:
error hint:
                     QUERY PLAN                      
-----------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t1.id = t2.id)
         ->  Tid Scan on t1
               TID Cond: (ctid = '(1,1)'::tid)
         ->  Hash
               ->  Tid Scan on t2
                     TID Cond: (ctid = '(1,1)'::tid)
 Optimizer: Postgres query optimizer
(9 rows)

/*+TidScan(t1) SeqScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
LOG:  statement: /*+TidScan(t1) SeqScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
NOTICE:  SELECT uses system-defined column "t1.ctid" without the necessary companion column "t1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
NOTICE:  SELECT uses system-defined column "t2.ctid" without the necessary companion column "t2.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  pg_hint_plan:
used hint:
TidScan(t1)
SeqScan(t2)
not used hint:
duplication hint:
error hint:
                     QUERY PLAN                      
-----------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t2.id = t1.id)
         ->  Seq Scan on t2
               Filter: (ctid = '(1,1)'::tid)
         ->  Hash
               ->  Tid Scan on t1
                     TID Cond: (ctid = '(1,1)'::tid)
 Optimizer: Postgres query optimizer
(9 rows)

/*+TidScan(t1) IndexScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
LOG:  statement: /*+TidScan(t1) IndexScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
NOTICE:  SELECT uses system-defined column "t1.ctid" without the necessary companion column "t1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
NOTICE:  SELECT uses system-defined column "t2.ctid" without the necessary companion column "t2.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  pg_hint_plan:
used hint:
TidScan(t1)
IndexScan(t2)
not used hint:
duplication hint:
error hint:
                     QUERY PLAN                      
-----------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t2.id = t1.id)
         ->  Index Scan using t2_pkey on t2
               Filter: (ctid = '(1,1)'::tid)
         ->  Hash
               ->  Tid Scan on t1
                     TID Cond: (ctid = '(1,1)'::tid)
 Optimizer: Postgres query optimizer
(9 rows)

/*+TidScan(t1) BitmapScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
LOG:  statement: /*+TidScan(t1) BitmapScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
NOTICE:  SELECT uses system-defined column "t1.ctid" without the necessary companion column "t1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
NOTICE:  SELECT uses system-defined column "t2.ctid" without the necessary companion column "t2.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  pg_hint_plan:
used hint:
TidScan(t1)
BitmapScan(t2)
not used hint:
duplication hint:
error hint:
                     QUERY PLAN                      
-----------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t2.id = t1.id)
         ->  Bitmap Heap Scan on t2
               Filter: (ctid = '(1,1)'::tid)
               ->  Bitmap Index Scan on t2_pkey
         ->  Hash
               ->  Tid Scan on t1
                     TID Cond: (ctid = '(1,1)'::tid)
 Optimizer: Postgres query optimizer
(10 rows)

/*+TidScan(t1) TidScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
LOG:  statement: /*+TidScan(t1) TidScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
NOTICE:  SELECT uses system-defined column "t1.ctid" without the necessary companion column "t1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
NOTICE:  SELECT uses system-defined column "t2.ctid" without the necessary companion column "t2.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  pg_hint_plan:
used hint:
TidScan(t1)
TidScan(t2)
not used hint:
duplication hint:
error hint:
                     QUERY PLAN                      
-----------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t1.id = t2.id)
         ->  Tid Scan on t1
               TID Cond: (ctid = '(1,1)'::tid)
         ->  Hash
               ->  Tid Scan on t2
                     TID Cond: (ctid = '(1,1)'::tid)
 Optimizer: Postgres query optimizer
(9 rows)

/*+TidScan(t1) NoSeqScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
LOG:  statement: /*+TidScan(t1) NoSeqScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
NOTICE:  SELECT uses system-defined column "t1.ctid" without the necessary companion column "t1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
NOTICE:  SELECT uses system-defined column "t2.ctid" without the necessary companion column "t2.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  pg_hint_plan:
used hint:
TidScan(t1)
NoSeqScan(t2)
not used hint:
duplication hint:
error hint:
                     QUERY PLAN                      
-----------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t2.id = t1.id)
         ->  Tid Scan on t2
               TID Cond: (ctid = '(1,1)'::tid)
         ->  Hash
               ->  Tid Scan on t1
                     TID Cond: (ctid = '(1,1)'::tid)
 Optimizer: Postgres query optimizer
(9 rows)

/*+TidScan(t1) NoIndexScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
LOG:  statement: /*+TidScan(t1) NoIndexScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
NOTICE:  SELECT uses system-defined column "t1.ctid" without the necessary companion column "t1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
NOTICE:  SELECT uses system-defined column "t2.ctid" without the necessary companion column "t2.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  pg_hint_plan:
used hint:
TidScan(t1)
NoIndexScan(t2)
not used hint:
duplication hint:
error hint:
                     QUERY PLAN                      
-----------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t2.id = t1.id)
         ->  Tid Scan on t2
               TID Cond: (ctid = '(1,1)'::tid)
         ->  Hash
               ->  Tid Scan on t1
                     TID Cond: (ctid = '(1,1)'::tid)
 Optimizer: Postgres query optimizer
(9 rows)

/*+TidScan(t1) NoBitmapScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
LOG:  statement: /*+TidScan(t1) NoBitmapScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
NOTICE:  SELECT uses system-defined column "t1.ctid" without the necessary companion column "t1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
NOTICE:  SELECT uses system-defined column "t2.ctid" without the necessary companion column "t2.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  pg_hint_plan:
used hint:
TidScan(t1)
NoBitmapScan(t2)
not used hint:
duplication hint:
error hint:
                     QUERY PLAN                      
-----------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t2.id = t1.id)
         ->  Tid Scan on t2
               TID Cond: (ctid = '(1,1)'::tid)
         ->  Hash
               ->  Tid Scan on t1
                     TID Cond: (ctid = '(1,1)'::tid)
 Optimizer: Postgres query optimizer
(9 rows)

/*+TidScan(t1) NoTidScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
LOG:  statement: /*+TidScan(t1) NoTidScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
NOTICE:  SELECT uses system-defined column "t1.ctid" without the necessary companion column "t1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
NOTICE:  SELECT uses system-defined column "t2.ctid" without the necessary companion column "t2.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  pg_hint_plan:
used hint:
TidScan(t1)
NoTidScan(t2)
not used hint:
duplication hint:
error hint:
                     QUERY PLAN                      
-----------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t2.id = t1.id)
         ->  Seq Scan on t2
               Filter: (ctid = '(1,1)'::tid)
         ->  Hash
               ->  Tid Scan on t1
                     TID Cond: (ctid = '(1,1)'::tid)
 Optimizer: Postgres query optimizer
(9 rows)

/*+NoSeqScan(t1)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
LOG:  statement: /*+NoSeqScan(t1)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
NOTICE:  SELECT uses system-defined column "t1.ctid" without the necessary companion column "t1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
NOTICE:  SELECT uses system-defined column "t2.ctid" without the necessary companion column "t2.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  pg_hint_plan:
used hint:
NoSeqScan(t1)
not used hint:
duplication hint:
error hint:
                     QUERY PLAN                      
-----------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t1.id = t2.id)
         ->  Tid Scan on t1
               TID Cond: (ctid = '(1,1)'::tid)
         ->  Hash
               ->  Tid Scan on t2
                     TID Cond: (ctid = '(1,1)'::tid)
 Optimizer: Postgres query optimizer
(9 rows)

/*+NoSeqScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
LOG:  statement: /*+NoSeqScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
NOTICE:  SELECT uses system-defined column "t1.ctid" without the necessary companion column "t1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
NOTICE:  SELECT uses system-defined column "t2.ctid" without the necessary companion column "t2.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  pg_hint_plan:
used hint:
NoSeqScan(t2)
not used hint:
duplication hint:
error hint:
                     QUERY PLAN                      
-----------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t1.id = t2.id)
         ->  Tid Scan on t1
               TID Cond: (ctid = '(1,1)'::tid)
         ->  Hash
               ->  Tid Scan on t2
                     TID Cond: (ctid = '(1,1)'::tid)
 Optimizer: Postgres query optimizer
(9 rows)

/*+NoSeqScan(t1) SeqScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
LOG:  statement: /*+NoSeqScan(t1) SeqScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
NOTICE:  SELECT uses system-defined column "t1.ctid" without the necessary companion column "t1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
NOTICE:  SELECT uses system-defined column "t2.ctid" without the necessary companion column "t2.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  pg_hint_plan:
used hint:
NoSeqScan(t1)
SeqScan(t2)
not used hint:
duplication hint:
error hint:
                     QUERY PLAN                      
-----------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t2.id = t1.id)
         ->  Seq Scan on t2
               Filter: (ctid = '(1,1)'::tid)
         ->  Hash
               ->  Tid Scan on t1
                     TID Cond: (ctid = '(1,1)'::tid)
 Optimizer: Postgres query optimizer
(9 rows)

/*+NoSeqScan(t1) IndexScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
LOG:  statement: /*+NoSeqScan(t1) IndexScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
NOTICE:  SELECT uses system-defined column "t1.ctid" without the necessary companion column "t1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
NOTICE:  SELECT uses system-defined column "t2.ctid" without the necessary companion column "t2.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  pg_hint_plan:
used hint:
NoSeqScan(t1)
IndexScan(t2)
not used hint:
duplication hint:
error hint:
                     QUERY PLAN                      
-----------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t2.id = t1.id)
         ->  Index Scan using t2_pkey on t2
               Filter: (ctid = '(1,1)'::tid)
         ->  Hash
               ->  Tid Scan on t1
                     TID Cond: (ctid = '(1,1)'::tid)
 Optimizer: Postgres query optimizer
(9 rows)

/*+NoSeqScan(t1) BitmapScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
LOG:  statement: /*+NoSeqScan(t1) BitmapScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
NOTICE:  SELECT uses system-defined column "t1.ctid" without the necessary companion column "t1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
NOTICE:  SELECT uses system-defined column "t2.ctid" without the necessary companion column "t2.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  pg_hint_plan:
used hint:
NoSeqScan(t1)
BitmapScan(t2)
not used hint:
duplication hint:
error hint:
                     QUERY PLAN                      
-----------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t2.id = t1.id)
         ->  Bitmap Heap Scan on t2
               Filter: (ctid = '(1,1)'::tid)
               ->  Bitmap Index Scan on t2_pkey
         ->  Hash
               ->  Tid Scan on t1
                     TID Cond: (ctid = '(1,1)'::tid)
 Optimizer: Postgres query optimizer
(10 rows)

/*+NoSeqScan(t1) TidScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
LOG:  statement: /*+NoSeqScan(t1) TidScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
NOTICE:  SELECT uses system-defined column "t1.ctid" without the necessary companion column "t1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
NOTICE:  SELECT uses system-defined column "t2.ctid" without the necessary companion column "t2.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  pg_hint_plan:
used hint:
NoSeqScan(t1)
TidScan(t2)
not used hint:
duplication hint:
error hint:
                     QUERY PLAN                      
-----------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t1.id = t2.id)
         ->  Tid Scan on t1
               TID Cond: (ctid = '(1,1)'::tid)
         ->  Hash
               ->  Tid Scan on t2
                     TID Cond: (ctid = '(1,1)'::tid)
 Optimizer: Postgres query optimizer
(9 rows)

/*+NoSeqScan(t1) NoSeqScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
LOG:  statement: /*+NoSeqScan(t1) NoSeqScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
NOTICE:  SELECT uses system-defined column "t1.ctid" without the necessary companion column "t1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
NOTICE:  SELECT uses system-defined column "t2.ctid" without the necessary companion column "t2.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  pg_hint_plan:
used hint:
NoSeqScan(t1)
NoSeqScan(t2)
not used hint:
duplication hint:
error hint:
                     QUERY PLAN                      
-----------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t1.id = t2.id)
         ->  Tid Scan on t1
               TID Cond: (ctid = '(1,1)'::tid)
         ->  Hash
               ->  Tid Scan on t2
                     TID Cond: (ctid = '(1,1)'::tid)
 Optimizer: Postgres query optimizer
(9 rows)

/*+NoSeqScan(t1) NoIndexScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
LOG:  statement: /*+NoSeqScan(t1) NoIndexScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
NOTICE:  SELECT uses system-defined column "t1.ctid" without the necessary companion column "t1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
NOTICE:  SELECT uses system-defined column "t2.ctid" without the necessary companion column "t2.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  pg_hint_plan:
used hint:
NoSeqScan(t1)
NoIndexScan(t2)
not used hint:
duplication hint:
error hint:
                     QUERY PLAN                      
-----------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t1.id = t2.id)
         ->  Tid Scan on t1
               TID Cond: (ctid = '(1,1)'::tid)
         ->  Hash
               ->  Tid Scan on t2
                     TID Cond: (ctid = '(1,1)'::tid)
 Optimizer: Postgres query optimizer
(9 rows)

/*+NoSeqScan(t1) NoBitmapScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
LOG:  statement: /*+NoSeqScan(t1) NoBitmapScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
NOTICE:  SELECT uses system-defined column "t1.ctid" without the necessary companion column "t1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
NOTICE:  SELECT uses system-defined column "t2.ctid" without the necessary companion column "t2.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  pg_hint_plan:
used hint:
NoSeqScan(t1)
NoBitmapScan(t2)
not used hint:
duplication hint:
error hint:
                     QUERY PLAN                      
-----------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t1.id = t2.id)
         ->  Tid Scan on t1
               TID Cond: (ctid = '(1,1)'::tid)
         ->  Hash
               ->  Tid Scan on t2
                     TID Cond: (ctid = '(1,1)'::tid)
 Optimizer: Postgres query optimizer
(9 rows)

/*+NoSeqScan(t1) NoTidScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
LOG:  statement: /*+NoSeqScan(t1) NoTidScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
NOTICE:  SELECT uses system-defined column "t1.ctid" without the necessary companion column "t1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
NOTICE:  SELECT uses system-defined column "t2.ctid" without the necessary companion column "t2.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  pg_hint_plan:
used hint:
NoSeqScan(t1)
NoTidScan(t2)
not used hint:
duplication hint:
error hint:
                     QUERY PLAN                      
-----------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t2.id = t1.id)
         ->  Seq Scan on t2
               Filter: (ctid = '(1,1)'::tid)
         ->  Hash
               ->  Tid Scan on t1
                     TID Cond: (ctid = '(1,1)'::tid)
 Optimizer: Postgres query optimizer
(9 rows)

/*+NoIndexScan(t1)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
LOG:  statement: /*+NoIndexScan(t1)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
NOTICE:  SELECT uses system-defined column "t1.ctid" without the necessary companion column "t1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
NOTICE:  SELECT uses system-defined column "t2.ctid" without the necessary companion column "t2.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  pg_hint_plan:
used hint:
NoIndexScan(t1)
not used hint:
duplication hint:
error hint:
                     QUERY PLAN                      
-----------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t1.id = t2.id)
         ->  Tid Scan on t1
               TID Cond: (ctid = '(1,1)'::tid)
         ->  Hash
               ->  Tid Scan on t2
                     TID Cond: (ctid = '(1,1)'::tid)
 Optimizer: Postgres query optimizer
(9 rows)

/*+NoIndexScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
LOG:  statement: /*+NoIndexScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
NOTICE:  SELECT uses system-defined column "t1.ctid" without the necessary companion column "t1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
NOTICE:  SELECT uses system-defined column "t2.ctid" without the necessary companion column "t2.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  pg_hint_plan:
used hint:
NoIndexScan(t2)
not used hint:
duplication hint:
error hint:
                     QUERY PLAN                      
-----------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t1.id = t2.id)
         ->  Tid Scan on t1
               TID Cond: (ctid = '(1,1)'::tid)
         ->  Hash
               ->  Tid Scan on t2
                     TID Cond: (ctid = '(1,1)'::tid)
 Optimizer: Postgres query optimizer
(9 rows)

/*+NoIndexScan(t1) SeqScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
LOG:  statement: /*+NoIndexScan(t1) SeqScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
NOTICE:  SELECT uses system-defined column "t1.ctid" without the necessary companion column "t1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
NOTICE:  SELECT uses system-defined column "t2.ctid" without the necessary companion column "t2.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  pg_hint_plan:
used hint:
NoIndexScan(t1)
SeqScan(t2)
not used hint:
duplication hint:
error hint:
                     QUERY PLAN                      
-----------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t2.id = t1.id)
         ->  Seq Scan on t2
               Filter: (ctid = '(1,1)'::tid)
         ->  Hash
               ->  Tid Scan on t1
                     TID Cond: (ctid = '(1,1)'::tid)
 Optimizer: Postgres query optimizer
(9 rows)

/*+NoIndexScan(t1) IndexScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
LOG:  statement: /*+NoIndexScan(t1) IndexScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
NOTICE:  SELECT uses system-defined column "t1.ctid" without the necessary companion column "t1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
NOTICE:  SELECT uses system-defined column "t2.ctid" without the necessary companion column "t2.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  pg_hint_plan:
used hint:
NoIndexScan(t1)
IndexScan(t2)
not used hint:
duplication hint:
error hint:
                     QUERY PLAN                      
-----------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t2.id = t1.id)
         ->  Index Scan using t2_pkey on t2
               Filter: (ctid = '(1,1)'::tid)
         ->  Hash
               ->  Tid Scan on t1
                     TID Cond: (ctid = '(1,1)'::tid)
 Optimizer: Postgres query optimizer
(9 rows)

/*+NoIndexScan(t1) BitmapScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
LOG:  statement: /*+NoIndexScan(t1) BitmapScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
NOTICE:  SELECT uses system-defined column "t1.ctid" without the necessary companion column "t1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
NOTICE:  SELECT uses system-defined column "t2.ctid" without the necessary companion column "t2.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  pg_hint_plan:
used hint:
NoIndexScan(t1)
BitmapScan(t2)
not used hint:
duplication hint:
error hint:
                     QUERY PLAN                      
-----------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t2.id = t1.id)
         ->  Bitmap Heap Scan on t2
               Filter: (ctid = '(1,1)'::tid)
               ->  Bitmap Index Scan on t2_pkey
         ->  Hash
               ->  Tid Scan on t1
                     TID Cond: (ctid = '(1,1)'::tid)
 Optimizer: Postgres query optimizer
(10 rows)

/*+NoIndexScan(t1) TidScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
LOG:  statement: /*+NoIndexScan(t1) TidScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
NOTICE:  SELECT uses system-defined column "t1.ctid" without the necessary companion column "t1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
NOTICE:  SELECT uses system-defined column "t2.ctid" without the necessary companion column "t2.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  pg_hint_plan:
used hint:
NoIndexScan(t1)
TidScan(t2)
not used hint:
duplication hint:
error hint:
                     QUERY PLAN                      
-----------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t1.id = t2.id)
         ->  Tid Scan on t1
               TID Cond: (ctid = '(1,1)'::tid)
         ->  Hash
               ->  Tid Scan on t2
                     TID Cond: (ctid = '(1,1)'::tid)
 Optimizer: Postgres query optimizer
(9 rows)

/*+NoIndexScan(t1) NoSeqScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
LOG:  statement: /*+NoIndexScan(t1) NoSeqScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
NOTICE:  SELECT uses system-defined column "t1.ctid" without the necessary companion column "t1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
NOTICE:  SELECT uses system-defined column "t2.ctid" without the necessary companion column "t2.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  pg_hint_plan:
used hint:
NoIndexScan(t1)
NoSeqScan(t2)
not used hint:
duplication hint:
error hint:
                     QUERY PLAN                      
-----------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t1.id = t2.id)
         ->  Tid Scan on t1
               TID Cond: (ctid = '(1,1)'::tid)
         ->  Hash
               ->  Tid Scan on t2
                     TID Cond: (ctid = '(1,1)'::tid)
 Optimizer: Postgres query optimizer
(9 rows)

/*+NoIndexScan(t1) NoIndexScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
LOG:  statement: /*+NoIndexScan(t1) NoIndexScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
NOTICE:  SELECT uses system-defined column "t1.ctid" without the necessary companion column "t1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
NOTICE:  SELECT uses system-defined column "t2.ctid" without the necessary companion column "t2.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  pg_hint_plan:
used hint:
NoIndexScan(t1)
NoIndexScan(t2)
not used hint:
duplication hint:
error hint:
                     QUERY PLAN                      
-----------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t1.id = t2.id)
         ->  Tid Scan on t1
               TID Cond: (ctid = '(1,1)'::tid)
         ->  Hash
               ->  Tid Scan on t2
                     TID Cond: (ctid = '(1,1)'::tid)
 Optimizer: Postgres query optimizer
(9 rows)

/*+NoIndexScan(t1) NoBitmapScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
LOG:  statement: /*+NoIndexScan(t1) NoBitmapScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
NOTICE:  SELECT uses system-defined column "t1.ctid" without the necessary companion column "t1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
NOTICE:  SELECT uses system-defined column "t2.ctid" without the necessary companion column "t2.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  pg_hint_plan:
used hint:
NoIndexScan(t1)
NoBitmapScan(t2)
not used hint:
duplication hint:
error hint:
                     QUERY PLAN                      
-----------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t1.id = t2.id)
         ->  Tid Scan on t1
               TID Cond: (ctid = '(1,1)'::tid)
         ->  Hash
               ->  Tid Scan on t2
                     TID Cond: (ctid = '(1,1)'::tid)
 Optimizer: Postgres query optimizer
(9 rows)

/*+NoIndexScan(t1) NoTidScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
LOG:  statement: /*+NoIndexScan(t1) NoTidScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
NOTICE:  SELECT uses system-defined column "t1.ctid" without the necessary companion column "t1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
NOTICE:  SELECT uses system-defined column "t2.ctid" without the necessary companion column "t2.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  pg_hint_plan:
used hint:
NoIndexScan(t1)
NoTidScan(t2)
not used hint:
duplication hint:
error hint:
                     QUERY PLAN                      
-----------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t2.id = t1.id)
         ->  Seq Scan on t2
               Filter: (ctid = '(1,1)'::tid)
         ->  Hash
               ->  Tid Scan on t1
                     TID Cond: (ctid = '(1,1)'::tid)
 Optimizer: Postgres query optimizer
(9 rows)

/*+NoBitmapScan(t1)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
LOG:  statement: /*+NoBitmapScan(t1)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
NOTICE:  SELECT uses system-defined column "t1.ctid" without the necessary companion column "t1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
NOTICE:  SELECT uses system-defined column "t2.ctid" without the necessary companion column "t2.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  pg_hint_plan:
used hint:
NoBitmapScan(t1)
not used hint:
duplication hint:
error hint:
                     QUERY PLAN                      
-----------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t1.id = t2.id)
         ->  Tid Scan on t1
               TID Cond: (ctid = '(1,1)'::tid)
         ->  Hash
               ->  Tid Scan on t2
                     TID Cond: (ctid = '(1,1)'::tid)
 Optimizer: Postgres query optimizer
(9 rows)

/*+NoBitmapScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
LOG:  statement: /*+NoBitmapScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
NOTICE:  SELECT uses system-defined column "t1.ctid" without the necessary companion column "t1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
NOTICE:  SELECT uses system-defined column "t2.ctid" without the necessary companion column "t2.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  pg_hint_plan:
used hint:
NoBitmapScan(t2)
not used hint:
duplication hint:
error hint:
                     QUERY PLAN                      
-----------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t1.id = t2.id)
         ->  Tid Scan on t1
               TID Cond: (ctid = '(1,1)'::tid)
         ->  Hash
               ->  Tid Scan on t2
                     TID Cond: (ctid = '(1,1)'::tid)
 Optimizer: Postgres query optimizer
(9 rows)

/*+NoBitmapScan(t1) SeqScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
LOG:  statement: /*+NoBitmapScan(t1) SeqScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
NOTICE:  SELECT uses system-defined column "t1.ctid" without the necessary companion column "t1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
NOTICE:  SELECT uses system-defined column "t2.ctid" without the necessary companion column "t2.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  pg_hint_plan:
used hint:
NoBitmapScan(t1)
SeqScan(t2)
not used hint:
duplication hint:
error hint:
                     QUERY PLAN                      
-----------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t2.id = t1.id)
         ->  Seq Scan on t2
               Filter: (ctid = '(1,1)'::tid)
         ->  Hash
               ->  Tid Scan on t1
                     TID Cond: (ctid = '(1,1)'::tid)
 Optimizer: Postgres query optimizer
(9 rows)

/*+NoBitmapScan(t1) IndexScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
LOG:  statement: /*+NoBitmapScan(t1) IndexScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
NOTICE:  SELECT uses system-defined column "t1.ctid" without the necessary companion column "t1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
NOTICE:  SELECT uses system-defined column "t2.ctid" without the necessary companion column "t2.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  pg_hint_plan:
used hint:
NoBitmapScan(t1)
IndexScan(t2)
not used hint:
duplication hint:
error hint:
                     QUERY PLAN                      
-----------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t2.id = t1.id)
         ->  Index Scan using t2_pkey on t2
               Filter: (ctid = '(1,1)'::tid)
         ->  Hash
               ->  Tid Scan on t1
                     TID Cond: (ctid = '(1,1)'::tid)
 Optimizer: Postgres query optimizer
(9 rows)

/*+NoBitmapScan(t1) BitmapScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
LOG:  statement: /*+NoBitmapScan(t1) BitmapScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
NOTICE:  SELECT uses system-defined column "t1.ctid" without the necessary companion column "t1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
NOTICE:  SELECT uses system-defined column "t2.ctid" without the necessary companion column "t2.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  pg_hint_plan:
used hint:
NoBitmapScan(t1)
BitmapScan(t2)
not used hint:
duplication hint:
error hint:
                     QUERY PLAN                      
-----------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t2.id = t1.id)
         ->  Bitmap Heap Scan on t2
               Filter: (ctid = '(1,1)'::tid)
               ->  Bitmap Index Scan on t2_pkey
         ->  Hash
               ->  Tid Scan on t1
                     TID Cond: (ctid = '(1,1)'::tid)
 Optimizer: Postgres query optimizer
(10 rows)

/*+NoBitmapScan(t1) TidScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
LOG:  statement: /*+NoBitmapScan(t1) TidScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
NOTICE:  SELECT uses system-defined column "t1.ctid" without the necessary companion column "t1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
NOTICE:  SELECT uses system-defined column "t2.ctid" without the necessary companion column "t2.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  pg_hint_plan:
used hint:
NoBitmapScan(t1)
TidScan(t2)
not used hint:
duplication hint:
error hint:
                     QUERY PLAN                      
-----------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t1.id = t2.id)
         ->  Tid Scan on t1
               TID Cond: (ctid = '(1,1)'::tid)
         ->  Hash
               ->  Tid Scan on t2
                     TID Cond: (ctid = '(1,1)'::tid)
 Optimizer: Postgres query optimizer
(9 rows)

/*+NoBitmapScan(t1) NoSeqScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
LOG:  statement: /*+NoBitmapScan(t1) NoSeqScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
NOTICE:  SELECT uses system-defined column "t1.ctid" without the necessary companion column "t1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
NOTICE:  SELECT uses system-defined column "t2.ctid" without the necessary companion column "t2.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  pg_hint_plan:
used hint:
NoBitmapScan(t1)
NoSeqScan(t2)
not used hint:
duplication hint:
error hint:
                     QUERY PLAN                      
-----------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t1.id = t2.id)
         ->  Tid Scan on t1
               TID Cond: (ctid = '(1,1)'::tid)
         ->  Hash
               ->  Tid Scan on t2
                     TID Cond: (ctid = '(1,1)'::tid)
 Optimizer: Postgres query optimizer
(9 rows)

/*+NoBitmapScan(t1) NoIndexScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
LOG:  statement: /*+NoBitmapScan(t1) NoIndexScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
NOTICE:  SELECT uses system-defined column "t1.ctid" without the necessary companion column "t1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
NOTICE:  SELECT uses system-defined column "t2.ctid" without the necessary companion column "t2.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  pg_hint_plan:
used hint:
NoBitmapScan(t1)
NoIndexScan(t2)
not used hint:
duplication hint:
error hint:
                     QUERY PLAN                      
-----------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t1.id = t2.id)
         ->  Tid Scan on t1
               TID Cond: (ctid = '(1,1)'::tid)
         ->  Hash
               ->  Tid Scan on t2
                     TID Cond: (ctid = '(1,1)'::tid)
 Optimizer: Postgres query optimizer
(9 rows)

/*+NoBitmapScan(t1) NoBitmapScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
LOG:  statement: /*+NoBitmapScan(t1) NoBitmapScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
NOTICE:  SELECT uses system-defined column "t1.ctid" without the necessary companion column "t1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
NOTICE:  SELECT uses system-defined column "t2.ctid" without the necessary companion column "t2.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  pg_hint_plan:
used hint:
NoBitmapScan(t1)
NoBitmapScan(t2)
not used hint:
duplication hint:
error hint:
                     QUERY PLAN                      
-----------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t1.id = t2.id)
         ->  Tid Scan on t1
               TID Cond: (ctid = '(1,1)'::tid)
         ->  Hash
               ->  Tid Scan on t2
                     TID Cond: (ctid = '(1,1)'::tid)
 Optimizer: Postgres query optimizer
(9 rows)

/*+NoBitmapScan(t1) NoTidScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
LOG:  statement: /*+NoBitmapScan(t1) NoTidScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
NOTICE:  SELECT uses system-defined column "t1.ctid" without the necessary companion column "t1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
NOTICE:  SELECT uses system-defined column "t2.ctid" without the necessary companion column "t2.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  pg_hint_plan:
used hint:
NoBitmapScan(t1)
NoTidScan(t2)
not used hint:
duplication hint:
error hint:
                     QUERY PLAN                      
-----------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t2.id = t1.id)
         ->  Seq Scan on t2
               Filter: (ctid = '(1,1)'::tid)
         ->  Hash
               ->  Tid Scan on t1
                     TID Cond: (ctid = '(1,1)'::tid)
 Optimizer: Postgres query optimizer
(9 rows)

/*+NoTidScan(t1)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
LOG:  statement: /*+NoTidScan(t1)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
NOTICE:  SELECT uses system-defined column "t1.ctid" without the necessary companion column "t1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
NOTICE:  SELECT uses system-defined column "t2.ctid" without the necessary companion column "t2.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  pg_hint_plan:
used hint:
NoTidScan(t1)
not used hint:
duplication hint:
error hint:
                     QUERY PLAN                      
-----------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t1.id = t2.id)
         ->  Seq Scan on t1
               Filter: (ctid = '(1,1)'::tid)
         ->  Hash
               ->  Tid Scan on t2
                     TID Cond: (ctid = '(1,1)'::tid)
 Optimizer: Postgres query optimizer
(9 rows)

/*+NoTidScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
LOG:  statement: /*+NoTidScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
NOTICE:  SELECT uses system-defined column "t1.ctid" without the necessary companion column "t1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
NOTICE:  SELECT uses system-defined column "t2.ctid" without the necessary companion column "t2.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  pg_hint_plan:
used hint:
NoTidScan(t2)
not used hint:
duplication hint:
error hint:
                     QUERY PLAN                      
-----------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t2.id = t1.id)
         ->  Seq Scan on t2
               Filter: (ctid = '(1,1)'::tid)
         ->  Hash
               ->  Tid Scan on t1
                     TID Cond: (ctid = '(1,1)'::tid)
 Optimizer: Postgres query optimizer
(9 rows)

/*+NoTidScan(t1) SeqScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
LOG:  statement: /*+NoTidScan(t1) SeqScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
NOTICE:  SELECT uses system-defined column "t1.ctid" without the necessary companion column "t1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
NOTICE:  SELECT uses system-defined column "t2.ctid" without the necessary companion column "t2.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  pg_hint_plan:
used hint:
NoTidScan(t1)
SeqScan(t2)
not used hint:
duplication hint:
error hint:
                    QUERY PLAN                     
---------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t1.id = t2.id)
         ->  Seq Scan on t1
               Filter: (ctid = '(1,1)'::tid)
         ->  Hash
               ->  Seq Scan on t2
                     Filter: (ctid = '(1,1)'::tid)
 Optimizer: Postgres query optimizer
(9 rows)

/*+NoTidScan(t1) IndexScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
LOG:  statement: /*+NoTidScan(t1) IndexScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
NOTICE:  SELECT uses system-defined column "t1.ctid" without the necessary companion column "t1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
NOTICE:  SELECT uses system-defined column "t2.ctid" without the necessary companion column "t2.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  pg_hint_plan:
used hint:
NoTidScan(t1)
IndexScan(t2)
not used hint:
duplication hint:
error hint:
                    QUERY PLAN                     
---------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t1.id = t2.id)
         ->  Seq Scan on t1
               Filter: (ctid = '(1,1)'::tid)
         ->  Hash
               ->  Index Scan using t2_pkey on t2
                     Filter: (ctid = '(1,1)'::tid)
 Optimizer: Postgres query optimizer
(9 rows)

/*+NoTidScan(t1) BitmapScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
LOG:  statement: /*+NoTidScan(t1) BitmapScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
NOTICE:  SELECT uses system-defined column "t1.ctid" without the necessary companion column "t1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
NOTICE:  SELECT uses system-defined column "t2.ctid" without the necessary companion column "t2.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  pg_hint_plan:
used hint:
NoTidScan(t1)
BitmapScan(t2)
not used hint:
duplication hint:
error hint:
                      QUERY PLAN                      
------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t1.id = t2.id)
         ->  Seq Scan on t1
               Filter: (ctid = '(1,1)'::tid)
         ->  Hash
               ->  Bitmap Heap Scan on t2
                     Filter: (ctid = '(1,1)'::tid)
                     ->  Bitmap Index Scan on t2_pkey
 Optimizer: Postgres query optimizer
(10 rows)

/*+NoTidScan(t1) TidScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
LOG:  statement: /*+NoTidScan(t1) TidScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
NOTICE:  SELECT uses system-defined column "t1.ctid" without the necessary companion column "t1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
NOTICE:  SELECT uses system-defined column "t2.ctid" without the necessary companion column "t2.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  pg_hint_plan:
used hint:
NoTidScan(t1)
TidScan(t2)
not used hint:
duplication hint:
error hint:
                     QUERY PLAN                      
-----------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t1.id = t2.id)
         ->  Seq Scan on t1
               Filter: (ctid = '(1,1)'::tid)
         ->  Hash
               ->  Tid Scan on t2
                     TID Cond: (ctid = '(1,1)'::tid)
 Optimizer: Postgres query optimizer
(9 rows)

/*+NoTidScan(t1) NoSeqScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
LOG:  statement: /*+NoTidScan(t1) NoSeqScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
NOTICE:  SELECT uses system-defined column "t1.ctid" without the necessary companion column "t1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
NOTICE:  SELECT uses system-defined column "t2.ctid" without the necessary companion column "t2.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  pg_hint_plan:
used hint:
NoTidScan(t1)
NoSeqScan(t2)
not used hint:
duplication hint:
error hint:
                     QUERY PLAN                      
-----------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t1.id = t2.id)
         ->  Seq Scan on t1
               Filter: (ctid = '(1,1)'::tid)
         ->  Hash
               ->  Tid Scan on t2
                     TID Cond: (ctid = '(1,1)'::tid)
 Optimizer: Postgres query optimizer
(9 rows)

/*+NoTidScan(t1) NoIndexScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
LOG:  statement: /*+NoTidScan(t1) NoIndexScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
NOTICE:  SELECT uses system-defined column "t1.ctid" without the necessary companion column "t1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
NOTICE:  SELECT uses system-defined column "t2.ctid" without the necessary companion column "t2.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  pg_hint_plan:
used hint:
NoTidScan(t1)
NoIndexScan(t2)
not used hint:
duplication hint:
error hint:
                     QUERY PLAN                      
-----------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t1.id = t2.id)
         ->  Seq Scan on t1
               Filter: (ctid = '(1,1)'::tid)
         ->  Hash
               ->  Tid Scan on t2
                     TID Cond: (ctid = '(1,1)'::tid)
 Optimizer: Postgres query optimizer
(9 rows)

/*+NoTidScan(t1) NoBitmapScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
LOG:  statement: /*+NoTidScan(t1) NoBitmapScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
NOTICE:  SELECT uses system-defined column "t1.ctid" without the necessary companion column "t1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
NOTICE:  SELECT uses system-defined column "t2.ctid" without the necessary companion column "t2.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  pg_hint_plan:
used hint:
NoTidScan(t1)
NoBitmapScan(t2)
not used hint:
duplication hint:
error hint:
                     QUERY PLAN                      
-----------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t1.id = t2.id)
         ->  Seq Scan on t1
               Filter: (ctid = '(1,1)'::tid)
         ->  Hash
               ->  Tid Scan on t2
                     TID Cond: (ctid = '(1,1)'::tid)
 Optimizer: Postgres query optimizer
(9 rows)

/*+NoTidScan(t1) NoTidScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
LOG:  statement: /*+NoTidScan(t1) NoTidScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
NOTICE:  SELECT uses system-defined column "t1.ctid" without the necessary companion column "t1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
NOTICE:  SELECT uses system-defined column "t2.ctid" without the necessary companion column "t2.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  pg_hint_plan:
used hint:
NoTidScan(t1)
NoTidScan(t2)
not used hint:
duplication hint:
error hint:
                    QUERY PLAN                     
---------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t1.id = t2.id)
         ->  Seq Scan on t1
               Filter: (ctid = '(1,1)'::tid)
         ->  Hash
               ->  Seq Scan on t2
                     Filter: (ctid = '(1,1)'::tid)
 Optimizer: Postgres query optimizer
(9 rows)

-- additional test
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)' AND t1.id < 10 AND t2.id < 10;
LOG:  statement: EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)' AND t1.id < 10 AND t2.id < 10;
NOTICE:  SELECT uses system-defined column "t1.ctid" without the necessary companion column "t1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
NOTICE:  SELECT uses system-defined column "t2.ctid" without the necessary companion column "t2.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
                     QUERY PLAN                      
-----------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t1.id = t2.id)
         ->  Tid Scan on t1
               TID Cond: (ctid = '(1,1)'::tid)
               Filter: (id < 10)
         ->  Hash
               ->  Tid Scan on t2
                     TID Cond: (ctid = '(1,1)'::tid)
                     Filter: (id < 10)
 Optimizer: Postgres query optimizer
(11 rows)

/*+BitmapScan(t1) BitmapScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)' AND t1.id < 10 AND t2.id < 10;
LOG:  statement: /*+BitmapScan(t1) BitmapScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)' AND t1.id < 10 AND t2.id < 10;
NOTICE:  SELECT uses system-defined column "t1.ctid" without the necessary companion column "t1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
NOTICE:  SELECT uses system-defined column "t2.ctid" without the necessary companion column "t2.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  pg_hint_plan:
used hint:
BitmapScan(t1)
BitmapScan(t2)
not used hint:
duplication hint:
error hint:
                      QUERY PLAN                      
------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t1.id = t2.id)
         ->  Bitmap Heap Scan on t1
               Recheck Cond: (id < 10)
               Filter: (ctid = '(1,1)'::tid)
               ->  Bitmap Index Scan on t1_pkey
                     Index Cond: (id < 10)
         ->  Hash
               ->  Bitmap Heap Scan on t2
                     Recheck Cond: (id < 10)
                     Filter: (ctid = '(1,1)'::tid)
                     ->  Bitmap Index Scan on t2_pkey
                           Index Cond: (id < 10)
 Optimizer: Postgres query optimizer
(15 rows)

-- outer join test
EXPLAIN (COSTS false) SELECT * FROM t1 FULL OUTER JOIN  t2 ON (t1.id = t2.id);
LOG:  statement: EXPLAIN (COSTS false) SELECT * FROM t1 FULL OUTER JOIN  t2 ON (t1.id = t2.id);
                QUERY PLAN                
------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Full Join
         Hash Cond: (t1.id = t2.id)
         ->  Seq Scan on t1
         ->  Hash
               ->  Seq Scan on t2
 Optimizer: Postgres query optimizer
(7 rows)

/*+MergeJoin(t1 t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1 FULL OUTER JOIN  t2 ON (t1.id = t2.id);
LOG:  statement: /*+MergeJoin(t1 t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1 FULL OUTER JOIN  t2 ON (t1.id = t2.id);
LOG:  pg_hint_plan:
used hint:
MergeJoin(t1 t2)
not used hint:
duplication hint:
error hint:
                 QUERY PLAN                 
--------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Merge Full Join
         Merge Cond: (t1.id = t2.id)
         ->  Index Scan using t1_pkey on t1
         ->  Sort
               Sort Key: t2.id
               ->  Seq Scan on t2
 Optimizer: Postgres query optimizer
(8 rows)

-- Cannot work
/*+NestLoop(t1 t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1 FULL OUTER JOIN  t2 ON (t1.id = t2.id);
LOG:  statement: /*+NestLoop(t1 t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1 FULL OUTER JOIN  t2 ON (t1.id = t2.id);
LOG:  pg_hint_plan:
used hint:
NestLoop(t1 t2)
not used hint:
duplication hint:
error hint:
                QUERY PLAN                
------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Full Join
         Hash Cond: (t1.id = t2.id)
         ->  Seq Scan on t1
         ->  Hash
               ->  Seq Scan on t2
 Optimizer: Postgres query optimizer
(7 rows)

-- inheritance tables test
SET constraint_exclusion TO off;
LOG:  statement: SET constraint_exclusion TO off;
EXPLAIN (COSTS false) SELECT * FROM p1 WHERE id >= 50 AND id <= 51 AND p1.ctid = '(1,1)';
LOG:  statement: EXPLAIN (COSTS false) SELECT * FROM p1 WHERE id >= 50 AND id <= 51 AND p1.ctid = '(1,1)';
NOTICE:  SELECT uses system-defined column "p1.ctid" without the necessary companion column "p1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
                                 QUERY PLAN                                  
-----------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Append
         ->  Seq Scan on p1
               Filter: ((id >= 50) AND (id <= 51) AND (ctid = '(1,1)'::tid))
         ->  Seq Scan on p1_c1
               Filter: ((id >= 50) AND (id <= 51) AND (ctid = '(1,1)'::tid))
         ->  Seq Scan on p1_c2
               Filter: ((id >= 50) AND (id <= 51) AND (ctid = '(1,1)'::tid))
         ->  Seq Scan on p1_c3
               Filter: ((id >= 50) AND (id <= 51) AND (ctid = '(1,1)'::tid))
         ->  Seq Scan on p1_c4
               Filter: ((id >= 50) AND (id <= 51) AND (ctid = '(1,1)'::tid))
         ->  Seq Scan on p1_c1_c1
               Filter: ((id >= 50) AND (id <= 51) AND (ctid = '(1,1)'::tid))
         ->  Seq Scan on p1_c1_c2
               Filter: ((id >= 50) AND (id <= 51) AND (ctid = '(1,1)'::tid))
         ->  Seq Scan on p1_c3_c1
               Filter: ((id >= 50) AND (id <= 51) AND (ctid = '(1,1)'::tid))
         ->  Seq Scan on p1_c3_c2
               Filter: ((id >= 50) AND (id <= 51) AND (ctid = '(1,1)'::tid))
 Optimizer: Postgres query optimizer
(21 rows)

SET constraint_exclusion TO on;
LOG:  statement: SET constraint_exclusion TO on;
EXPLAIN (COSTS false) SELECT * FROM p1 WHERE id >= 50 AND id <= 51 AND p1.ctid = '(1,1)';
LOG:  statement: EXPLAIN (COSTS false) SELECT * FROM p1 WHERE id >= 50 AND id <= 51 AND p1.ctid = '(1,1)';
NOTICE:  SELECT uses system-defined column "p1.ctid" without the necessary companion column "p1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
                                 QUERY PLAN                                  
-----------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Append
         ->  Seq Scan on p1
               Filter: ((id >= 50) AND (id <= 51) AND (ctid = '(1,1)'::tid))
         ->  Seq Scan on p1_c1
               Filter: ((id >= 50) AND (id <= 51) AND (ctid = '(1,1)'::tid))
         ->  Seq Scan on p1_c1_c1
               Filter: ((id >= 50) AND (id <= 51) AND (ctid = '(1,1)'::tid))
         ->  Seq Scan on p1_c1_c2
               Filter: ((id >= 50) AND (id <= 51) AND (ctid = '(1,1)'::tid))
 Optimizer: Postgres query optimizer
(11 rows)

SET constraint_exclusion TO off;
LOG:  statement: SET constraint_exclusion TO off;
/*+SeqScan(p1)*/
EXPLAIN (COSTS false) SELECT * FROM p1 WHERE id >= 50 AND id <= 51 AND p1.ctid = '(1,1)';
LOG:  statement: /*+SeqScan(p1)*/
EXPLAIN (COSTS false) SELECT * FROM p1 WHERE id >= 50 AND id <= 51 AND p1.ctid = '(1,1)';
NOTICE:  SELECT uses system-defined column "p1.ctid" without the necessary companion column "p1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  pg_hint_plan:
used hint:
SeqScan(p1)
not used hint:
duplication hint:
error hint:
                                 QUERY PLAN                                  
-----------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Append
         ->  Seq Scan on p1
               Filter: ((id >= 50) AND (id <= 51) AND (ctid = '(1,1)'::tid))
         ->  Seq Scan on p1_c1
               Filter: ((id >= 50) AND (id <= 51) AND (ctid = '(1,1)'::tid))
         ->  Seq Scan on p1_c2
               Filter: ((id >= 50) AND (id <= 51) AND (ctid = '(1,1)'::tid))
         ->  Seq Scan on p1_c3
               Filter: ((id >= 50) AND (id <= 51) AND (ctid = '(1,1)'::tid))
         ->  Seq Scan on p1_c4
               Filter: ((id >= 50) AND (id <= 51) AND (ctid = '(1,1)'::tid))
         ->  Seq Scan on p1_c1_c1
               Filter: ((id >= 50) AND (id <= 51) AND (ctid = '(1,1)'::tid))
         ->  Seq Scan on p1_c1_c2
               Filter: ((id >= 50) AND (id <= 51) AND (ctid = '(1,1)'::tid))
         ->  Seq Scan on p1_c3_c1
               Filter: ((id >= 50) AND (id <= 51) AND (ctid = '(1,1)'::tid))
         ->  Seq Scan on p1_c3_c2
               Filter: ((id >= 50) AND (id <= 51) AND (ctid = '(1,1)'::tid))
 Optimizer: Postgres query optimizer
(21 rows)

/*+IndexScan(p1)*/
EXPLAIN (COSTS false) SELECT * FROM p1 WHERE id >= 50 AND id <= 51 AND p1.ctid = '(1,1)';
LOG:  statement: /*+IndexScan(p1)*/
EXPLAIN (COSTS false) SELECT * FROM p1 WHERE id >= 50 AND id <= 51 AND p1.ctid = '(1,1)';
NOTICE:  SELECT uses system-defined column "p1.ctid" without the necessary companion column "p1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  pg_hint_plan:
used hint:
IndexScan(p1)
not used hint:
duplication hint:
error hint:
                       QUERY PLAN                       
--------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Append
         ->  Index Scan using p1_pkey on p1
               Index Cond: ((id >= 50) AND (id <= 51))
               Filter: (ctid = '(1,1)'::tid)
         ->  Index Scan using p1_c1_pkey on p1_c1
               Index Cond: ((id >= 50) AND (id <= 51))
               Filter: (ctid = '(1,1)'::tid)
         ->  Index Scan using p1_c2_pkey on p1_c2
               Index Cond: ((id >= 50) AND (id <= 51))
               Filter: (ctid = '(1,1)'::tid)
         ->  Index Scan using p1_c3_pkey on p1_c3
               Index Cond: ((id >= 50) AND (id <= 51))
               Filter: (ctid = '(1,1)'::tid)
         ->  Index Scan using p1_c4_pkey on p1_c4
               Index Cond: ((id >= 50) AND (id <= 51))
               Filter: (ctid = '(1,1)'::tid)
         ->  Index Scan using p1_c1_c1_pkey on p1_c1_c1
               Index Cond: ((id >= 50) AND (id <= 51))
               Filter: (ctid = '(1,1)'::tid)
         ->  Index Scan using p1_c1_c2_pkey on p1_c1_c2
               Index Cond: ((id >= 50) AND (id <= 51))
               Filter: (ctid = '(1,1)'::tid)
         ->  Index Scan using p1_c3_c1_pkey on p1_c3_c1
               Index Cond: ((id >= 50) AND (id <= 51))
               Filter: (ctid = '(1,1)'::tid)
         ->  Index Scan using p1_c3_c2_pkey on p1_c3_c2
               Index Cond: ((id >= 50) AND (id <= 51))
               Filter: (ctid = '(1,1)'::tid)
 Optimizer: Postgres query optimizer
(30 rows)

/*+BitmapScan(p1)*/
EXPLAIN (COSTS false) SELECT * FROM p1 WHERE id >= 50 AND id <= 51 AND p1.ctid = '(1,1)';
LOG:  statement: /*+BitmapScan(p1)*/
EXPLAIN (COSTS false) SELECT * FROM p1 WHERE id >= 50 AND id <= 51 AND p1.ctid = '(1,1)';
NOTICE:  SELECT uses system-defined column "p1.ctid" without the necessary companion column "p1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  pg_hint_plan:
used hint:
BitmapScan(p1)
not used hint:
duplication hint:
error hint:
                         QUERY PLAN                          
-------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Append
         ->  Bitmap Heap Scan on p1
               Recheck Cond: ((id >= 50) AND (id <= 51))
               Filter: (ctid = '(1,1)'::tid)
               ->  Bitmap Index Scan on p1_pkey
                     Index Cond: ((id >= 50) AND (id <= 51))
         ->  Bitmap Heap Scan on p1_c1
               Recheck Cond: ((id >= 50) AND (id <= 51))
               Filter: (ctid = '(1,1)'::tid)
               ->  Bitmap Index Scan on p1_c1_pkey
                     Index Cond: ((id >= 50) AND (id <= 51))
         ->  Bitmap Heap Scan on p1_c2
               Recheck Cond: ((id >= 50) AND (id <= 51))
               Filter: (ctid = '(1,1)'::tid)
               ->  Bitmap Index Scan on p1_c2_pkey
                     Index Cond: ((id >= 50) AND (id <= 51))
         ->  Bitmap Heap Scan on p1_c3
               Recheck Cond: ((id >= 50) AND (id <= 51))
               Filter: (ctid = '(1,1)'::tid)
               ->  Bitmap Index Scan on p1_c3_pkey
                     Index Cond: ((id >= 50) AND (id <= 51))
         ->  Bitmap Heap Scan on p1_c4
               Recheck Cond: ((id >= 50) AND (id <= 51))
               Filter: (ctid = '(1,1)'::tid)
               ->  Bitmap Index Scan on p1_c4_pkey
                     Index Cond: ((id >= 50) AND (id <= 51))
         ->  Bitmap Heap Scan on p1_c1_c1
               Recheck Cond: ((id >= 50) AND (id <= 51))
               Filter: (ctid = '(1,1)'::tid)
               ->  Bitmap Index Scan on p1_c1_c1_pkey
                     Index Cond: ((id >= 50) AND (id <= 51))
         ->  Bitmap Heap Scan on p1_c1_c2
               Recheck Cond: ((id >= 50) AND (id <= 51))
               Filter: (ctid = '(1,1)'::tid)
               ->  Bitmap Index Scan on p1_c1_c2_pkey
                     Index Cond: ((id >= 50) AND (id <= 51))
         ->  Bitmap Heap Scan on p1_c3_c1
               Recheck Cond: ((id >= 50) AND (id <= 51))
               Filter: (ctid = '(1,1)'::tid)
               ->  Bitmap Index Scan on p1_c3_c1_pkey
                     Index Cond: ((id >= 50) AND (id <= 51))
         ->  Bitmap Heap Scan on p1_c3_c2
               Recheck Cond: ((id >= 50) AND (id <= 51))
               Filter: (ctid = '(1,1)'::tid)
               ->  Bitmap Index Scan on p1_c3_c2_pkey
                     Index Cond: ((id >= 50) AND (id <= 51))
 Optimizer: Postgres query optimizer
(48 rows)

/*+TidScan(p1)*/
EXPLAIN (COSTS false) SELECT * FROM p1 WHERE id >= 50 AND id <= 51 AND p1.ctid = '(1,1)';
LOG:  statement: /*+TidScan(p1)*/
EXPLAIN (COSTS false) SELECT * FROM p1 WHERE id >= 50 AND id <= 51 AND p1.ctid = '(1,1)';
NOTICE:  SELECT uses system-defined column "p1.ctid" without the necessary companion column "p1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  pg_hint_plan:
used hint:
TidScan(p1)
not used hint:
duplication hint:
error hint:
                    QUERY PLAN                     
---------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Append
         ->  Tid Scan on p1
               TID Cond: (ctid = '(1,1)'::tid)
               Filter: ((id >= 50) AND (id <= 51))
         ->  Tid Scan on p1_c1
               TID Cond: (ctid = '(1,1)'::tid)
               Filter: ((id >= 50) AND (id <= 51))
         ->  Tid Scan on p1_c2
               TID Cond: (ctid = '(1,1)'::tid)
               Filter: ((id >= 50) AND (id <= 51))
         ->  Tid Scan on p1_c3
               TID Cond: (ctid = '(1,1)'::tid)
               Filter: ((id >= 50) AND (id <= 51))
         ->  Tid Scan on p1_c4
               TID Cond: (ctid = '(1,1)'::tid)
               Filter: ((id >= 50) AND (id <= 51))
         ->  Tid Scan on p1_c1_c1
               TID Cond: (ctid = '(1,1)'::tid)
               Filter: ((id >= 50) AND (id <= 51))
         ->  Tid Scan on p1_c1_c2
               TID Cond: (ctid = '(1,1)'::tid)
               Filter: ((id >= 50) AND (id <= 51))
         ->  Tid Scan on p1_c3_c1
               TID Cond: (ctid = '(1,1)'::tid)
               Filter: ((id >= 50) AND (id <= 51))
         ->  Tid Scan on p1_c3_c2
               TID Cond: (ctid = '(1,1)'::tid)
               Filter: ((id >= 50) AND (id <= 51))
 Optimizer: Postgres query optimizer
(30 rows)

SET constraint_exclusion TO on;
LOG:  statement: SET constraint_exclusion TO on;
/*+SeqScan(p1)*/
EXPLAIN (COSTS false) SELECT * FROM p1 WHERE id >= 50 AND id <= 51 AND p1.ctid = '(1,1)';
LOG:  statement: /*+SeqScan(p1)*/
EXPLAIN (COSTS false) SELECT * FROM p1 WHERE id >= 50 AND id <= 51 AND p1.ctid = '(1,1)';
NOTICE:  SELECT uses system-defined column "p1.ctid" without the necessary companion column "p1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  pg_hint_plan:
used hint:
SeqScan(p1)
not used hint:
duplication hint:
error hint:
                                 QUERY PLAN                                  
-----------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Append
         ->  Seq Scan on p1
               Filter: ((id >= 50) AND (id <= 51) AND (ctid = '(1,1)'::tid))
         ->  Seq Scan on p1_c1
               Filter: ((id >= 50) AND (id <= 51) AND (ctid = '(1,1)'::tid))
         ->  Seq Scan on p1_c1_c1
               Filter: ((id >= 50) AND (id <= 51) AND (ctid = '(1,1)'::tid))
         ->  Seq Scan on p1_c1_c2
               Filter: ((id >= 50) AND (id <= 51) AND (ctid = '(1,1)'::tid))
 Optimizer: Postgres query optimizer
(11 rows)

/*+IndexScan(p1)*/
EXPLAIN (COSTS false) SELECT * FROM p1 WHERE id >= 50 AND id <= 51 AND p1.ctid = '(1,1)';
LOG:  statement: /*+IndexScan(p1)*/
EXPLAIN (COSTS false) SELECT * FROM p1 WHERE id >= 50 AND id <= 51 AND p1.ctid = '(1,1)';
NOTICE:  SELECT uses system-defined column "p1.ctid" without the necessary companion column "p1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  pg_hint_plan:
used hint:
IndexScan(p1)
not used hint:
duplication hint:
error hint:
                       QUERY PLAN                       
--------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Append
         ->  Index Scan using p1_pkey on p1
               Index Cond: ((id >= 50) AND (id <= 51))
               Filter: (ctid = '(1,1)'::tid)
         ->  Index Scan using p1_c1_pkey on p1_c1
               Index Cond: ((id >= 50) AND (id <= 51))
               Filter: (ctid = '(1,1)'::tid)
         ->  Index Scan using p1_c1_c1_pkey on p1_c1_c1
               Index Cond: ((id >= 50) AND (id <= 51))
               Filter: (ctid = '(1,1)'::tid)
         ->  Index Scan using p1_c1_c2_pkey on p1_c1_c2
               Index Cond: ((id >= 50) AND (id <= 51))
               Filter: (ctid = '(1,1)'::tid)
 Optimizer: Postgres query optimizer
(15 rows)

/*+BitmapScan(p1)*/
EXPLAIN (COSTS false) SELECT * FROM p1 WHERE id >= 50 AND id <= 51 AND p1.ctid = '(1,1)';
LOG:  statement: /*+BitmapScan(p1)*/
EXPLAIN (COSTS false) SELECT * FROM p1 WHERE id >= 50 AND id <= 51 AND p1.ctid = '(1,1)';
NOTICE:  SELECT uses system-defined column "p1.ctid" without the necessary companion column "p1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  pg_hint_plan:
used hint:
BitmapScan(p1)
not used hint:
duplication hint:
error hint:
                         QUERY PLAN                          
-------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Append
         ->  Bitmap Heap Scan on p1
               Recheck Cond: ((id >= 50) AND (id <= 51))
               Filter: (ctid = '(1,1)'::tid)
               ->  Bitmap Index Scan on p1_pkey
                     Index Cond: ((id >= 50) AND (id <= 51))
         ->  Bitmap Heap Scan on p1_c1
               Recheck Cond: ((id >= 50) AND (id <= 51))
               Filter: (ctid = '(1,1)'::tid)
               ->  Bitmap Index Scan on p1_c1_pkey
                     Index Cond: ((id >= 50) AND (id <= 51))
         ->  Bitmap Heap Scan on p1_c1_c1
               Recheck Cond: ((id >= 50) AND (id <= 51))
               Filter: (ctid = '(1,1)'::tid)
               ->  Bitmap Index Scan on p1_c1_c1_pkey
                     Index Cond: ((id >= 50) AND (id <= 51))
         ->  Bitmap Heap Scan on p1_c1_c2
               Recheck Cond: ((id >= 50) AND (id <= 51))
               Filter: (ctid = '(1,1)'::tid)
               ->  Bitmap Index Scan on p1_c1_c2_pkey
                     Index Cond: ((id >= 50) AND (id <= 51))
 Optimizer: Postgres query optimizer
(23 rows)

/*+TidScan(p1)*/
EXPLAIN (COSTS false) SELECT * FROM p1 WHERE id >= 50 AND id <= 51 AND p1.ctid = '(1,1)';
LOG:  statement: /*+TidScan(p1)*/
EXPLAIN (COSTS false) SELECT * FROM p1 WHERE id >= 50 AND id <= 51 AND p1.ctid = '(1,1)';
NOTICE:  SELECT uses system-defined column "p1.ctid" without the necessary companion column "p1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  pg_hint_plan:
used hint:
TidScan(p1)
not used hint:
duplication hint:
error hint:
                    QUERY PLAN                     
---------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Append
         ->  Tid Scan on p1
               TID Cond: (ctid = '(1,1)'::tid)
               Filter: ((id >= 50) AND (id <= 51))
         ->  Tid Scan on p1_c1
               TID Cond: (ctid = '(1,1)'::tid)
               Filter: ((id >= 50) AND (id <= 51))
         ->  Tid Scan on p1_c1_c1
               TID Cond: (ctid = '(1,1)'::tid)
               Filter: ((id >= 50) AND (id <= 51))
         ->  Tid Scan on p1_c1_c2
               TID Cond: (ctid = '(1,1)'::tid)
               Filter: ((id >= 50) AND (id <= 51))
 Optimizer: Postgres query optimizer
(15 rows)

SET constraint_exclusion TO off;
LOG:  statement: SET constraint_exclusion TO off;
EXPLAIN (COSTS false) SELECT * FROM p1, t1 WHERE p1.id >= 50 AND p1.id <= 51 AND p1.ctid = '(1,1)' AND p1.id = t1.id AND t1.id < 10;
LOG:  statement: EXPLAIN (COSTS false) SELECT * FROM p1, t1 WHERE p1.id >= 50 AND p1.id <= 51 AND p1.ctid = '(1,1)' AND p1.id = t1.id AND t1.id < 10;
NOTICE:  SELECT uses system-defined column "p1.ctid" without the necessary companion column "p1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
                                           QUERY PLAN                                            
-------------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (p1.id = t1.id)
         ->  Append
               ->  Seq Scan on p1
                     Filter: ((id >= 50) AND (id <= 51) AND (id < 10) AND (ctid = '(1,1)'::tid))
               ->  Seq Scan on p1_c1
                     Filter: ((id >= 50) AND (id <= 51) AND (id < 10) AND (ctid = '(1,1)'::tid))
               ->  Seq Scan on p1_c2
                     Filter: ((id >= 50) AND (id <= 51) AND (id < 10) AND (ctid = '(1,1)'::tid))
               ->  Seq Scan on p1_c3
                     Filter: ((id >= 50) AND (id <= 51) AND (id < 10) AND (ctid = '(1,1)'::tid))
               ->  Seq Scan on p1_c4
                     Filter: ((id >= 50) AND (id <= 51) AND (id < 10) AND (ctid = '(1,1)'::tid))
               ->  Seq Scan on p1_c1_c1
                     Filter: ((id >= 50) AND (id <= 51) AND (id < 10) AND (ctid = '(1,1)'::tid))
               ->  Seq Scan on p1_c1_c2
                     Filter: ((id >= 50) AND (id <= 51) AND (id < 10) AND (ctid = '(1,1)'::tid))
               ->  Seq Scan on p1_c3_c1
                     Filter: ((id >= 50) AND (id <= 51) AND (id < 10) AND (ctid = '(1,1)'::tid))
               ->  Seq Scan on p1_c3_c2
                     Filter: ((id >= 50) AND (id <= 51) AND (id < 10) AND (ctid = '(1,1)'::tid))
         ->  Hash
               ->  Index Scan using t1_pkey on t1
                     Index Cond: ((id < 10) AND (id >= 50) AND (id <= 51))
 Optimizer: Postgres query optimizer
(26 rows)

SET constraint_exclusion TO on;
LOG:  statement: SET constraint_exclusion TO on;
EXPLAIN (COSTS false) SELECT * FROM p1, t1 WHERE p1.id >= 50 AND p1.id <= 51 AND p1.ctid = '(1,1)' AND p1.id = t1.id AND t1.id < 10;
LOG:  statement: EXPLAIN (COSTS false) SELECT * FROM p1, t1 WHERE p1.id >= 50 AND p1.id <= 51 AND p1.ctid = '(1,1)' AND p1.id = t1.id AND t1.id < 10;
NOTICE:  SELECT uses system-defined column "p1.ctid" without the necessary companion column "p1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
             QUERY PLAN              
-------------------------------------
 Result
   One-Time Filter: false
 Optimizer: Postgres query optimizer
(3 rows)

SET constraint_exclusion TO off;
LOG:  statement: SET constraint_exclusion TO off;
/*+SeqScan(p1)*/
EXPLAIN (COSTS false) SELECT * FROM p1, t1 WHERE p1.id >= 50 AND p1.id <= 51 AND p1.ctid = '(1,1)' AND p1.id = t1.id AND t1.id < 10;
LOG:  statement: /*+SeqScan(p1)*/
EXPLAIN (COSTS false) SELECT * FROM p1, t1 WHERE p1.id >= 50 AND p1.id <= 51 AND p1.ctid = '(1,1)' AND p1.id = t1.id AND t1.id < 10;
NOTICE:  SELECT uses system-defined column "p1.ctid" without the necessary companion column "p1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  pg_hint_plan:
used hint:
SeqScan(p1)
not used hint:
duplication hint:
error hint:
                                           QUERY PLAN                                            
-------------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (p1.id = t1.id)
         ->  Append
               ->  Seq Scan on p1
                     Filter: ((id >= 50) AND (id <= 51) AND (id < 10) AND (ctid = '(1,1)'::tid))
               ->  Seq Scan on p1_c1
                     Filter: ((id >= 50) AND (id <= 51) AND (id < 10) AND (ctid = '(1,1)'::tid))
               ->  Seq Scan on p1_c2
                     Filter: ((id >= 50) AND (id <= 51) AND (id < 10) AND (ctid = '(1,1)'::tid))
               ->  Seq Scan on p1_c3
                     Filter: ((id >= 50) AND (id <= 51) AND (id < 10) AND (ctid = '(1,1)'::tid))
               ->  Seq Scan on p1_c4
                     Filter: ((id >= 50) AND (id <= 51) AND (id < 10) AND (ctid = '(1,1)'::tid))
               ->  Seq Scan on p1_c1_c1
                     Filter: ((id >= 50) AND (id <= 51) AND (id < 10) AND (ctid = '(1,1)'::tid))
               ->  Seq Scan on p1_c1_c2
                     Filter: ((id >= 50) AND (id <= 51) AND (id < 10) AND (ctid = '(1,1)'::tid))
               ->  Seq Scan on p1_c3_c1
                     Filter: ((id >= 50) AND (id <= 51) AND (id < 10) AND (ctid = '(1,1)'::tid))
               ->  Seq Scan on p1_c3_c2
                     Filter: ((id >= 50) AND (id <= 51) AND (id < 10) AND (ctid = '(1,1)'::tid))
         ->  Hash
               ->  Index Scan using t1_pkey on t1
                     Index Cond: ((id < 10) AND (id >= 50) AND (id <= 51))
 Optimizer: Postgres query optimizer
(26 rows)

/*+IndexScan(p1)*/
EXPLAIN (COSTS false) SELECT * FROM p1, t1 WHERE p1.id >= 50 AND p1.id <= 51 AND p1.ctid = '(1,1)' AND p1.id = t1.id AND t1.id < 10;
LOG:  statement: /*+IndexScan(p1)*/
EXPLAIN (COSTS false) SELECT * FROM p1, t1 WHERE p1.id >= 50 AND p1.id <= 51 AND p1.ctid = '(1,1)' AND p1.id = t1.id AND t1.id < 10;
NOTICE:  SELECT uses system-defined column "p1.ctid" without the necessary companion column "p1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  pg_hint_plan:
used hint:
IndexScan(p1)
not used hint:
duplication hint:
error hint:
                                QUERY PLAN                                 
---------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (p1.id = t1.id)
         ->  Append
               ->  Index Scan using p1_pkey on p1
                     Index Cond: ((id >= 50) AND (id <= 51) AND (id < 10))
                     Filter: (ctid = '(1,1)'::tid)
               ->  Index Scan using p1_c1_pkey on p1_c1
                     Index Cond: ((id >= 50) AND (id <= 51) AND (id < 10))
                     Filter: (ctid = '(1,1)'::tid)
               ->  Index Scan using p1_c2_pkey on p1_c2
                     Index Cond: ((id >= 50) AND (id <= 51) AND (id < 10))
                     Filter: (ctid = '(1,1)'::tid)
               ->  Index Scan using p1_c3_pkey on p1_c3
                     Index Cond: ((id >= 50) AND (id <= 51) AND (id < 10))
                     Filter: (ctid = '(1,1)'::tid)
               ->  Index Scan using p1_c4_pkey on p1_c4
                     Index Cond: ((id >= 50) AND (id <= 51) AND (id < 10))
                     Filter: (ctid = '(1,1)'::tid)
               ->  Index Scan using p1_c1_c1_pkey on p1_c1_c1
                     Index Cond: ((id >= 50) AND (id <= 51) AND (id < 10))
                     Filter: (ctid = '(1,1)'::tid)
               ->  Index Scan using p1_c1_c2_pkey on p1_c1_c2
                     Index Cond: ((id >= 50) AND (id <= 51) AND (id < 10))
                     Filter: (ctid = '(1,1)'::tid)
               ->  Index Scan using p1_c3_c1_pkey on p1_c3_c1
                     Index Cond: ((id >= 50) AND (id <= 51) AND (id < 10))
                     Filter: (ctid = '(1,1)'::tid)
               ->  Index Scan using p1_c3_c2_pkey on p1_c3_c2
                     Index Cond: ((id >= 50) AND (id <= 51) AND (id < 10))
                     Filter: (ctid = '(1,1)'::tid)
         ->  Hash
               ->  Index Scan using t1_pkey on t1
                     Index Cond: ((id < 10) AND (id >= 50) AND (id <= 51))
 Optimizer: Postgres query optimizer
(35 rows)

/*+BitmapScan(p1)*/
EXPLAIN (COSTS false) SELECT * FROM p1, t1 WHERE p1.id >= 50 AND p1.id <= 51 AND p1.ctid = '(1,1)' AND p1.id = t1.id AND t1.id < 10;
LOG:  statement: /*+BitmapScan(p1)*/
EXPLAIN (COSTS false) SELECT * FROM p1, t1 WHERE p1.id >= 50 AND p1.id <= 51 AND p1.ctid = '(1,1)' AND p1.id = t1.id AND t1.id < 10;
NOTICE:  SELECT uses system-defined column "p1.ctid" without the necessary companion column "p1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  pg_hint_plan:
used hint:
BitmapScan(p1)
not used hint:
duplication hint:
error hint:
                                   QUERY PLAN                                    
---------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (p1.id = t1.id)
         ->  Append
               ->  Bitmap Heap Scan on p1
                     Recheck Cond: ((id >= 50) AND (id <= 51) AND (id < 10))
                     Filter: (ctid = '(1,1)'::tid)
                     ->  Bitmap Index Scan on p1_pkey
                           Index Cond: ((id >= 50) AND (id <= 51) AND (id < 10))
               ->  Bitmap Heap Scan on p1_c1
                     Recheck Cond: ((id >= 50) AND (id <= 51) AND (id < 10))
                     Filter: (ctid = '(1,1)'::tid)
                     ->  Bitmap Index Scan on p1_c1_pkey
                           Index Cond: ((id >= 50) AND (id <= 51) AND (id < 10))
               ->  Bitmap Heap Scan on p1_c2
                     Recheck Cond: ((id >= 50) AND (id <= 51) AND (id < 10))
                     Filter: (ctid = '(1,1)'::tid)
                     ->  Bitmap Index Scan on p1_c2_pkey
                           Index Cond: ((id >= 50) AND (id <= 51) AND (id < 10))
               ->  Bitmap Heap Scan on p1_c3
                     Recheck Cond: ((id >= 50) AND (id <= 51) AND (id < 10))
                     Filter: (ctid = '(1,1)'::tid)
                     ->  Bitmap Index Scan on p1_c3_pkey
                           Index Cond: ((id >= 50) AND (id <= 51) AND (id < 10))
               ->  Bitmap Heap Scan on p1_c4
                     Recheck Cond: ((id >= 50) AND (id <= 51) AND (id < 10))
                     Filter: (ctid = '(1,1)'::tid)
                     ->  Bitmap Index Scan on p1_c4_pkey
                           Index Cond: ((id >= 50) AND (id <= 51) AND (id < 10))
               ->  Bitmap Heap Scan on p1_c1_c1
                     Recheck Cond: ((id >= 50) AND (id <= 51) AND (id < 10))
                     Filter: (ctid = '(1,1)'::tid)
                     ->  Bitmap Index Scan on p1_c1_c1_pkey
                           Index Cond: ((id >= 50) AND (id <= 51) AND (id < 10))
               ->  Bitmap Heap Scan on p1_c1_c2
                     Recheck Cond: ((id >= 50) AND (id <= 51) AND (id < 10))
                     Filter: (ctid = '(1,1)'::tid)
                     ->  Bitmap Index Scan on p1_c1_c2_pkey
                           Index Cond: ((id >= 50) AND (id <= 51) AND (id < 10))
               ->  Bitmap Heap Scan on p1_c3_c1
                     Recheck Cond: ((id >= 50) AND (id <= 51) AND (id < 10))
                     Filter: (ctid = '(1,1)'::tid)
                     ->  Bitmap Index Scan on p1_c3_c1_pkey
                           Index Cond: ((id >= 50) AND (id <= 51) AND (id < 10))
               ->  Bitmap Heap Scan on p1_c3_c2
                     Recheck Cond: ((id >= 50) AND (id <= 51) AND (id < 10))
                     Filter: (ctid = '(1,1)'::tid)
                     ->  Bitmap Index Scan on p1_c3_c2_pkey
                           Index Cond: ((id >= 50) AND (id <= 51) AND (id < 10))
         ->  Hash
               ->  Index Scan using t1_pkey on t1
                     Index Cond: ((id < 10) AND (id >= 50) AND (id <= 51))
 Optimizer: Postgres query optimizer
(53 rows)

/*+TidScan(p1)*/
EXPLAIN (COSTS false) SELECT * FROM p1, t1 WHERE p1.id >= 50 AND p1.id <= 51 AND p1.ctid = '(1,1)' AND p1.id = t1.id AND t1.id < 10;
LOG:  statement: /*+TidScan(p1)*/
EXPLAIN (COSTS false) SELECT * FROM p1, t1 WHERE p1.id >= 50 AND p1.id <= 51 AND p1.ctid = '(1,1)' AND p1.id = t1.id AND t1.id < 10;
NOTICE:  SELECT uses system-defined column "p1.ctid" without the necessary companion column "p1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  pg_hint_plan:
used hint:
TidScan(p1)
not used hint:
duplication hint:
error hint:
                                QUERY PLAN                                 
---------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (p1.id = t1.id)
         ->  Append
               ->  Tid Scan on p1
                     TID Cond: (ctid = '(1,1)'::tid)
                     Filter: ((id >= 50) AND (id <= 51) AND (id < 10))
               ->  Tid Scan on p1_c1
                     TID Cond: (ctid = '(1,1)'::tid)
                     Filter: ((id >= 50) AND (id <= 51) AND (id < 10))
               ->  Tid Scan on p1_c2
                     TID Cond: (ctid = '(1,1)'::tid)
                     Filter: ((id >= 50) AND (id <= 51) AND (id < 10))
               ->  Tid Scan on p1_c3
                     TID Cond: (ctid = '(1,1)'::tid)
                     Filter: ((id >= 50) AND (id <= 51) AND (id < 10))
               ->  Tid Scan on p1_c4
                     TID Cond: (ctid = '(1,1)'::tid)
                     Filter: ((id >= 50) AND (id <= 51) AND (id < 10))
               ->  Tid Scan on p1_c1_c1
                     TID Cond: (ctid = '(1,1)'::tid)
                     Filter: ((id >= 50) AND (id <= 51) AND (id < 10))
               ->  Tid Scan on p1_c1_c2
                     TID Cond: (ctid = '(1,1)'::tid)
                     Filter: ((id >= 50) AND (id <= 51) AND (id < 10))
               ->  Tid Scan on p1_c3_c1
                     TID Cond: (ctid = '(1,1)'::tid)
                     Filter: ((id >= 50) AND (id <= 51) AND (id < 10))
               ->  Tid Scan on p1_c3_c2
                     TID Cond: (ctid = '(1,1)'::tid)
                     Filter: ((id >= 50) AND (id <= 51) AND (id < 10))
         ->  Hash
               ->  Index Scan using t1_pkey on t1
                     Index Cond: ((id < 10) AND (id >= 50) AND (id <= 51))
 Optimizer: Postgres query optimizer
(35 rows)

/*+NestLoop(p1 t1)*/
EXPLAIN (COSTS false) SELECT * FROM p1, t1 WHERE p1.id >= 50 AND p1.id <= 51 AND p1.ctid = '(1,1)' AND p1.id = t1.id AND t1.id < 10;
LOG:  statement: /*+NestLoop(p1 t1)*/
EXPLAIN (COSTS false) SELECT * FROM p1, t1 WHERE p1.id >= 50 AND p1.id <= 51 AND p1.ctid = '(1,1)' AND p1.id = t1.id AND t1.id < 10;
NOTICE:  SELECT uses system-defined column "p1.ctid" without the necessary companion column "p1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  pg_hint_plan:
used hint:
NestLoop(p1 t1)
not used hint:
duplication hint:
error hint:
                                           QUERY PLAN                                            
-------------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Nested Loop
         Join Filter: (p1.id = t1.id)
         ->  Index Scan using t1_pkey on t1
               Index Cond: ((id < 10) AND (id >= 50) AND (id <= 51))
         ->  Append
               ->  Seq Scan on p1
                     Filter: ((id >= 50) AND (id <= 51) AND (id < 10) AND (ctid = '(1,1)'::tid))
               ->  Seq Scan on p1_c1
                     Filter: ((id >= 50) AND (id <= 51) AND (id < 10) AND (ctid = '(1,1)'::tid))
               ->  Seq Scan on p1_c2
                     Filter: ((id >= 50) AND (id <= 51) AND (id < 10) AND (ctid = '(1,1)'::tid))
               ->  Seq Scan on p1_c3
                     Filter: ((id >= 50) AND (id <= 51) AND (id < 10) AND (ctid = '(1,1)'::tid))
               ->  Seq Scan on p1_c4
                     Filter: ((id >= 50) AND (id <= 51) AND (id < 10) AND (ctid = '(1,1)'::tid))
               ->  Seq Scan on p1_c1_c1
                     Filter: ((id >= 50) AND (id <= 51) AND (id < 10) AND (ctid = '(1,1)'::tid))
               ->  Seq Scan on p1_c1_c2
                     Filter: ((id >= 50) AND (id <= 51) AND (id < 10) AND (ctid = '(1,1)'::tid))
               ->  Seq Scan on p1_c3_c1
                     Filter: ((id >= 50) AND (id <= 51) AND (id < 10) AND (ctid = '(1,1)'::tid))
               ->  Seq Scan on p1_c3_c2
                     Filter: ((id >= 50) AND (id <= 51) AND (id < 10) AND (ctid = '(1,1)'::tid))
 Optimizer: Postgres query optimizer
(25 rows)

/*+MergeJoin(p1 t1)*/
EXPLAIN (COSTS false) SELECT * FROM p1, t1 WHERE p1.id >= 50 AND p1.id <= 51 AND p1.ctid = '(1,1)' AND p1.id = t1.id AND t1.id < 10;
LOG:  statement: /*+MergeJoin(p1 t1)*/
EXPLAIN (COSTS false) SELECT * FROM p1, t1 WHERE p1.id >= 50 AND p1.id <= 51 AND p1.ctid = '(1,1)' AND p1.id = t1.id AND t1.id < 10;
NOTICE:  SELECT uses system-defined column "p1.ctid" without the necessary companion column "p1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  pg_hint_plan:
used hint:
MergeJoin(p1 t1)
not used hint:
duplication hint:
error hint:
                                              QUERY PLAN                                               
-------------------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Merge Join
         Merge Cond: (p1.id = t1.id)
         ->  Sort
               Sort Key: p1.id
               ->  Append
                     ->  Seq Scan on p1
                           Filter: ((id >= 50) AND (id <= 51) AND (id < 10) AND (ctid = '(1,1)'::tid))
                     ->  Seq Scan on p1_c1
                           Filter: ((id >= 50) AND (id <= 51) AND (id < 10) AND (ctid = '(1,1)'::tid))
                     ->  Seq Scan on p1_c2
                           Filter: ((id >= 50) AND (id <= 51) AND (id < 10) AND (ctid = '(1,1)'::tid))
                     ->  Seq Scan on p1_c3
                           Filter: ((id >= 50) AND (id <= 51) AND (id < 10) AND (ctid = '(1,1)'::tid))
                     ->  Seq Scan on p1_c4
                           Filter: ((id >= 50) AND (id <= 51) AND (id < 10) AND (ctid = '(1,1)'::tid))
                     ->  Seq Scan on p1_c1_c1
                           Filter: ((id >= 50) AND (id <= 51) AND (id < 10) AND (ctid = '(1,1)'::tid))
                     ->  Seq Scan on p1_c1_c2
                           Filter: ((id >= 50) AND (id <= 51) AND (id < 10) AND (ctid = '(1,1)'::tid))
                     ->  Seq Scan on p1_c3_c1
                           Filter: ((id >= 50) AND (id <= 51) AND (id < 10) AND (ctid = '(1,1)'::tid))
                     ->  Seq Scan on p1_c3_c2
                           Filter: ((id >= 50) AND (id <= 51) AND (id < 10) AND (ctid = '(1,1)'::tid))
         ->  Index Scan using t1_pkey on t1
               Index Cond: ((id < 10) AND (id >= 50) AND (id <= 51))
 Optimizer: Postgres query optimizer
(27 rows)

/*+HashJoin(p1 t1)*/
EXPLAIN (COSTS false) SELECT * FROM p1, t1 WHERE p1.id >= 50 AND p1.id <= 51 AND p1.ctid = '(1,1)' AND p1.id = t1.id AND t1.id < 10;
LOG:  statement: /*+HashJoin(p1 t1)*/
EXPLAIN (COSTS false) SELECT * FROM p1, t1 WHERE p1.id >= 50 AND p1.id <= 51 AND p1.ctid = '(1,1)' AND p1.id = t1.id AND t1.id < 10;
NOTICE:  SELECT uses system-defined column "p1.ctid" without the necessary companion column "p1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
WARNING:  "work_mem": setting is deprecated, and may be removed in a future release.
LOG:  pg_hint_plan:
used hint:
HashJoin(p1 t1)
not used hint:
duplication hint:
error hint:
                                           QUERY PLAN                                            
-------------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (p1.id = t1.id)
         ->  Append
               ->  Seq Scan on p1
                     Filter: ((id >= 50) AND (id <= 51) AND (id < 10) AND (ctid = '(1,1)'::tid))
               ->  Seq Scan on p1_c1
                     Filter: ((id >= 50) AND (id <= 51) AND (id < 10) AND (ctid = '(1,1)'::tid))
               ->  Seq Scan on p1_c2
                     Filter: ((id >= 50) AND (id <= 51) AND (id < 10) AND (ctid = '(1,1)'::tid))
               ->  Seq Scan on p1_c3
                     Filter: ((id >= 50) AND (id <= 51) AND (id < 10) AND (ctid = '(1,1)'::tid))
               ->  Seq Scan on p1_c4
                     Filter: ((id >= 50) AND (id <= 51) AND (id < 10) AND (ctid = '(1,1)'::tid))
               ->  Seq Scan on p1_c1_c1
                     Filter: ((id >= 50) AND (id <= 51) AND (id < 10) AND (ctid = '(1,1)'::tid))
               ->  Seq Scan on p1_c1_c2
                     Filter: ((id >= 50) AND (id <= 51) AND (id < 10) AND (ctid = '(1,1)'::tid))
               ->  Seq Scan on p1_c3_c1
                     Filter: ((id >= 50) AND (id <= 51) AND (id < 10) AND (ctid = '(1,1)'::tid))
               ->  Seq Scan on p1_c3_c2
                     Filter: ((id >= 50) AND (id <= 51) AND (id < 10) AND (ctid = '(1,1)'::tid))
         ->  Hash
               ->  Index Scan using t1_pkey on t1
                     Index Cond: ((id < 10) AND (id >= 50) AND (id <= 51))
 Optimizer: Postgres query optimizer
(26 rows)

SET constraint_exclusion TO on;
LOG:  statement: SET constraint_exclusion TO on;
/*+SeqScan(p1)*/
EXPLAIN (COSTS false) SELECT * FROM p1, t1 WHERE p1.id >= 50 AND p1.id <= 51 AND p1.ctid = '(1,1)' AND p1.id = t1.id AND t1.id < 10;
LOG:  statement: /*+SeqScan(p1)*/
EXPLAIN (COSTS false) SELECT * FROM p1, t1 WHERE p1.id >= 50 AND p1.id <= 51 AND p1.ctid = '(1,1)' AND p1.id = t1.id AND t1.id < 10;
NOTICE:  SELECT uses system-defined column "p1.ctid" without the necessary companion column "p1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  pg_hint_plan:
used hint:
not used hint:
SeqScan(p1)
duplication hint:
error hint:
             QUERY PLAN              
-------------------------------------
 Result
   One-Time Filter: false
 Optimizer: Postgres query optimizer
(3 rows)

/*+IndexScan(p1)*/
EXPLAIN (COSTS false) SELECT * FROM p1, t1 WHERE p1.id >= 50 AND p1.id <= 51 AND p1.ctid = '(1,1)' AND p1.id = t1.id AND t1.id < 10;
LOG:  statement: /*+IndexScan(p1)*/
EXPLAIN (COSTS false) SELECT * FROM p1, t1 WHERE p1.id >= 50 AND p1.id <= 51 AND p1.ctid = '(1,1)' AND p1.id = t1.id AND t1.id < 10;
NOTICE:  SELECT uses system-defined column "p1.ctid" without the necessary companion column "p1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  pg_hint_plan:
used hint:
not used hint:
IndexScan(p1)
duplication hint:
error hint:
             QUERY PLAN              
-------------------------------------
 Result
   One-Time Filter: false
 Optimizer: Postgres query optimizer
(3 rows)

/*+BitmapScan(p1)*/
EXPLAIN (COSTS false) SELECT * FROM p1, t1 WHERE p1.id >= 50 AND p1.id <= 51 AND p1.ctid = '(1,1)' AND p1.id = t1.id AND t1.id < 10;
LOG:  statement: /*+BitmapScan(p1)*/
EXPLAIN (COSTS false) SELECT * FROM p1, t1 WHERE p1.id >= 50 AND p1.id <= 51 AND p1.ctid = '(1,1)' AND p1.id = t1.id AND t1.id < 10;
NOTICE:  SELECT uses system-defined column "p1.ctid" without the necessary companion column "p1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  pg_hint_plan:
used hint:
not used hint:
BitmapScan(p1)
duplication hint:
error hint:
             QUERY PLAN              
-------------------------------------
 Result
   One-Time Filter: false
 Optimizer: Postgres query optimizer
(3 rows)

/*+TidScan(p1)*/
EXPLAIN (COSTS false) SELECT * FROM p1, t1 WHERE p1.id >= 50 AND p1.id <= 51 AND p1.ctid = '(1,1)' AND p1.id = t1.id AND t1.id < 10;
LOG:  statement: /*+TidScan(p1)*/
EXPLAIN (COSTS false) SELECT * FROM p1, t1 WHERE p1.id >= 50 AND p1.id <= 51 AND p1.ctid = '(1,1)' AND p1.id = t1.id AND t1.id < 10;
NOTICE:  SELECT uses system-defined column "p1.ctid" without the necessary companion column "p1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  pg_hint_plan:
used hint:
not used hint:
TidScan(p1)
duplication hint:
error hint:
             QUERY PLAN              
-------------------------------------
 Result
   One-Time Filter: false
 Optimizer: Postgres query optimizer
(3 rows)

/*+NestLoop(p1 t1)*/
EXPLAIN (COSTS false) SELECT * FROM p1, t1 WHERE p1.id >= 50 AND p1.id <= 51 AND p1.ctid = '(1,1)' AND p1.id = t1.id AND t1.id < 10;
LOG:  statement: /*+NestLoop(p1 t1)*/
EXPLAIN (COSTS false) SELECT * FROM p1, t1 WHERE p1.id >= 50 AND p1.id <= 51 AND p1.ctid = '(1,1)' AND p1.id = t1.id AND t1.id < 10;
NOTICE:  SELECT uses system-defined column "p1.ctid" without the necessary companion column "p1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  pg_hint_plan:
used hint:
NestLoop(p1 t1)
not used hint:
duplication hint:
error hint:
             QUERY PLAN              
-------------------------------------
 Result
   One-Time Filter: false
 Optimizer: Postgres query optimizer
(3 rows)

/*+MergeJoin(p1 t1)*/
EXPLAIN (COSTS false) SELECT * FROM p1, t1 WHERE p1.id >= 50 AND p1.id <= 51 AND p1.ctid = '(1,1)' AND p1.id = t1.id AND t1.id < 10;
LOG:  statement: /*+MergeJoin(p1 t1)*/
EXPLAIN (COSTS false) SELECT * FROM p1, t1 WHERE p1.id >= 50 AND p1.id <= 51 AND p1.ctid = '(1,1)' AND p1.id = t1.id AND t1.id < 10;
NOTICE:  SELECT uses system-defined column "p1.ctid" without the necessary companion column "p1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  pg_hint_plan:
used hint:
MergeJoin(p1 t1)
not used hint:
duplication hint:
error hint:
             QUERY PLAN              
-------------------------------------
 Result
   One-Time Filter: false
 Optimizer: Postgres query optimizer
(3 rows)

/*+HashJoin(p1 t1)*/
EXPLAIN (COSTS false) SELECT * FROM p1, t1 WHERE p1.id >= 50 AND p1.id <= 51 AND p1.ctid = '(1,1)' AND p1.id = t1.id AND t1.id < 10;
LOG:  statement: /*+HashJoin(p1 t1)*/
EXPLAIN (COSTS false) SELECT * FROM p1, t1 WHERE p1.id >= 50 AND p1.id <= 51 AND p1.ctid = '(1,1)' AND p1.id = t1.id AND t1.id < 10;
NOTICE:  SELECT uses system-defined column "p1.ctid" without the necessary companion column "p1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
WARNING:  "work_mem": setting is deprecated, and may be removed in a future release.
LOG:  pg_hint_plan:
used hint:
HashJoin(p1 t1)
not used hint:
duplication hint:
error hint:
             QUERY PLAN              
-------------------------------------
 Result
   One-Time Filter: false
 Optimizer: Postgres query optimizer
(3 rows)

SET constraint_exclusion TO off;
LOG:  statement: SET constraint_exclusion TO off;
EXPLAIN (COSTS false) SELECT * FROM ONLY p1 WHERE id >= 50 AND id <= 51 AND p1.ctid = '(1,1)';
LOG:  statement: EXPLAIN (COSTS false) SELECT * FROM ONLY p1 WHERE id >= 50 AND id <= 51 AND p1.ctid = '(1,1)';
NOTICE:  SELECT uses system-defined column "p1.ctid" without the necessary companion column "p1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
                              QUERY PLAN                               
-----------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Seq Scan on p1
         Filter: ((id >= 50) AND (id <= 51) AND (ctid = '(1,1)'::tid))
 Optimizer: Postgres query optimizer
(4 rows)

SET constraint_exclusion TO on;
LOG:  statement: SET constraint_exclusion TO on;
EXPLAIN (COSTS false) SELECT * FROM ONLY p1 WHERE id >= 50 AND id <= 51 AND p1.ctid = '(1,1)';
LOG:  statement: EXPLAIN (COSTS false) SELECT * FROM ONLY p1 WHERE id >= 50 AND id <= 51 AND p1.ctid = '(1,1)';
NOTICE:  SELECT uses system-defined column "p1.ctid" without the necessary companion column "p1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
                              QUERY PLAN                               
-----------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Seq Scan on p1
         Filter: ((id >= 50) AND (id <= 51) AND (ctid = '(1,1)'::tid))
 Optimizer: Postgres query optimizer
(4 rows)

SET constraint_exclusion TO off;
LOG:  statement: SET constraint_exclusion TO off;
/*+SeqScan(p1)*/
EXPLAIN (COSTS false) SELECT * FROM ONLY p1 WHERE id >= 50 AND id <= 51 AND p1.ctid = '(1,1)';
LOG:  statement: /*+SeqScan(p1)*/
EXPLAIN (COSTS false) SELECT * FROM ONLY p1 WHERE id >= 50 AND id <= 51 AND p1.ctid = '(1,1)';
NOTICE:  SELECT uses system-defined column "p1.ctid" without the necessary companion column "p1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  pg_hint_plan:
used hint:
SeqScan(p1)
not used hint:
duplication hint:
error hint:
                              QUERY PLAN                               
-----------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Seq Scan on p1
         Filter: ((id >= 50) AND (id <= 51) AND (ctid = '(1,1)'::tid))
 Optimizer: Postgres query optimizer
(4 rows)

/*+IndexScan(p1)*/
EXPLAIN (COSTS false) SELECT * FROM ONLY p1 WHERE id >= 50 AND id <= 51 AND p1.ctid = '(1,1)';
LOG:  statement: /*+IndexScan(p1)*/
EXPLAIN (COSTS false) SELECT * FROM ONLY p1 WHERE id >= 50 AND id <= 51 AND p1.ctid = '(1,1)';
NOTICE:  SELECT uses system-defined column "p1.ctid" without the necessary companion column "p1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  pg_hint_plan:
used hint:
IndexScan(p1)
not used hint:
duplication hint:
error hint:
                   QUERY PLAN                    
-------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Index Scan using p1_pkey on p1
         Index Cond: ((id >= 50) AND (id <= 51))
         Filter: (ctid = '(1,1)'::tid)
 Optimizer: Postgres query optimizer
(5 rows)

/*+BitmapScan(p1)*/
EXPLAIN (COSTS false) SELECT * FROM ONLY p1 WHERE id >= 50 AND id <= 51 AND p1.ctid = '(1,1)';
LOG:  statement: /*+BitmapScan(p1)*/
EXPLAIN (COSTS false) SELECT * FROM ONLY p1 WHERE id >= 50 AND id <= 51 AND p1.ctid = '(1,1)';
NOTICE:  SELECT uses system-defined column "p1.ctid" without the necessary companion column "p1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  pg_hint_plan:
used hint:
BitmapScan(p1)
not used hint:
duplication hint:
error hint:
                      QUERY PLAN                       
-------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Bitmap Heap Scan on p1
         Recheck Cond: ((id >= 50) AND (id <= 51))
         Filter: (ctid = '(1,1)'::tid)
         ->  Bitmap Index Scan on p1_pkey
               Index Cond: ((id >= 50) AND (id <= 51))
 Optimizer: Postgres query optimizer
(7 rows)

/*+TidScan(p1)*/
EXPLAIN (COSTS false) SELECT * FROM ONLY p1 WHERE id >= 50 AND id <= 51 AND p1.ctid = '(1,1)';
LOG:  statement: /*+TidScan(p1)*/
EXPLAIN (COSTS false) SELECT * FROM ONLY p1 WHERE id >= 50 AND id <= 51 AND p1.ctid = '(1,1)';
NOTICE:  SELECT uses system-defined column "p1.ctid" without the necessary companion column "p1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  pg_hint_plan:
used hint:
TidScan(p1)
not used hint:
duplication hint:
error hint:
                 QUERY PLAN                  
---------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Tid Scan on p1
         TID Cond: (ctid = '(1,1)'::tid)
         Filter: ((id >= 50) AND (id <= 51))
 Optimizer: Postgres query optimizer
(5 rows)

/*+NestLoop(p1 t1)*/
EXPLAIN (COSTS false) SELECT * FROM ONLY p1, t1 WHERE p1.id >= 50 AND p1.id <= 51 AND p1.ctid = '(1,1)' AND p1.id = t1.id AND t1.id < 10;
LOG:  statement: /*+NestLoop(p1 t1)*/
EXPLAIN (COSTS false) SELECT * FROM ONLY p1, t1 WHERE p1.id >= 50 AND p1.id <= 51 AND p1.ctid = '(1,1)' AND p1.id = t1.id AND t1.id < 10;
NOTICE:  SELECT uses system-defined column "p1.ctid" without the necessary companion column "p1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  pg_hint_plan:
used hint:
NestLoop(p1 t1)
not used hint:
duplication hint:
error hint:
                                        QUERY PLAN                                         
-------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Nested Loop
         Join Filter: (p1.id = t1.id)
         ->  Seq Scan on p1
               Filter: ((id >= 50) AND (id <= 51) AND (id < 10) AND (ctid = '(1,1)'::tid))
         ->  Index Scan using t1_pkey on t1
               Index Cond: ((id < 10) AND (id >= 50) AND (id <= 51))
 Optimizer: Postgres query optimizer
(8 rows)

/*+MergeJoin(p1 t1)*/
EXPLAIN (COSTS false) SELECT * FROM ONLY p1, t1 WHERE p1.id >= 50 AND p1.id <= 51 AND p1.ctid = '(1,1)' AND p1.id = t1.id AND t1.id < 10;
LOG:  statement: /*+MergeJoin(p1 t1)*/
EXPLAIN (COSTS false) SELECT * FROM ONLY p1, t1 WHERE p1.id >= 50 AND p1.id <= 51 AND p1.ctid = '(1,1)' AND p1.id = t1.id AND t1.id < 10;
NOTICE:  SELECT uses system-defined column "p1.ctid" without the necessary companion column "p1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  pg_hint_plan:
used hint:
MergeJoin(p1 t1)
not used hint:
duplication hint:
error hint:
                                           QUERY PLAN                                            
-------------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Merge Join
         Merge Cond: (p1.id = t1.id)
         ->  Sort
               Sort Key: p1.id
               ->  Seq Scan on p1
                     Filter: ((id >= 50) AND (id <= 51) AND (id < 10) AND (ctid = '(1,1)'::tid))
         ->  Index Scan using t1_pkey on t1
               Index Cond: ((id < 10) AND (id >= 50) AND (id <= 51))
 Optimizer: Postgres query optimizer
(10 rows)

/*+HashJoin(p1 t1)*/
EXPLAIN (COSTS false) SELECT * FROM ONLY p1, t1 WHERE p1.id >= 50 AND p1.id <= 51 AND p1.ctid = '(1,1)' AND p1.id = t1.id AND t1.id < 10;
LOG:  statement: /*+HashJoin(p1 t1)*/
EXPLAIN (COSTS false) SELECT * FROM ONLY p1, t1 WHERE p1.id >= 50 AND p1.id <= 51 AND p1.ctid = '(1,1)' AND p1.id = t1.id AND t1.id < 10;
NOTICE:  SELECT uses system-defined column "p1.ctid" without the necessary companion column "p1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
WARNING:  "work_mem": setting is deprecated, and may be removed in a future release.
LOG:  pg_hint_plan:
used hint:
HashJoin(p1 t1)
not used hint:
duplication hint:
error hint:
                                           QUERY PLAN                                            
-------------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t1.id = p1.id)
         ->  Index Scan using t1_pkey on t1
               Index Cond: ((id < 10) AND (id >= 50) AND (id <= 51))
         ->  Hash
               ->  Seq Scan on p1
                     Filter: ((id >= 50) AND (id <= 51) AND (id < 10) AND (ctid = '(1,1)'::tid))
 Optimizer: Postgres query optimizer
(9 rows)

SET constraint_exclusion TO on;
LOG:  statement: SET constraint_exclusion TO on;
/*+SeqScan(p1)*/
EXPLAIN (COSTS false) SELECT * FROM ONLY p1 WHERE id >= 50 AND id <= 51 AND p1.ctid = '(1,1)';
LOG:  statement: /*+SeqScan(p1)*/
EXPLAIN (COSTS false) SELECT * FROM ONLY p1 WHERE id >= 50 AND id <= 51 AND p1.ctid = '(1,1)';
NOTICE:  SELECT uses system-defined column "p1.ctid" without the necessary companion column "p1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  pg_hint_plan:
used hint:
SeqScan(p1)
not used hint:
duplication hint:
error hint:
                              QUERY PLAN                               
-----------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Seq Scan on p1
         Filter: ((id >= 50) AND (id <= 51) AND (ctid = '(1,1)'::tid))
 Optimizer: Postgres query optimizer
(4 rows)

/*+IndexScan(p1)*/
EXPLAIN (COSTS false) SELECT * FROM ONLY p1 WHERE id >= 50 AND id <= 51 AND p1.ctid = '(1,1)';
LOG:  statement: /*+IndexScan(p1)*/
EXPLAIN (COSTS false) SELECT * FROM ONLY p1 WHERE id >= 50 AND id <= 51 AND p1.ctid = '(1,1)';
NOTICE:  SELECT uses system-defined column "p1.ctid" without the necessary companion column "p1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  pg_hint_plan:
used hint:
IndexScan(p1)
not used hint:
duplication hint:
error hint:
                   QUERY PLAN                    
-------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Index Scan using p1_pkey on p1
         Index Cond: ((id >= 50) AND (id <= 51))
         Filter: (ctid = '(1,1)'::tid)
 Optimizer: Postgres query optimizer
(5 rows)

/*+BitmapScan(p1)*/
EXPLAIN (COSTS false) SELECT * FROM ONLY p1 WHERE id >= 50 AND id <= 51 AND p1.ctid = '(1,1)';
LOG:  statement: /*+BitmapScan(p1)*/
EXPLAIN (COSTS false) SELECT * FROM ONLY p1 WHERE id >= 50 AND id <= 51 AND p1.ctid = '(1,1)';
NOTICE:  SELECT uses system-defined column "p1.ctid" without the necessary companion column "p1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  pg_hint_plan:
used hint:
BitmapScan(p1)
not used hint:
duplication hint:
error hint:
                      QUERY PLAN                       
-------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Bitmap Heap Scan on p1
         Recheck Cond: ((id >= 50) AND (id <= 51))
         Filter: (ctid = '(1,1)'::tid)
         ->  Bitmap Index Scan on p1_pkey
               Index Cond: ((id >= 50) AND (id <= 51))
 Optimizer: Postgres query optimizer
(7 rows)

/*+TidScan(p1)*/
EXPLAIN (COSTS false) SELECT * FROM ONLY p1 WHERE id >= 50 AND id <= 51 AND p1.ctid = '(1,1)';
LOG:  statement: /*+TidScan(p1)*/
EXPLAIN (COSTS false) SELECT * FROM ONLY p1 WHERE id >= 50 AND id <= 51 AND p1.ctid = '(1,1)';
NOTICE:  SELECT uses system-defined column "p1.ctid" without the necessary companion column "p1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  pg_hint_plan:
used hint:
TidScan(p1)
not used hint:
duplication hint:
error hint:
                 QUERY PLAN                  
---------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Tid Scan on p1
         TID Cond: (ctid = '(1,1)'::tid)
         Filter: ((id >= 50) AND (id <= 51))
 Optimizer: Postgres query optimizer
(5 rows)

/*+NestLoop(p1 t1)*/
EXPLAIN (COSTS false) SELECT * FROM ONLY p1, t1 WHERE p1.id >= 50 AND p1.id <= 51 AND p1.ctid = '(1,1)' AND p1.id = t1.id AND t1.id < 10;
LOG:  statement: /*+NestLoop(p1 t1)*/
EXPLAIN (COSTS false) SELECT * FROM ONLY p1, t1 WHERE p1.id >= 50 AND p1.id <= 51 AND p1.ctid = '(1,1)' AND p1.id = t1.id AND t1.id < 10;
NOTICE:  SELECT uses system-defined column "p1.ctid" without the necessary companion column "p1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  pg_hint_plan:
used hint:
NestLoop(p1 t1)
not used hint:
duplication hint:
error hint:
             QUERY PLAN              
-------------------------------------
 Result
   One-Time Filter: false
 Optimizer: Postgres query optimizer
(3 rows)

/*+MergeJoin(p1 t1)*/
EXPLAIN (COSTS false) SELECT * FROM ONLY p1, t1 WHERE p1.id >= 50 AND p1.id <= 51 AND p1.ctid = '(1,1)' AND p1.id = t1.id AND t1.id < 10;
LOG:  statement: /*+MergeJoin(p1 t1)*/
EXPLAIN (COSTS false) SELECT * FROM ONLY p1, t1 WHERE p1.id >= 50 AND p1.id <= 51 AND p1.ctid = '(1,1)' AND p1.id = t1.id AND t1.id < 10;
NOTICE:  SELECT uses system-defined column "p1.ctid" without the necessary companion column "p1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  pg_hint_plan:
used hint:
MergeJoin(p1 t1)
not used hint:
duplication hint:
error hint:
             QUERY PLAN              
-------------------------------------
 Result
   One-Time Filter: false
 Optimizer: Postgres query optimizer
(3 rows)

/*+HashJoin(p1 t1)*/
EXPLAIN (COSTS false) SELECT * FROM ONLY p1, t1 WHERE p1.id >= 50 AND p1.id <= 51 AND p1.ctid = '(1,1)' AND p1.id = t1.id AND t1.id < 10;
LOG:  statement: /*+HashJoin(p1 t1)*/
EXPLAIN (COSTS false) SELECT * FROM ONLY p1, t1 WHERE p1.id >= 50 AND p1.id <= 51 AND p1.ctid = '(1,1)' AND p1.id = t1.id AND t1.id < 10;
NOTICE:  SELECT uses system-defined column "p1.ctid" without the necessary companion column "p1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
WARNING:  "work_mem": setting is deprecated, and may be removed in a future release.
LOG:  pg_hint_plan:
used hint:
HashJoin(p1 t1)
not used hint:
duplication hint:
error hint:
             QUERY PLAN              
-------------------------------------
 Result
   One-Time Filter: false
 Optimizer: Postgres query optimizer
(3 rows)

SET constraint_exclusion TO off;
LOG:  statement: SET constraint_exclusion TO off;
EXPLAIN (COSTS false) SELECT * FROM ONLY p1, t1 WHERE p1.id >= 50 AND p1.id <= 51 AND p1.ctid = '(1,1)' AND p1.id = t1.id AND t1.id < 10;
LOG:  statement: EXPLAIN (COSTS false) SELECT * FROM ONLY p1, t1 WHERE p1.id >= 50 AND p1.id <= 51 AND p1.ctid = '(1,1)' AND p1.id = t1.id AND t1.id < 10;
NOTICE:  SELECT uses system-defined column "p1.ctid" without the necessary companion column "p1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
                                           QUERY PLAN                                            
-------------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t1.id = p1.id)
         ->  Index Scan using t1_pkey on t1
               Index Cond: ((id < 10) AND (id >= 50) AND (id <= 51))
         ->  Hash
               ->  Seq Scan on p1
                     Filter: ((id >= 50) AND (id <= 51) AND (id < 10) AND (ctid = '(1,1)'::tid))
 Optimizer: Postgres query optimizer
(9 rows)

SET constraint_exclusion TO on;
LOG:  statement: SET constraint_exclusion TO on;
EXPLAIN (COSTS false) SELECT * FROM ONLY p1, t1 WHERE p1.id >= 50 AND p1.id <= 51 AND p1.ctid = '(1,1)' AND p1.id = t1.id AND t1.id < 10;
LOG:  statement: EXPLAIN (COSTS false) SELECT * FROM ONLY p1, t1 WHERE p1.id >= 50 AND p1.id <= 51 AND p1.ctid = '(1,1)' AND p1.id = t1.id AND t1.id < 10;
NOTICE:  SELECT uses system-defined column "p1.ctid" without the necessary companion column "p1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
             QUERY PLAN              
-------------------------------------
 Result
   One-Time Filter: false
 Optimizer: Postgres query optimizer
(3 rows)

SET constraint_exclusion TO off;
LOG:  statement: SET constraint_exclusion TO off;
/*+SeqScan(p1)*/
EXPLAIN (COSTS false) SELECT * FROM ONLY p1, t1 WHERE p1.id >= 50 AND p1.id <= 51 AND p1.ctid = '(1,1)' AND p1.id = t1.id AND t1.id < 10;
LOG:  statement: /*+SeqScan(p1)*/
EXPLAIN (COSTS false) SELECT * FROM ONLY p1, t1 WHERE p1.id >= 50 AND p1.id <= 51 AND p1.ctid = '(1,1)' AND p1.id = t1.id AND t1.id < 10;
NOTICE:  SELECT uses system-defined column "p1.ctid" without the necessary companion column "p1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  pg_hint_plan:
used hint:
SeqScan(p1)
not used hint:
duplication hint:
error hint:
                                           QUERY PLAN                                            
-------------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t1.id = p1.id)
         ->  Index Scan using t1_pkey on t1
               Index Cond: ((id < 10) AND (id >= 50) AND (id <= 51))
         ->  Hash
               ->  Seq Scan on p1
                     Filter: ((id >= 50) AND (id <= 51) AND (id < 10) AND (ctid = '(1,1)'::tid))
 Optimizer: Postgres query optimizer
(9 rows)

/*+IndexScan(p1)*/
EXPLAIN (COSTS false) SELECT * FROM ONLY p1, t1 WHERE p1.id >= 50 AND p1.id <= 51 AND p1.ctid = '(1,1)' AND p1.id = t1.id AND t1.id < 10;
LOG:  statement: /*+IndexScan(p1)*/
EXPLAIN (COSTS false) SELECT * FROM ONLY p1, t1 WHERE p1.id >= 50 AND p1.id <= 51 AND p1.ctid = '(1,1)' AND p1.id = t1.id AND t1.id < 10;
NOTICE:  SELECT uses system-defined column "p1.ctid" without the necessary companion column "p1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  pg_hint_plan:
used hint:
IndexScan(p1)
not used hint:
duplication hint:
error hint:
                                QUERY PLAN                                 
---------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (p1.id = t1.id)
         ->  Index Scan using p1_pkey on p1
               Index Cond: ((id >= 50) AND (id <= 51) AND (id < 10))
               Filter: (ctid = '(1,1)'::tid)
         ->  Hash
               ->  Index Scan using t1_pkey on t1
                     Index Cond: ((id < 10) AND (id >= 50) AND (id <= 51))
 Optimizer: Postgres query optimizer
(10 rows)

/*+BitmapScan(p1)*/
EXPLAIN (COSTS false) SELECT * FROM ONLY p1, t1 WHERE p1.id >= 50 AND p1.id <= 51 AND p1.ctid = '(1,1)' AND p1.id = t1.id AND t1.id < 10;
LOG:  statement: /*+BitmapScan(p1)*/
EXPLAIN (COSTS false) SELECT * FROM ONLY p1, t1 WHERE p1.id >= 50 AND p1.id <= 51 AND p1.ctid = '(1,1)' AND p1.id = t1.id AND t1.id < 10;
NOTICE:  SELECT uses system-defined column "p1.ctid" without the necessary companion column "p1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  pg_hint_plan:
used hint:
BitmapScan(p1)
not used hint:
duplication hint:
error hint:
                                   QUERY PLAN                                    
---------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t1.id = p1.id)
         ->  Index Scan using t1_pkey on t1
               Index Cond: ((id < 10) AND (id >= 50) AND (id <= 51))
         ->  Hash
               ->  Bitmap Heap Scan on p1
                     Recheck Cond: ((id >= 50) AND (id <= 51) AND (id < 10))
                     Filter: (ctid = '(1,1)'::tid)
                     ->  Bitmap Index Scan on p1_pkey
                           Index Cond: ((id >= 50) AND (id <= 51) AND (id < 10))
 Optimizer: Postgres query optimizer
(12 rows)

/*+TidScan(p1)*/
EXPLAIN (COSTS false) SELECT * FROM ONLY p1, t1 WHERE p1.id >= 50 AND p1.id <= 51 AND p1.ctid = '(1,1)' AND p1.id = t1.id AND t1.id < 10;
LOG:  statement: /*+TidScan(p1)*/
EXPLAIN (COSTS false) SELECT * FROM ONLY p1, t1 WHERE p1.id >= 50 AND p1.id <= 51 AND p1.ctid = '(1,1)' AND p1.id = t1.id AND t1.id < 10;
NOTICE:  SELECT uses system-defined column "p1.ctid" without the necessary companion column "p1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  pg_hint_plan:
used hint:
TidScan(p1)
not used hint:
duplication hint:
error hint:
                              QUERY PLAN                               
-----------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t1.id = p1.id)
         ->  Index Scan using t1_pkey on t1
               Index Cond: ((id < 10) AND (id >= 50) AND (id <= 51))
         ->  Hash
               ->  Tid Scan on p1
                     TID Cond: (ctid = '(1,1)'::tid)
                     Filter: ((id >= 50) AND (id <= 51) AND (id < 10))
 Optimizer: Postgres query optimizer
(10 rows)

SET constraint_exclusion TO on;
LOG:  statement: SET constraint_exclusion TO on;
/*+SeqScan(p1)*/
EXPLAIN (COSTS false) SELECT * FROM ONLY p1, t1 WHERE p1.id >= 50 AND p1.id <= 51 AND p1.ctid = '(1,1)' AND p1.id = t1.id AND t1.id < 10;
LOG:  statement: /*+SeqScan(p1)*/
EXPLAIN (COSTS false) SELECT * FROM ONLY p1, t1 WHERE p1.id >= 50 AND p1.id <= 51 AND p1.ctid = '(1,1)' AND p1.id = t1.id AND t1.id < 10;
NOTICE:  SELECT uses system-defined column "p1.ctid" without the necessary companion column "p1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  pg_hint_plan:
used hint:
not used hint:
SeqScan(p1)
duplication hint:
error hint:
             QUERY PLAN              
-------------------------------------
 Result
   One-Time Filter: false
 Optimizer: Postgres query optimizer
(3 rows)

/*+IndexScan(p1)*/
EXPLAIN (COSTS false) SELECT * FROM ONLY p1, t1 WHERE p1.id >= 50 AND p1.id <= 51 AND p1.ctid = '(1,1)' AND p1.id = t1.id AND t1.id < 10;
LOG:  statement: /*+IndexScan(p1)*/
EXPLAIN (COSTS false) SELECT * FROM ONLY p1, t1 WHERE p1.id >= 50 AND p1.id <= 51 AND p1.ctid = '(1,1)' AND p1.id = t1.id AND t1.id < 10;
NOTICE:  SELECT uses system-defined column "p1.ctid" without the necessary companion column "p1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  pg_hint_plan:
used hint:
not used hint:
IndexScan(p1)
duplication hint:
error hint:
             QUERY PLAN              
-------------------------------------
 Result
   One-Time Filter: false
 Optimizer: Postgres query optimizer
(3 rows)

/*+BitmapScan(p1)*/
EXPLAIN (COSTS false) SELECT * FROM ONLY p1, t1 WHERE p1.id >= 50 AND p1.id <= 51 AND p1.ctid = '(1,1)' AND p1.id = t1.id AND t1.id < 10;
LOG:  statement: /*+BitmapScan(p1)*/
EXPLAIN (COSTS false) SELECT * FROM ONLY p1, t1 WHERE p1.id >= 50 AND p1.id <= 51 AND p1.ctid = '(1,1)' AND p1.id = t1.id AND t1.id < 10;
NOTICE:  SELECT uses system-defined column "p1.ctid" without the necessary companion column "p1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  pg_hint_plan:
used hint:
not used hint:
BitmapScan(p1)
duplication hint:
error hint:
             QUERY PLAN              
-------------------------------------
 Result
   One-Time Filter: false
 Optimizer: Postgres query optimizer
(3 rows)

/*+TidScan(p1)*/
EXPLAIN (COSTS false) SELECT * FROM ONLY p1, t1 WHERE p1.id >= 50 AND p1.id <= 51 AND p1.ctid = '(1,1)' AND p1.id = t1.id AND t1.id < 10;
LOG:  statement: /*+TidScan(p1)*/
EXPLAIN (COSTS false) SELECT * FROM ONLY p1, t1 WHERE p1.id >= 50 AND p1.id <= 51 AND p1.ctid = '(1,1)' AND p1.id = t1.id AND t1.id < 10;
NOTICE:  SELECT uses system-defined column "p1.ctid" without the necessary companion column "p1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  pg_hint_plan:
used hint:
not used hint:
TidScan(p1)
duplication hint:
error hint:
             QUERY PLAN              
-------------------------------------
 Result
   One-Time Filter: false
 Optimizer: Postgres query optimizer
(3 rows)

-- quote test
/*+SeqScan("""t1 )	")IndexScan("t	2 """)HashJoin("""t1 )	"T3"t	2 """)Leading("""t1 )	"T3"t	2 """)Set(application_name"a	a	a""	a	A")*/
EXPLAIN (COSTS false) SELECT * FROM t1 """t1 )	", t2 "t	2 """, t3 "T3" WHERE """t1 )	".id = "t	2 """.id AND """t1 )	".id = "T3".id;
LOG:  statement: /*+SeqScan("""t1 )	")IndexScan("t	2 """)HashJoin("""t1 )	"T3"t	2 """)Leading("""t1 )	"T3"t	2 """)Set(application_name"a	a	a""	a	A")*/
EXPLAIN (COSTS false) SELECT * FROM t1 """t1 )	", t2 "t	2 """, t3 "T3" WHERE """t1 )	".id = "t	2 """.id AND """t1 )	".id = "T3".id;
WARNING:  "work_mem": setting is deprecated, and may be removed in a future release.
WARNING:  "work_mem": setting is deprecated, and may be removed in a future release.
WARNING:  "work_mem": setting is deprecated, and may be removed in a future release.
WARNING:  "work_mem": setting is deprecated, and may be removed in a future release.
LOG:  pg_hint_plan:
used hint:
SeqScan("""t1 )	")
IndexScan("t	2 """)
HashJoin("""t1 )	" T3 "t	2 """)
Leading("""t1 )	" T3 "t	2 """)
Set(application_name "a	a	a""	a	A")
not used hint:
duplication hint:
error hint:
                       QUERY PLAN                        
---------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: ("t  2 """.id = """t1 )      ".id)
         ->  Index Scan using t2_pkey on t2 "t   2 """
         ->  Hash
               ->  Hash Join
                     Hash Cond: ("""t1 ) ".id = "T3".id)
                     ->  Seq Scan on t1 """t1 )  "
                     ->  Hash
                           ->  Seq Scan on t3 "T3"
 Optimizer: Postgres query optimizer
(11 rows)

-- duplicate hint test
/*+SeqScan(t1)SeqScan(t2)IndexScan(t1)IndexScan(t2)BitmapScan(t1)BitmapScan(t2)TidScan(t1)TidScan(t2)HashJoin(t1 t2)NestLoop(t2 t1)MergeJoin(t1 t2)Leading(t1 t2)Leading(t2 t1)Set(enable_seqscan off)Set(enable_mergejoin on)Set(enable_seqscan on)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
LOG:  statement: /*+SeqScan(t1)SeqScan(t2)IndexScan(t1)IndexScan(t2)BitmapScan(t1)BitmapScan(t2)TidScan(t1)TidScan(t2)HashJoin(t1 t2)NestLoop(t2 t1)MergeJoin(t1 t2)Leading(t1 t2)Leading(t2 t1)Set(enable_seqscan off)Set(enable_mergejoin on)Set(enable_seqscan on)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
INFO:  pg_hint_plan: hint syntax error at or near "SeqScan(t1)SeqScan(t2)IndexScan(t1)IndexScan(t2)BitmapScan(t1)BitmapScan(t2)TidScan(t1)TidScan(t2)HashJoin(t1 t2)NestLoop(t2 t1)MergeJoin(t1 t2)Leading(t1 t2)Leading(t2 t1)Set(enable_seqscan off)Set(enable_mergejoin on)Set(enable_seqscan on)"
DETAIL:  Conflict scan method hint.
INFO:  pg_hint_plan: hint syntax error at or near "IndexScan(t1)IndexScan(t2)BitmapScan(t1)BitmapScan(t2)TidScan(t1)TidScan(t2)HashJoin(t1 t2)NestLoop(t2 t1)MergeJoin(t1 t2)Leading(t1 t2)Leading(t2 t1)Set(enable_seqscan off)Set(enable_mergejoin on)Set(enable_seqscan on)"
DETAIL:  Conflict scan method hint.
INFO:  pg_hint_plan: hint syntax error at or near "BitmapScan(t1)BitmapScan(t2)TidScan(t1)TidScan(t2)HashJoin(t1 t2)NestLoop(t2 t1)MergeJoin(t1 t2)Leading(t1 t2)Leading(t2 t1)Set(enable_seqscan off)Set(enable_mergejoin on)Set(enable_seqscan on)"
DETAIL:  Conflict scan method hint.
INFO:  pg_hint_plan: hint syntax error at or near "SeqScan(t2)IndexScan(t1)IndexScan(t2)BitmapScan(t1)BitmapScan(t2)TidScan(t1)TidScan(t2)HashJoin(t1 t2)NestLoop(t2 t1)MergeJoin(t1 t2)Leading(t1 t2)Leading(t2 t1)Set(enable_seqscan off)Set(enable_mergejoin on)Set(enable_seqscan on)"
DETAIL:  Conflict scan method hint.
INFO:  pg_hint_plan: hint syntax error at or near "IndexScan(t2)BitmapScan(t1)BitmapScan(t2)TidScan(t1)TidScan(t2)HashJoin(t1 t2)NestLoop(t2 t1)MergeJoin(t1 t2)Leading(t1 t2)Leading(t2 t1)Set(enable_seqscan off)Set(enable_mergejoin on)Set(enable_seqscan on)"
DETAIL:  Conflict scan method hint.
INFO:  pg_hint_plan: hint syntax error at or near "BitmapScan(t2)TidScan(t1)TidScan(t2)HashJoin(t1 t2)NestLoop(t2 t1)MergeJoin(t1 t2)Leading(t1 t2)Leading(t2 t1)Set(enable_seqscan off)Set(enable_mergejoin on)Set(enable_seqscan on)"
DETAIL:  Conflict scan method hint.
INFO:  pg_hint_plan: hint syntax error at or near "HashJoin(t1 t2)NestLoop(t2 t1)MergeJoin(t1 t2)Leading(t1 t2)Leading(t2 t1)Set(enable_seqscan off)Set(enable_mergejoin on)Set(enable_seqscan on)"
DETAIL:  Conflict join method hint.
INFO:  pg_hint_plan: hint syntax error at or near "NestLoop(t2 t1)MergeJoin(t1 t2)Leading(t1 t2)Leading(t2 t1)Set(enable_seqscan off)Set(enable_mergejoin on)Set(enable_seqscan on)"
DETAIL:  Conflict join method hint.
INFO:  pg_hint_plan: hint syntax error at or near "Set(enable_seqscan off)Set(enable_mergejoin on)Set(enable_seqscan on)"
DETAIL:  Conflict set hint.
NOTICE:  SELECT uses system-defined column "t1.ctid" without the necessary companion column "t1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
NOTICE:  SELECT uses system-defined column "t2.ctid" without the necessary companion column "t2.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
INFO:  pg_hint_plan: hint syntax error at or near "Leading(t1 t2)Leading(t2 t1)Set(enable_seqscan off)Set(enable_mergejoin on)Set(enable_seqscan on)"
DETAIL:  Conflict leading hint.
LOG:  pg_hint_plan:
used hint:
TidScan(t1)
TidScan(t2)
MergeJoin(t1 t2)
Leading(t2 t1)
Set(enable_mergejoin on)
Set(enable_seqscan on)
not used hint:
duplication hint:
SeqScan(t1)
IndexScan(t1)
BitmapScan(t1)
SeqScan(t2)
IndexScan(t2)
BitmapScan(t2)
HashJoin(t1 t2)
NestLoop(t1 t2)
Leading(t1 t2)
Set(enable_seqscan off)
error hint:
                     QUERY PLAN                      
-----------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Merge Join
         Merge Cond: (t1.id = t2.id)
         ->  Sort
               Sort Key: t1.id
               ->  Tid Scan on t1
                     TID Cond: (ctid = '(1,1)'::tid)
         ->  Sort
               Sort Key: t2.id
               ->  Tid Scan on t2
                     TID Cond: (ctid = '(1,1)'::tid)
 Optimizer: Postgres query optimizer
(12 rows)

-- sub query Leading hint test
SET from_collapse_limit TO 100;
LOG:  statement: SET from_collapse_limit TO 100;
SET geqo_threshold TO 100;
LOG:  statement: SET geqo_threshold TO 100;
WARNING:  "geqo_threshold": setting is ignored because it is defunct
EXPLAIN (COSTS false)
WITH c1_1(id) AS (
SELECT max(t1_5.id) FROM t1 t1_5, t2 t2_5, t3 t3_5 WHERE t1_5.id = t2_5.id AND t2_5.id = t3_5.id
)
SELECT t1_1.id, (
SELECT max(t1_2.id) FROM t1 t1_2, t2 t2_2, t3 t3_2 WHERE t1_2.id = t2_2.id AND t2_2.id = t3_2.id
) FROM t1 t1_1, t2 t2_1, t3 t3_1, (
SELECT t1_3.id FROM t1 t1_3, t2 t2_3, t3 t3_3 WHERE t1_3.id = t2_3.id AND t2_3.id = t3_3.id
) v1_1(id), c1_1 WHERE t1_1.id = t2_1.id AND t2_1.id = t3_1.id AND t2_1.id = v1_1.id AND v1_1.id = c1_1.id AND t1_1.id = (
SELECT max(t1_4.id) FROM t1 t1_4, t2 t2_4, t3 t3_4 WHERE t1_4.id = t2_4.id AND t2_4.id = t3_4.id 
);
LOG:  statement: EXPLAIN (COSTS false)
WITH c1_1(id) AS (
SELECT max(t1_5.id) FROM t1 t1_5, t2 t2_5, t3 t3_5 WHERE t1_5.id = t2_5.id AND t2_5.id = t3_5.id
)
SELECT t1_1.id, (
SELECT max(t1_2.id) FROM t1 t1_2, t2 t2_2, t3 t3_2 WHERE t1_2.id = t2_2.id AND t2_2.id = t3_2.id
) FROM t1 t1_1, t2 t2_1, t3 t3_1, (
SELECT t1_3.id FROM t1 t1_3, t2 t2_3, t3 t3_3 WHERE t1_3.id = t2_3.id AND t2_3.id = t3_3.id
) v1_1(id), c1_1 WHERE t1_1.id = t2_1.id AND t2_1.id = t3_1.id AND t2_1.id = v1_1.id AND v1_1.id = c1_1.id AND t1_1.id = (
SELECT max(t1_4.id) FROM t1 t1_4, t2 t2_4, t3 t3_4 WHERE t1_4.id = t2_4.id AND t2_4.id = t3_4.id 
);
                                       QUERY PLAN                                       
----------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   InitPlan 1 (returns $0)  (slice4)
     ->  Finalize Aggregate
           ->  Gather Motion 3:1  (slice5; segments: 3)
                 ->  Partial Aggregate
                       ->  Hash Join
                             Hash Cond: (t1_2.id = t2_2.id)
                             ->  Seq Scan on t1 t1_2
                             ->  Hash
                                   ->  Hash Join
                                         Hash Cond: (t2_2.id = t3_2.id)
                                         ->  Seq Scan on t2 t2_2
                                         ->  Hash
                                               ->  Seq Scan on t3 t3_2
   InitPlan 2 (returns $1)  (slice6)
     ->  Finalize Aggregate
           ->  Gather Motion 3:1  (slice7; segments: 3)
                 ->  Partial Aggregate
                       ->  Hash Join
                             Hash Cond: (t1_4.id = t2_4.id)
                             ->  Seq Scan on t1 t1_4
                             ->  Hash
                                   ->  Hash Join
                                         Hash Cond: (t2_4.id = t3_4.id)
                                         ->  Seq Scan on t2 t2_4
                                         ->  Hash
                                               ->  Seq Scan on t3 t3_4
   ->  Nested Loop
         ->  Nested Loop
               ->  Nested Loop
                     ->  Nested Loop
                           ->  Index Only Scan using t1_pkey on t1 t1_1
                                 Index Cond: (id = $1)
                           ->  Seq Scan on t2 t2_1
                                 Filter: (id = $1)
                     ->  Seq Scan on t3 t3_1
                           Filter: (id = $1)
               ->  Materialize
                     ->  Nested Loop
                           ->  Nested Loop
                                 ->  Index Only Scan using t1_pkey on t1 t1_3
                                       Index Cond: (id = $1)
                                 ->  Seq Scan on t2 t2_3
                                       Filter: (id = $1)
                           ->  Seq Scan on t3 t3_3
                                 Filter: (id = $1)
         ->  Materialize
               ->  Redistribute Motion 1:3  (slice2; segments: 1)
                     Hash Key: (max(t1_5.id))
                     ->  Finalize Aggregate
                           Filter: (max(t1_5.id) = $1)
                           ->  Gather Motion 3:1  (slice3; segments: 3)
                                 ->  Partial Aggregate
                                       ->  Hash Join
                                             Hash Cond: (t1_5.id = t2_5.id)
                                             ->  Seq Scan on t1 t1_5
                                             ->  Hash
                                                   ->  Hash Join
                                                         Hash Cond: (t2_5.id = t3_5.id)
                                                         ->  Seq Scan on t2 t2_5
                                                         ->  Hash
                                                               ->  Seq Scan on t3 t3_5
 Optimizer: Postgres query optimizer
(63 rows)

/*+HashJoin(t1_1 t3_1)MergeJoin(t1_3 t3_3)NestLoop(t1_2 t2_2)NestLoop(t1_4 t2_4)NestLoop(t1_5 t2_5)*/
EXPLAIN (COSTS false)
WITH c1_1(id) AS (
SELECT max(t1_5.id) FROM t1 t1_5, t2 t2_5, t3 t3_5 WHERE t1_5.id = t2_5.id AND t2_5.id = t3_5.id
)
SELECT t1_1.id, (
SELECT max(t1_2.id) FROM t1 t1_2, t2 t2_2, t3 t3_2 WHERE t1_2.id = t2_2.id AND t2_2.id = t3_2.id
) FROM t1 t1_1, t2 t2_1, t3 t3_1, (
SELECT t1_3.id FROM t1 t1_3, t2 t2_3, t3 t3_3 WHERE t1_3.id = t2_3.id AND t2_3.id = t3_3.id
) v1_1(id), c1_1 WHERE t1_1.id = t2_1.id AND t2_1.id = t3_1.id AND t2_1.id = v1_1.id AND v1_1.id = c1_1.id AND t1_1.id = (
SELECT max(t1_4.id) FROM t1 t1_4, t2 t2_4, t3 t3_4 WHERE t1_4.id = t2_4.id AND t2_4.id = t3_4.id 
);
LOG:  statement: /*+HashJoin(t1_1 t3_1)MergeJoin(t1_3 t3_3)NestLoop(t1_2 t2_2)NestLoop(t1_4 t2_4)NestLoop(t1_5 t2_5)*/
EXPLAIN (COSTS false)
WITH c1_1(id) AS (
SELECT max(t1_5.id) FROM t1 t1_5, t2 t2_5, t3 t3_5 WHERE t1_5.id = t2_5.id AND t2_5.id = t3_5.id
)
SELECT t1_1.id, (
SELECT max(t1_2.id) FROM t1 t1_2, t2 t2_2, t3 t3_2 WHERE t1_2.id = t2_2.id AND t2_2.id = t3_2.id
) FROM t1 t1_1, t2 t2_1, t3 t3_1, (
SELECT t1_3.id FROM t1 t1_3, t2 t2_3, t3 t3_3 WHERE t1_3.id = t2_3.id AND t2_3.id = t3_3.id
) v1_1(id), c1_1 WHERE t1_1.id = t2_1.id AND t2_1.id = t3_1.id AND t2_1.id = v1_1.id AND v1_1.id = c1_1.id AND t1_1.id = (
SELECT max(t1_4.id) FROM t1 t1_4, t2 t2_4, t3 t3_4 WHERE t1_4.id = t2_4.id AND t2_4.id = t3_4.id 
);
WARNING:  "work_mem": setting is deprecated, and may be removed in a future release.
LOG:  pg_hint_plan:
used hint:
HashJoin(t1_1 t3_1)
NestLoop(t1_2 t2_2)
MergeJoin(t1_3 t3_3)
NestLoop(t1_4 t2_4)
NestLoop(t1_5 t2_5)
not used hint:
duplication hint:
error hint:
                                       QUERY PLAN                                       
----------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   InitPlan 1 (returns $0)  (slice4)
     ->  Finalize Aggregate
           ->  Gather Motion 3:1  (slice5; segments: 3)
                 ->  Partial Aggregate
                       ->  Hash Join
                             Hash Cond: (t1_2.id = t2_2.id)
                             ->  Seq Scan on t1 t1_2
                             ->  Hash
                                   ->  Hash Join
                                         Hash Cond: (t2_2.id = t3_2.id)
                                         ->  Seq Scan on t2 t2_2
                                         ->  Hash
                                               ->  Seq Scan on t3 t3_2
   InitPlan 2 (returns $1)  (slice6)
     ->  Finalize Aggregate
           ->  Gather Motion 3:1  (slice7; segments: 3)
                 ->  Partial Aggregate
                       ->  Hash Join
                             Hash Cond: (t1_4.id = t2_4.id)
                             ->  Seq Scan on t1 t1_4
                             ->  Hash
                                   ->  Hash Join
                                         Hash Cond: (t2_4.id = t3_4.id)
                                         ->  Seq Scan on t2 t2_4
                                         ->  Hash
                                               ->  Seq Scan on t3 t3_4
   ->  Nested Loop
         ->  Nested Loop
               ->  Nested Loop
                     ->  Nested Loop
                           ->  Index Only Scan using t1_pkey on t1 t1_1
                                 Index Cond: (id = $1)
                           ->  Seq Scan on t2 t2_1
                                 Filter: (id = $1)
                     ->  Seq Scan on t3 t3_1
                           Filter: (id = $1)
               ->  Materialize
                     ->  Nested Loop
                           ->  Nested Loop
                                 ->  Index Only Scan using t1_pkey on t1 t1_3
                                       Index Cond: (id = $1)
                                 ->  Seq Scan on t2 t2_3
                                       Filter: (id = $1)
                           ->  Seq Scan on t3 t3_3
                                 Filter: (id = $1)
         ->  Materialize
               ->  Redistribute Motion 1:3  (slice2; segments: 1)
                     Hash Key: (max(t1_5.id))
                     ->  Finalize Aggregate
                           Filter: (max(t1_5.id) = $1)
                           ->  Gather Motion 3:1  (slice3; segments: 3)
                                 ->  Partial Aggregate
                                       ->  Hash Join
                                             Hash Cond: (t1_5.id = t2_5.id)
                                             ->  Seq Scan on t1 t1_5
                                             ->  Hash
                                                   ->  Hash Join
                                                         Hash Cond: (t2_5.id = t3_5.id)
                                                         ->  Seq Scan on t2 t2_5
                                                         ->  Hash
                                                               ->  Seq Scan on t3 t3_5
 Optimizer: Postgres query optimizer
(63 rows)

/*+HashJoin(t1_1 t3_1)MergeJoin(t1_3 t3_3)NestLoop(t1_2 t2_2)NestLoop(t1_4 t2_4)NestLoop(t1_5 t2_5)Leading(a t1_1 t1_2 t1_4 t1_5)*/
EXPLAIN (COSTS false)
WITH c1_1(id) AS (
SELECT max(t1_5.id) FROM t1 t1_5, t2 t2_5, t3 t3_5 WHERE t1_5.id = t2_5.id AND t2_5.id = t3_5.id
)
SELECT t1_1.id, (
SELECT max(t1_2.id) FROM t1 t1_2, t2 t2_2, t3 t3_2 WHERE t1_2.id = t2_2.id AND t2_2.id = t3_2.id
) FROM t1 t1_1, t2 t2_1, t3 t3_1, (
SELECT t1_3.id FROM t1 t1_3, t2 t2_3, t3 t3_3 WHERE t1_3.id = t2_3.id AND t2_3.id = t3_3.id
) v1_1(id), c1_1 WHERE t1_1.id = t2_1.id AND t2_1.id = t3_1.id AND t2_1.id = v1_1.id AND v1_1.id = c1_1.id AND t1_1.id = (
SELECT max(t1_4.id) FROM t1 t1_4, t2 t2_4, t3 t3_4 WHERE t1_4.id = t2_4.id AND t2_4.id = t3_4.id 
);
LOG:  statement: /*+HashJoin(t1_1 t3_1)MergeJoin(t1_3 t3_3)NestLoop(t1_2 t2_2)NestLoop(t1_4 t2_4)NestLoop(t1_5 t2_5)Leading(a t1_1 t1_2 t1_4 t1_5)*/
EXPLAIN (COSTS false)
WITH c1_1(id) AS (
SELECT max(t1_5.id) FROM t1 t1_5, t2 t2_5, t3 t3_5 WHERE t1_5.id = t2_5.id AND t2_5.id = t3_5.id
)
SELECT t1_1.id, (
SELECT max(t1_2.id) FROM t1 t1_2, t2 t2_2, t3 t3_2 WHERE t1_2.id = t2_2.id AND t2_2.id = t3_2.id
) FROM t1 t1_1, t2 t2_1, t3 t3_1, (
SELECT t1_3.id FROM t1 t1_3, t2 t2_3, t3 t3_3 WHERE t1_3.id = t2_3.id AND t2_3.id = t3_3.id
) v1_1(id), c1_1 WHERE t1_1.id = t2_1.id AND t2_1.id = t3_1.id AND t2_1.id = v1_1.id AND v1_1.id = c1_1.id AND t1_1.id = (
SELECT max(t1_4.id) FROM t1 t1_4, t2 t2_4, t3 t3_4 WHERE t1_4.id = t2_4.id AND t2_4.id = t3_4.id 
);
WARNING:  "work_mem": setting is deprecated, and may be removed in a future release.
LOG:  pg_hint_plan:
used hint:
HashJoin(t1_1 t3_1)
NestLoop(t1_2 t2_2)
MergeJoin(t1_3 t3_3)
NestLoop(t1_4 t2_4)
NestLoop(t1_5 t2_5)
not used hint:
Leading(a t1_1 t1_2 t1_4 t1_5)
duplication hint:
error hint:
                                       QUERY PLAN                                       
----------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   InitPlan 1 (returns $0)  (slice4)
     ->  Finalize Aggregate
           ->  Gather Motion 3:1  (slice5; segments: 3)
                 ->  Partial Aggregate
                       ->  Hash Join
                             Hash Cond: (t1_2.id = t2_2.id)
                             ->  Seq Scan on t1 t1_2
                             ->  Hash
                                   ->  Hash Join
                                         Hash Cond: (t2_2.id = t3_2.id)
                                         ->  Seq Scan on t2 t2_2
                                         ->  Hash
                                               ->  Seq Scan on t3 t3_2
   InitPlan 2 (returns $1)  (slice6)
     ->  Finalize Aggregate
           ->  Gather Motion 3:1  (slice7; segments: 3)
                 ->  Partial Aggregate
                       ->  Hash Join
                             Hash Cond: (t1_4.id = t2_4.id)
                             ->  Seq Scan on t1 t1_4
                             ->  Hash
                                   ->  Hash Join
                                         Hash Cond: (t2_4.id = t3_4.id)
                                         ->  Seq Scan on t2 t2_4
                                         ->  Hash
                                               ->  Seq Scan on t3 t3_4
   ->  Nested Loop
         ->  Nested Loop
               ->  Nested Loop
                     ->  Nested Loop
                           ->  Index Only Scan using t1_pkey on t1 t1_1
                                 Index Cond: (id = $1)
                           ->  Seq Scan on t2 t2_1
                                 Filter: (id = $1)
                     ->  Seq Scan on t3 t3_1
                           Filter: (id = $1)
               ->  Materialize
                     ->  Nested Loop
                           ->  Nested Loop
                                 ->  Index Only Scan using t1_pkey on t1 t1_3
                                       Index Cond: (id = $1)
                                 ->  Seq Scan on t2 t2_3
                                       Filter: (id = $1)
                           ->  Seq Scan on t3 t3_3
                                 Filter: (id = $1)
         ->  Materialize
               ->  Redistribute Motion 1:3  (slice2; segments: 1)
                     Hash Key: (max(t1_5.id))
                     ->  Finalize Aggregate
                           Filter: (max(t1_5.id) = $1)
                           ->  Gather Motion 3:1  (slice3; segments: 3)
                                 ->  Partial Aggregate
                                       ->  Hash Join
                                             Hash Cond: (t1_5.id = t2_5.id)
                                             ->  Seq Scan on t1 t1_5
                                             ->  Hash
                                                   ->  Hash Join
                                                         Hash Cond: (t2_5.id = t3_5.id)
                                                         ->  Seq Scan on t2 t2_5
                                                         ->  Hash
                                                               ->  Seq Scan on t3 t3_5
 Optimizer: Postgres query optimizer
(63 rows)

/*+HashJoin(t1_1 t3_1)MergeJoin(t1_3 t3_3)NestLoop(t1_2 t2_2)NestLoop(t1_4 t2_4)NestLoop(t1_5 t2_5)Leading(a t3_2 t3_5 t2_2 c1_1 t3_4 t3_3 t2_3 t2_4 t1_3 t2_5 t1_2 t3_1 t1_4 t2_1 t1_5 t1_1)*/
EXPLAIN (COSTS false)
WITH c1_1(id) AS (
SELECT max(t1_5.id) FROM t1 t1_5, t2 t2_5, t3 t3_5 WHERE t1_5.id = t2_5.id AND t2_5.id = t3_5.id
)
SELECT t1_1.id, (
SELECT max(t1_2.id) FROM t1 t1_2, t2 t2_2, t3 t3_2 WHERE t1_2.id = t2_2.id AND t2_2.id = t3_2.id
) FROM t1 t1_1, t2 t2_1, t3 t3_1, (
SELECT t1_3.id FROM t1 t1_3, t2 t2_3, t3 t3_3 WHERE t1_3.id = t2_3.id AND t2_3.id = t3_3.id
) v1_1(id), c1_1 WHERE t1_1.id = t2_1.id AND t2_1.id = t3_1.id AND t2_1.id = v1_1.id AND v1_1.id = c1_1.id AND t1_1.id = (
SELECT max(t1_4.id) FROM t1 t1_4, t2 t2_4, t3 t3_4 WHERE t1_4.id = t2_4.id AND t2_4.id = t3_4.id 
);
LOG:  statement: /*+HashJoin(t1_1 t3_1)MergeJoin(t1_3 t3_3)NestLoop(t1_2 t2_2)NestLoop(t1_4 t2_4)NestLoop(t1_5 t2_5)Leading(a t3_2 t3_5 t2_2 c1_1 t3_4 t3_3 t2_3 t2_4 t1_3 t2_5 t1_2 t3_1 t1_4 t2_1 t1_5 t1_1)*/
EXPLAIN (COSTS false)
WITH c1_1(id) AS (
SELECT max(t1_5.id) FROM t1 t1_5, t2 t2_5, t3 t3_5 WHERE t1_5.id = t2_5.id AND t2_5.id = t3_5.id
)
SELECT t1_1.id, (
SELECT max(t1_2.id) FROM t1 t1_2, t2 t2_2, t3 t3_2 WHERE t1_2.id = t2_2.id AND t2_2.id = t3_2.id
) FROM t1 t1_1, t2 t2_1, t3 t3_1, (
SELECT t1_3.id FROM t1 t1_3, t2 t2_3, t3 t3_3 WHERE t1_3.id = t2_3.id AND t2_3.id = t3_3.id
) v1_1(id), c1_1 WHERE t1_1.id = t2_1.id AND t2_1.id = t3_1.id AND t2_1.id = v1_1.id AND v1_1.id = c1_1.id AND t1_1.id = (
SELECT max(t1_4.id) FROM t1 t1_4, t2 t2_4, t3 t3_4 WHERE t1_4.id = t2_4.id AND t2_4.id = t3_4.id 
);
WARNING:  "work_mem": setting is deprecated, and may be removed in a future release.
LOG:  pg_hint_plan:
used hint:
HashJoin(t1_1 t3_1)
NestLoop(t1_2 t2_2)
MergeJoin(t1_3 t3_3)
NestLoop(t1_4 t2_4)
NestLoop(t1_5 t2_5)
not used hint:
Leading(a t3_2 t3_5 t2_2 c1_1 t3_4 t3_3 t2_3 t2_4 t1_3 t2_5 t1_2 t3_1 t1_4 t2_1 t1_5 t1_1)
duplication hint:
error hint:
                                       QUERY PLAN                                       
----------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   InitPlan 1 (returns $0)  (slice4)
     ->  Finalize Aggregate
           ->  Gather Motion 3:1  (slice5; segments: 3)
                 ->  Partial Aggregate
                       ->  Hash Join
                             Hash Cond: (t1_2.id = t2_2.id)
                             ->  Seq Scan on t1 t1_2
                             ->  Hash
                                   ->  Hash Join
                                         Hash Cond: (t2_2.id = t3_2.id)
                                         ->  Seq Scan on t2 t2_2
                                         ->  Hash
                                               ->  Seq Scan on t3 t3_2
   InitPlan 2 (returns $1)  (slice6)
     ->  Finalize Aggregate
           ->  Gather Motion 3:1  (slice7; segments: 3)
                 ->  Partial Aggregate
                       ->  Hash Join
                             Hash Cond: (t1_4.id = t2_4.id)
                             ->  Seq Scan on t1 t1_4
                             ->  Hash
                                   ->  Hash Join
                                         Hash Cond: (t2_4.id = t3_4.id)
                                         ->  Seq Scan on t2 t2_4
                                         ->  Hash
                                               ->  Seq Scan on t3 t3_4
   ->  Nested Loop
         ->  Nested Loop
               ->  Nested Loop
                     ->  Nested Loop
                           ->  Index Only Scan using t1_pkey on t1 t1_1
                                 Index Cond: (id = $1)
                           ->  Seq Scan on t2 t2_1
                                 Filter: (id = $1)
                     ->  Seq Scan on t3 t3_1
                           Filter: (id = $1)
               ->  Materialize
                     ->  Nested Loop
                           ->  Nested Loop
                                 ->  Index Only Scan using t1_pkey on t1 t1_3
                                       Index Cond: (id = $1)
                                 ->  Seq Scan on t2 t2_3
                                       Filter: (id = $1)
                           ->  Seq Scan on t3 t3_3
                                 Filter: (id = $1)
         ->  Materialize
               ->  Redistribute Motion 1:3  (slice2; segments: 1)
                     Hash Key: (max(t1_5.id))
                     ->  Finalize Aggregate
                           Filter: (max(t1_5.id) = $1)
                           ->  Gather Motion 3:1  (slice3; segments: 3)
                                 ->  Partial Aggregate
                                       ->  Hash Join
                                             Hash Cond: (t1_5.id = t2_5.id)
                                             ->  Seq Scan on t1 t1_5
                                             ->  Hash
                                                   ->  Hash Join
                                                         Hash Cond: (t2_5.id = t3_5.id)
                                                         ->  Seq Scan on t2 t2_5
                                                         ->  Hash
                                                               ->  Seq Scan on t3 t3_5
 Optimizer: Postgres query optimizer
(63 rows)

/*+HashJoin(t1_1 t3_1)MergeJoin(t1_3 t3_3)NestLoop(t1_2 t2_2)NestLoop(t1_4 t2_4)NestLoop(t1_5 t2_5)Leading(t3_5 t2_5 t1_5)Leading(t3_2 t2_2 t1_2)Leading(t3_4 t2_4 t1_4)Leading(c1_1 t3_3 t2_3 t1_3 t3_1 t2_1 t1_1)*/
EXPLAIN (COSTS false)
WITH c1_1(id) AS (
SELECT max(t1_5.id) FROM t1 t1_5, t2 t2_5, t3 t3_5 WHERE t1_5.id = t2_5.id AND t2_5.id = t3_5.id
)
SELECT t1_1.id, (
SELECT max(t1_2.id) FROM t1 t1_2, t2 t2_2, t3 t3_2 WHERE t1_2.id = t2_2.id AND t2_2.id = t3_2.id
) FROM t1 t1_1, t2 t2_1, t3 t3_1, (
SELECT t1_3.id FROM t1 t1_3, t2 t2_3, t3 t3_3 WHERE t1_3.id = t2_3.id AND t2_3.id = t3_3.id
) v1_1(id), c1_1 WHERE t1_1.id = t2_1.id AND t2_1.id = t3_1.id AND t2_1.id = v1_1.id AND v1_1.id = c1_1.id AND t1_1.id = (
SELECT max(t1_4.id) FROM t1 t1_4, t2 t2_4, t3 t3_4 WHERE t1_4.id = t2_4.id AND t2_4.id = t3_4.id 
);
LOG:  statement: /*+HashJoin(t1_1 t3_1)MergeJoin(t1_3 t3_3)NestLoop(t1_2 t2_2)NestLoop(t1_4 t2_4)NestLoop(t1_5 t2_5)Leading(t3_5 t2_5 t1_5)Leading(t3_2 t2_2 t1_2)Leading(t3_4 t2_4 t1_4)Leading(c1_1 t3_3 t2_3 t1_3 t3_1 t2_1 t1_1)*/
EXPLAIN (COSTS false)
WITH c1_1(id) AS (
SELECT max(t1_5.id) FROM t1 t1_5, t2 t2_5, t3 t3_5 WHERE t1_5.id = t2_5.id AND t2_5.id = t3_5.id
)
SELECT t1_1.id, (
SELECT max(t1_2.id) FROM t1 t1_2, t2 t2_2, t3 t3_2 WHERE t1_2.id = t2_2.id AND t2_2.id = t3_2.id
) FROM t1 t1_1, t2 t2_1, t3 t3_1, (
SELECT t1_3.id FROM t1 t1_3, t2 t2_3, t3 t3_3 WHERE t1_3.id = t2_3.id AND t2_3.id = t3_3.id
) v1_1(id), c1_1 WHERE t1_1.id = t2_1.id AND t2_1.id = t3_1.id AND t2_1.id = v1_1.id AND v1_1.id = c1_1.id AND t1_1.id = (
SELECT max(t1_4.id) FROM t1 t1_4, t2 t2_4, t3 t3_4 WHERE t1_4.id = t2_4.id AND t2_4.id = t3_4.id 
);
WARNING:  "work_mem": setting is deprecated, and may be removed in a future release.
LOG:  pg_hint_plan:
used hint:
HashJoin(t1_1 t3_1)
MergeJoin(t1_3 t3_3)
Leading(t3_5 t2_5 t1_5)
Leading(t3_2 t2_2 t1_2)
Leading(t3_4 t2_4 t1_4)
not used hint:
NestLoop(t1_2 t2_2)
NestLoop(t1_4 t2_4)
NestLoop(t1_5 t2_5)
Leading(c1_1 t3_3 t2_3 t1_3 t3_1 t2_1 t1_1)
duplication hint:
error hint:
                                       QUERY PLAN                                       
----------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   InitPlan 1 (returns $0)  (slice4)
     ->  Finalize Aggregate
           ->  Gather Motion 3:1  (slice5; segments: 3)
                 ->  Partial Aggregate
                       ->  Hash Join
                             Hash Cond: (t1_2.id = t2_2.id)
                             ->  Seq Scan on t1 t1_2
                             ->  Hash
                                   ->  Hash Join
                                         Hash Cond: (t2_2.id = t3_2.id)
                                         ->  Seq Scan on t2 t2_2
                                         ->  Hash
                                               ->  Seq Scan on t3 t3_2
   InitPlan 2 (returns $1)  (slice6)
     ->  Finalize Aggregate
           ->  Gather Motion 3:1  (slice7; segments: 3)
                 ->  Partial Aggregate
                       ->  Hash Join
                             Hash Cond: (t1_4.id = t2_4.id)
                             ->  Seq Scan on t1 t1_4
                             ->  Hash
                                   ->  Hash Join
                                         Hash Cond: (t2_4.id = t3_4.id)
                                         ->  Seq Scan on t2 t2_4
                                         ->  Hash
                                               ->  Seq Scan on t3 t3_4
   ->  Nested Loop
         ->  Nested Loop
               ->  Nested Loop
                     ->  Nested Loop
                           ->  Index Only Scan using t1_pkey on t1 t1_1
                                 Index Cond: (id = $1)
                           ->  Seq Scan on t2 t2_1
                                 Filter: (id = $1)
                     ->  Seq Scan on t3 t3_1
                           Filter: (id = $1)
               ->  Materialize
                     ->  Nested Loop
                           ->  Nested Loop
                                 ->  Index Only Scan using t1_pkey on t1 t1_3
                                       Index Cond: (id = $1)
                                 ->  Seq Scan on t2 t2_3
                                       Filter: (id = $1)
                           ->  Seq Scan on t3 t3_3
                                 Filter: (id = $1)
         ->  Materialize
               ->  Redistribute Motion 1:3  (slice2; segments: 1)
                     Hash Key: (max(t1_5.id))
                     ->  Finalize Aggregate
                           Filter: (max(t1_5.id) = $1)
                           ->  Gather Motion 3:1  (slice3; segments: 3)
                                 ->  Partial Aggregate
                                       ->  Hash Join
                                             Hash Cond: (t1_5.id = t2_5.id)
                                             ->  Seq Scan on t1 t1_5
                                             ->  Hash
                                                   ->  Hash Join
                                                         Hash Cond: (t2_5.id = t3_5.id)
                                                         ->  Seq Scan on t2 t2_5
                                                         ->  Hash
                                                               ->  Seq Scan on t3 t3_5
 Optimizer: Postgres query optimizer
(63 rows)

SET from_collapse_limit TO 1;
LOG:  statement: SET from_collapse_limit TO 1;
EXPLAIN (COSTS false)
WITH c1_1(id) AS (
SELECT max(t1_5.id) FROM t1 t1_5, t2 t2_5, t3 t3_5 WHERE t1_5.id = t2_5.id AND t2_5.id = t3_5.id
)
SELECT t1_1.id, (
SELECT max(t1_2.id) FROM t1 t1_2, t2 t2_2, t3 t3_2 WHERE t1_2.id = t2_2.id AND t2_2.id = t3_2.id
) FROM t1 t1_1, t2 t2_1, t3 t3_1, (
SELECT t1_3.id FROM t1 t1_3, t2 t2_3, t3 t3_3 WHERE t1_3.id = t2_3.id AND t2_3.id = t3_3.id
) v1_1(id), c1_1 WHERE t1_1.id = t2_1.id AND t2_1.id = t3_1.id AND t2_1.id = v1_1.id AND v1_1.id = c1_1.id AND t1_1.id = (
SELECT max(t1_4.id) FROM t1 t1_4, t2 t2_4, t3 t3_4 WHERE t1_4.id = t2_4.id AND t2_4.id = t3_4.id 
);
LOG:  statement: EXPLAIN (COSTS false)
WITH c1_1(id) AS (
SELECT max(t1_5.id) FROM t1 t1_5, t2 t2_5, t3 t3_5 WHERE t1_5.id = t2_5.id AND t2_5.id = t3_5.id
)
SELECT t1_1.id, (
SELECT max(t1_2.id) FROM t1 t1_2, t2 t2_2, t3 t3_2 WHERE t1_2.id = t2_2.id AND t2_2.id = t3_2.id
) FROM t1 t1_1, t2 t2_1, t3 t3_1, (
SELECT t1_3.id FROM t1 t1_3, t2 t2_3, t3 t3_3 WHERE t1_3.id = t2_3.id AND t2_3.id = t3_3.id
) v1_1(id), c1_1 WHERE t1_1.id = t2_1.id AND t2_1.id = t3_1.id AND t2_1.id = v1_1.id AND v1_1.id = c1_1.id AND t1_1.id = (
SELECT max(t1_4.id) FROM t1 t1_4, t2 t2_4, t3 t3_4 WHERE t1_4.id = t2_4.id AND t2_4.id = t3_4.id 
);
                                       QUERY PLAN                                       
----------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   InitPlan 1 (returns $0)  (slice4)
     ->  Finalize Aggregate
           ->  Gather Motion 3:1  (slice5; segments: 3)
                 ->  Partial Aggregate
                       ->  Hash Join
                             Hash Cond: (t1_2.id = t2_2.id)
                             ->  Seq Scan on t1 t1_2
                             ->  Hash
                                   ->  Hash Join
                                         Hash Cond: (t2_2.id = t3_2.id)
                                         ->  Seq Scan on t2 t2_2
                                         ->  Hash
                                               ->  Seq Scan on t3 t3_2
   InitPlan 2 (returns $1)  (slice6)
     ->  Finalize Aggregate
           ->  Gather Motion 3:1  (slice7; segments: 3)
                 ->  Partial Aggregate
                       ->  Hash Join
                             Hash Cond: (t1_4.id = t2_4.id)
                             ->  Seq Scan on t1 t1_4
                             ->  Hash
                                   ->  Hash Join
                                         Hash Cond: (t2_4.id = t3_4.id)
                                         ->  Seq Scan on t2 t2_4
                                         ->  Hash
                                               ->  Seq Scan on t3 t3_4
   ->  Nested Loop
         ->  Nested Loop
               ->  Nested Loop
                     ->  Nested Loop
                           ->  Index Only Scan using t1_pkey on t1 t1_1
                                 Index Cond: (id = $1)
                           ->  Seq Scan on t2 t2_1
                                 Filter: (id = $1)
                     ->  Seq Scan on t3 t3_1
                           Filter: (id = $1)
               ->  Materialize
                     ->  Nested Loop
                           ->  Nested Loop
                                 ->  Index Only Scan using t1_pkey on t1 t1_3
                                       Index Cond: (id = $1)
                                 ->  Seq Scan on t2 t2_3
                                       Filter: (id = $1)
                           ->  Seq Scan on t3 t3_3
                                 Filter: (id = $1)
         ->  Materialize
               ->  Redistribute Motion 1:3  (slice2; segments: 1)
                     Hash Key: (max(t1_5.id))
                     ->  Finalize Aggregate
                           Filter: (max(t1_5.id) = $1)
                           ->  Gather Motion 3:1  (slice3; segments: 3)
                                 ->  Partial Aggregate
                                       ->  Hash Join
                                             Hash Cond: (t1_5.id = t2_5.id)
                                             ->  Seq Scan on t1 t1_5
                                             ->  Hash
                                                   ->  Hash Join
                                                         Hash Cond: (t2_5.id = t3_5.id)
                                                         ->  Seq Scan on t2 t2_5
                                                         ->  Hash
                                                               ->  Seq Scan on t3 t3_5
 Optimizer: Postgres query optimizer
(63 rows)

/*+HashJoin(t1_1 t3_1)MergeJoin(t1_3 t3_3)NestLoop(t1_2 t2_2)NestLoop(t1_4 t2_4)NestLoop(t1_5 t2_5)*/
EXPLAIN (COSTS false)
WITH c1_1(id) AS (
SELECT max(t1_5.id) FROM t1 t1_5, t2 t2_5, t3 t3_5 WHERE t1_5.id = t2_5.id AND t2_5.id = t3_5.id
)
SELECT t1_1.id, (
SELECT max(t1_2.id) FROM t1 t1_2, t2 t2_2, t3 t3_2 WHERE t1_2.id = t2_2.id AND t2_2.id = t3_2.id
) FROM t1 t1_1, t2 t2_1, t3 t3_1, (
SELECT t1_3.id FROM t1 t1_3, t2 t2_3, t3 t3_3 WHERE t1_3.id = t2_3.id AND t2_3.id = t3_3.id
) v1_1(id), c1_1 WHERE t1_1.id = t2_1.id AND t2_1.id = t3_1.id AND t2_1.id = v1_1.id AND v1_1.id = c1_1.id AND t1_1.id = (
SELECT max(t1_4.id) FROM t1 t1_4, t2 t2_4, t3 t3_4 WHERE t1_4.id = t2_4.id AND t2_4.id = t3_4.id 
);
LOG:  statement: /*+HashJoin(t1_1 t3_1)MergeJoin(t1_3 t3_3)NestLoop(t1_2 t2_2)NestLoop(t1_4 t2_4)NestLoop(t1_5 t2_5)*/
EXPLAIN (COSTS false)
WITH c1_1(id) AS (
SELECT max(t1_5.id) FROM t1 t1_5, t2 t2_5, t3 t3_5 WHERE t1_5.id = t2_5.id AND t2_5.id = t3_5.id
)
SELECT t1_1.id, (
SELECT max(t1_2.id) FROM t1 t1_2, t2 t2_2, t3 t3_2 WHERE t1_2.id = t2_2.id AND t2_2.id = t3_2.id
) FROM t1 t1_1, t2 t2_1, t3 t3_1, (
SELECT t1_3.id FROM t1 t1_3, t2 t2_3, t3 t3_3 WHERE t1_3.id = t2_3.id AND t2_3.id = t3_3.id
) v1_1(id), c1_1 WHERE t1_1.id = t2_1.id AND t2_1.id = t3_1.id AND t2_1.id = v1_1.id AND v1_1.id = c1_1.id AND t1_1.id = (
SELECT max(t1_4.id) FROM t1 t1_4, t2 t2_4, t3 t3_4 WHERE t1_4.id = t2_4.id AND t2_4.id = t3_4.id 
);
WARNING:  "work_mem": setting is deprecated, and may be removed in a future release.
LOG:  pg_hint_plan:
used hint:
HashJoin(t1_1 t3_1)
NestLoop(t1_2 t2_2)
MergeJoin(t1_3 t3_3)
NestLoop(t1_4 t2_4)
NestLoop(t1_5 t2_5)
not used hint:
duplication hint:
error hint:
                                       QUERY PLAN                                       
----------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   InitPlan 1 (returns $0)  (slice4)
     ->  Finalize Aggregate
           ->  Gather Motion 3:1  (slice5; segments: 3)
                 ->  Partial Aggregate
                       ->  Hash Join
                             Hash Cond: (t1_2.id = t2_2.id)
                             ->  Seq Scan on t1 t1_2
                             ->  Hash
                                   ->  Hash Join
                                         Hash Cond: (t2_2.id = t3_2.id)
                                         ->  Seq Scan on t2 t2_2
                                         ->  Hash
                                               ->  Seq Scan on t3 t3_2
   InitPlan 2 (returns $1)  (slice6)
     ->  Finalize Aggregate
           ->  Gather Motion 3:1  (slice7; segments: 3)
                 ->  Partial Aggregate
                       ->  Hash Join
                             Hash Cond: (t1_4.id = t2_4.id)
                             ->  Seq Scan on t1 t1_4
                             ->  Hash
                                   ->  Hash Join
                                         Hash Cond: (t2_4.id = t3_4.id)
                                         ->  Seq Scan on t2 t2_4
                                         ->  Hash
                                               ->  Seq Scan on t3 t3_4
   ->  Nested Loop
         ->  Nested Loop
               ->  Nested Loop
                     ->  Nested Loop
                           ->  Index Only Scan using t1_pkey on t1 t1_1
                                 Index Cond: (id = $1)
                           ->  Seq Scan on t2 t2_1
                                 Filter: (id = $1)
                     ->  Seq Scan on t3 t3_1
                           Filter: (id = $1)
               ->  Materialize
                     ->  Nested Loop
                           ->  Nested Loop
                                 ->  Index Only Scan using t1_pkey on t1 t1_3
                                       Index Cond: (id = $1)
                                 ->  Seq Scan on t2 t2_3
                                       Filter: (id = $1)
                           ->  Seq Scan on t3 t3_3
                                 Filter: (id = $1)
         ->  Materialize
               ->  Redistribute Motion 1:3  (slice2; segments: 1)
                     Hash Key: (max(t1_5.id))
                     ->  Finalize Aggregate
                           Filter: (max(t1_5.id) = $1)
                           ->  Gather Motion 3:1  (slice3; segments: 3)
                                 ->  Partial Aggregate
                                       ->  Hash Join
                                             Hash Cond: (t1_5.id = t2_5.id)
                                             ->  Seq Scan on t1 t1_5
                                             ->  Hash
                                                   ->  Hash Join
                                                         Hash Cond: (t2_5.id = t3_5.id)
                                                         ->  Seq Scan on t2 t2_5
                                                         ->  Hash
                                                               ->  Seq Scan on t3 t3_5
 Optimizer: Postgres query optimizer
(63 rows)

/*+HashJoin(t1_1 t3_1)MergeJoin(t1_3 t3_3)NestLoop(t1_2 t2_2)NestLoop(t1_4 t2_4)NestLoop(t1_5 t2_5)Leading(a t1_1 t1_2 t1_4 t1_5)*/
EXPLAIN (COSTS false)
WITH c1_1(id) AS (
SELECT max(t1_5.id) FROM t1 t1_5, t2 t2_5, t3 t3_5 WHERE t1_5.id = t2_5.id AND t2_5.id = t3_5.id
)
SELECT t1_1.id, (
SELECT max(t1_2.id) FROM t1 t1_2, t2 t2_2, t3 t3_2 WHERE t1_2.id = t2_2.id AND t2_2.id = t3_2.id
) FROM t1 t1_1, t2 t2_1, t3 t3_1, (
SELECT t1_3.id FROM t1 t1_3, t2 t2_3, t3 t3_3 WHERE t1_3.id = t2_3.id AND t2_3.id = t3_3.id
) v1_1(id), c1_1 WHERE t1_1.id = t2_1.id AND t2_1.id = t3_1.id AND t2_1.id = v1_1.id AND v1_1.id = c1_1.id AND t1_1.id = (
SELECT max(t1_4.id) FROM t1 t1_4, t2 t2_4, t3 t3_4 WHERE t1_4.id = t2_4.id AND t2_4.id = t3_4.id 
);
LOG:  statement: /*+HashJoin(t1_1 t3_1)MergeJoin(t1_3 t3_3)NestLoop(t1_2 t2_2)NestLoop(t1_4 t2_4)NestLoop(t1_5 t2_5)Leading(a t1_1 t1_2 t1_4 t1_5)*/
EXPLAIN (COSTS false)
WITH c1_1(id) AS (
SELECT max(t1_5.id) FROM t1 t1_5, t2 t2_5, t3 t3_5 WHERE t1_5.id = t2_5.id AND t2_5.id = t3_5.id
)
SELECT t1_1.id, (
SELECT max(t1_2.id) FROM t1 t1_2, t2 t2_2, t3 t3_2 WHERE t1_2.id = t2_2.id AND t2_2.id = t3_2.id
) FROM t1 t1_1, t2 t2_1, t3 t3_1, (
SELECT t1_3.id FROM t1 t1_3, t2 t2_3, t3 t3_3 WHERE t1_3.id = t2_3.id AND t2_3.id = t3_3.id
) v1_1(id), c1_1 WHERE t1_1.id = t2_1.id AND t2_1.id = t3_1.id AND t2_1.id = v1_1.id AND v1_1.id = c1_1.id AND t1_1.id = (
SELECT max(t1_4.id) FROM t1 t1_4, t2 t2_4, t3 t3_4 WHERE t1_4.id = t2_4.id AND t2_4.id = t3_4.id 
);
WARNING:  "work_mem": setting is deprecated, and may be removed in a future release.
LOG:  pg_hint_plan:
used hint:
HashJoin(t1_1 t3_1)
NestLoop(t1_2 t2_2)
MergeJoin(t1_3 t3_3)
NestLoop(t1_4 t2_4)
NestLoop(t1_5 t2_5)
not used hint:
Leading(a t1_1 t1_2 t1_4 t1_5)
duplication hint:
error hint:
                                       QUERY PLAN                                       
----------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   InitPlan 1 (returns $0)  (slice4)
     ->  Finalize Aggregate
           ->  Gather Motion 3:1  (slice5; segments: 3)
                 ->  Partial Aggregate
                       ->  Hash Join
                             Hash Cond: (t1_2.id = t2_2.id)
                             ->  Seq Scan on t1 t1_2
                             ->  Hash
                                   ->  Hash Join
                                         Hash Cond: (t2_2.id = t3_2.id)
                                         ->  Seq Scan on t2 t2_2
                                         ->  Hash
                                               ->  Seq Scan on t3 t3_2
   InitPlan 2 (returns $1)  (slice6)
     ->  Finalize Aggregate
           ->  Gather Motion 3:1  (slice7; segments: 3)
                 ->  Partial Aggregate
                       ->  Hash Join
                             Hash Cond: (t1_4.id = t2_4.id)
                             ->  Seq Scan on t1 t1_4
                             ->  Hash
                                   ->  Hash Join
                                         Hash Cond: (t2_4.id = t3_4.id)
                                         ->  Seq Scan on t2 t2_4
                                         ->  Hash
                                               ->  Seq Scan on t3 t3_4
   ->  Nested Loop
         ->  Nested Loop
               ->  Nested Loop
                     ->  Nested Loop
                           ->  Index Only Scan using t1_pkey on t1 t1_1
                                 Index Cond: (id = $1)
                           ->  Seq Scan on t2 t2_1
                                 Filter: (id = $1)
                     ->  Seq Scan on t3 t3_1
                           Filter: (id = $1)
               ->  Materialize
                     ->  Nested Loop
                           ->  Nested Loop
                                 ->  Index Only Scan using t1_pkey on t1 t1_3
                                       Index Cond: (id = $1)
                                 ->  Seq Scan on t2 t2_3
                                       Filter: (id = $1)
                           ->  Seq Scan on t3 t3_3
                                 Filter: (id = $1)
         ->  Materialize
               ->  Redistribute Motion 1:3  (slice2; segments: 1)
                     Hash Key: (max(t1_5.id))
                     ->  Finalize Aggregate
                           Filter: (max(t1_5.id) = $1)
                           ->  Gather Motion 3:1  (slice3; segments: 3)
                                 ->  Partial Aggregate
                                       ->  Hash Join
                                             Hash Cond: (t1_5.id = t2_5.id)
                                             ->  Seq Scan on t1 t1_5
                                             ->  Hash
                                                   ->  Hash Join
                                                         Hash Cond: (t2_5.id = t3_5.id)
                                                         ->  Seq Scan on t2 t2_5
                                                         ->  Hash
                                                               ->  Seq Scan on t3 t3_5
 Optimizer: Postgres query optimizer
(63 rows)

/*+HashJoin(t1_1 t3_1)MergeJoin(t1_3 t3_3)NestLoop(t1_2 t2_2)NestLoop(t1_4 t2_4)NestLoop(t1_5 t2_5)Leading(a t3_2 t3_5 t2_2 c1_1 t3_4 t3_3 t2_3 t2_4 t1_3 t2_5 t1_2 t3_1 t1_4 t2_1 t1_5 t1_1)*/
EXPLAIN (COSTS false)
WITH c1_1(id) AS (
SELECT max(t1_5.id) FROM t1 t1_5, t2 t2_5, t3 t3_5 WHERE t1_5.id = t2_5.id AND t2_5.id = t3_5.id
)
SELECT t1_1.id, (
SELECT max(t1_2.id) FROM t1 t1_2, t2 t2_2, t3 t3_2 WHERE t1_2.id = t2_2.id AND t2_2.id = t3_2.id
) FROM t1 t1_1, t2 t2_1, t3 t3_1, (
SELECT t1_3.id FROM t1 t1_3, t2 t2_3, t3 t3_3 WHERE t1_3.id = t2_3.id AND t2_3.id = t3_3.id
) v1_1(id), c1_1 WHERE t1_1.id = t2_1.id AND t2_1.id = t3_1.id AND t2_1.id = v1_1.id AND v1_1.id = c1_1.id AND t1_1.id = (
SELECT max(t1_4.id) FROM t1 t1_4, t2 t2_4, t3 t3_4 WHERE t1_4.id = t2_4.id AND t2_4.id = t3_4.id 
);
LOG:  statement: /*+HashJoin(t1_1 t3_1)MergeJoin(t1_3 t3_3)NestLoop(t1_2 t2_2)NestLoop(t1_4 t2_4)NestLoop(t1_5 t2_5)Leading(a t3_2 t3_5 t2_2 c1_1 t3_4 t3_3 t2_3 t2_4 t1_3 t2_5 t1_2 t3_1 t1_4 t2_1 t1_5 t1_1)*/
EXPLAIN (COSTS false)
WITH c1_1(id) AS (
SELECT max(t1_5.id) FROM t1 t1_5, t2 t2_5, t3 t3_5 WHERE t1_5.id = t2_5.id AND t2_5.id = t3_5.id
)
SELECT t1_1.id, (
SELECT max(t1_2.id) FROM t1 t1_2, t2 t2_2, t3 t3_2 WHERE t1_2.id = t2_2.id AND t2_2.id = t3_2.id
) FROM t1 t1_1, t2 t2_1, t3 t3_1, (
SELECT t1_3.id FROM t1 t1_3, t2 t2_3, t3 t3_3 WHERE t1_3.id = t2_3.id AND t2_3.id = t3_3.id
) v1_1(id), c1_1 WHERE t1_1.id = t2_1.id AND t2_1.id = t3_1.id AND t2_1.id = v1_1.id AND v1_1.id = c1_1.id AND t1_1.id = (
SELECT max(t1_4.id) FROM t1 t1_4, t2 t2_4, t3 t3_4 WHERE t1_4.id = t2_4.id AND t2_4.id = t3_4.id 
);
WARNING:  "work_mem": setting is deprecated, and may be removed in a future release.
LOG:  pg_hint_plan:
used hint:
HashJoin(t1_1 t3_1)
NestLoop(t1_2 t2_2)
MergeJoin(t1_3 t3_3)
NestLoop(t1_4 t2_4)
NestLoop(t1_5 t2_5)
not used hint:
Leading(a t3_2 t3_5 t2_2 c1_1 t3_4 t3_3 t2_3 t2_4 t1_3 t2_5 t1_2 t3_1 t1_4 t2_1 t1_5 t1_1)
duplication hint:
error hint:
                                       QUERY PLAN                                       
----------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   InitPlan 1 (returns $0)  (slice4)
     ->  Finalize Aggregate
           ->  Gather Motion 3:1  (slice5; segments: 3)
                 ->  Partial Aggregate
                       ->  Hash Join
                             Hash Cond: (t1_2.id = t2_2.id)
                             ->  Seq Scan on t1 t1_2
                             ->  Hash
                                   ->  Hash Join
                                         Hash Cond: (t2_2.id = t3_2.id)
                                         ->  Seq Scan on t2 t2_2
                                         ->  Hash
                                               ->  Seq Scan on t3 t3_2
   InitPlan 2 (returns $1)  (slice6)
     ->  Finalize Aggregate
           ->  Gather Motion 3:1  (slice7; segments: 3)
                 ->  Partial Aggregate
                       ->  Hash Join
                             Hash Cond: (t1_4.id = t2_4.id)
                             ->  Seq Scan on t1 t1_4
                             ->  Hash
                                   ->  Hash Join
                                         Hash Cond: (t2_4.id = t3_4.id)
                                         ->  Seq Scan on t2 t2_4
                                         ->  Hash
                                               ->  Seq Scan on t3 t3_4
   ->  Nested Loop
         ->  Nested Loop
               ->  Nested Loop
                     ->  Nested Loop
                           ->  Index Only Scan using t1_pkey on t1 t1_1
                                 Index Cond: (id = $1)
                           ->  Seq Scan on t2 t2_1
                                 Filter: (id = $1)
                     ->  Seq Scan on t3 t3_1
                           Filter: (id = $1)
               ->  Materialize
                     ->  Nested Loop
                           ->  Nested Loop
                                 ->  Index Only Scan using t1_pkey on t1 t1_3
                                       Index Cond: (id = $1)
                                 ->  Seq Scan on t2 t2_3
                                       Filter: (id = $1)
                           ->  Seq Scan on t3 t3_3
                                 Filter: (id = $1)
         ->  Materialize
               ->  Redistribute Motion 1:3  (slice2; segments: 1)
                     Hash Key: (max(t1_5.id))
                     ->  Finalize Aggregate
                           Filter: (max(t1_5.id) = $1)
                           ->  Gather Motion 3:1  (slice3; segments: 3)
                                 ->  Partial Aggregate
                                       ->  Hash Join
                                             Hash Cond: (t1_5.id = t2_5.id)
                                             ->  Seq Scan on t1 t1_5
                                             ->  Hash
                                                   ->  Hash Join
                                                         Hash Cond: (t2_5.id = t3_5.id)
                                                         ->  Seq Scan on t2 t2_5
                                                         ->  Hash
                                                               ->  Seq Scan on t3 t3_5
 Optimizer: Postgres query optimizer
(63 rows)

/*+HashJoin(t1_1 t3_1)MergeJoin(t1_3 t3_3)NestLoop(t1_2 t2_2)NestLoop(t1_4 t2_4)NestLoop(t1_5 t2_5)Leading(t3_5 t2_5 t1_5)Leading(t3_2 t2_2 t1_2)Leading(t3_4 t2_4 t1_4)Leading(c1_1 t3_3 t2_3 t1_3 t3_1 t2_1 t1_1)*/
EXPLAIN (COSTS false)
WITH c1_1(id) AS (
SELECT max(t1_5.id) FROM t1 t1_5, t2 t2_5, t3 t3_5 WHERE t1_5.id = t2_5.id AND t2_5.id = t3_5.id
)
SELECT t1_1.id, (
SELECT max(t1_2.id) FROM t1 t1_2, t2 t2_2, t3 t3_2 WHERE t1_2.id = t2_2.id AND t2_2.id = t3_2.id
) FROM t1 t1_1, t2 t2_1, t3 t3_1, (
SELECT t1_3.id FROM t1 t1_3, t2 t2_3, t3 t3_3 WHERE t1_3.id = t2_3.id AND t2_3.id = t3_3.id
) v1_1(id), c1_1 WHERE t1_1.id = t2_1.id AND t2_1.id = t3_1.id AND t2_1.id = v1_1.id AND v1_1.id = c1_1.id AND t1_1.id = (
SELECT max(t1_4.id) FROM t1 t1_4, t2 t2_4, t3 t3_4 WHERE t1_4.id = t2_4.id AND t2_4.id = t3_4.id 
);
LOG:  statement: /*+HashJoin(t1_1 t3_1)MergeJoin(t1_3 t3_3)NestLoop(t1_2 t2_2)NestLoop(t1_4 t2_4)NestLoop(t1_5 t2_5)Leading(t3_5 t2_5 t1_5)Leading(t3_2 t2_2 t1_2)Leading(t3_4 t2_4 t1_4)Leading(c1_1 t3_3 t2_3 t1_3 t3_1 t2_1 t1_1)*/
EXPLAIN (COSTS false)
WITH c1_1(id) AS (
SELECT max(t1_5.id) FROM t1 t1_5, t2 t2_5, t3 t3_5 WHERE t1_5.id = t2_5.id AND t2_5.id = t3_5.id
)
SELECT t1_1.id, (
SELECT max(t1_2.id) FROM t1 t1_2, t2 t2_2, t3 t3_2 WHERE t1_2.id = t2_2.id AND t2_2.id = t3_2.id
) FROM t1 t1_1, t2 t2_1, t3 t3_1, (
SELECT t1_3.id FROM t1 t1_3, t2 t2_3, t3 t3_3 WHERE t1_3.id = t2_3.id AND t2_3.id = t3_3.id
) v1_1(id), c1_1 WHERE t1_1.id = t2_1.id AND t2_1.id = t3_1.id AND t2_1.id = v1_1.id AND v1_1.id = c1_1.id AND t1_1.id = (
SELECT max(t1_4.id) FROM t1 t1_4, t2 t2_4, t3 t3_4 WHERE t1_4.id = t2_4.id AND t2_4.id = t3_4.id 
);
WARNING:  "work_mem": setting is deprecated, and may be removed in a future release.
LOG:  pg_hint_plan:
used hint:
HashJoin(t1_1 t3_1)
MergeJoin(t1_3 t3_3)
Leading(t3_5 t2_5 t1_5)
Leading(t3_2 t2_2 t1_2)
Leading(t3_4 t2_4 t1_4)
not used hint:
NestLoop(t1_2 t2_2)
NestLoop(t1_4 t2_4)
NestLoop(t1_5 t2_5)
Leading(c1_1 t3_3 t2_3 t1_3 t3_1 t2_1 t1_1)
duplication hint:
error hint:
                                       QUERY PLAN                                       
----------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   InitPlan 1 (returns $0)  (slice4)
     ->  Finalize Aggregate
           ->  Gather Motion 3:1  (slice5; segments: 3)
                 ->  Partial Aggregate
                       ->  Hash Join
                             Hash Cond: (t1_2.id = t2_2.id)
                             ->  Seq Scan on t1 t1_2
                             ->  Hash
                                   ->  Hash Join
                                         Hash Cond: (t2_2.id = t3_2.id)
                                         ->  Seq Scan on t2 t2_2
                                         ->  Hash
                                               ->  Seq Scan on t3 t3_2
   InitPlan 2 (returns $1)  (slice6)
     ->  Finalize Aggregate
           ->  Gather Motion 3:1  (slice7; segments: 3)
                 ->  Partial Aggregate
                       ->  Hash Join
                             Hash Cond: (t1_4.id = t2_4.id)
                             ->  Seq Scan on t1 t1_4
                             ->  Hash
                                   ->  Hash Join
                                         Hash Cond: (t2_4.id = t3_4.id)
                                         ->  Seq Scan on t2 t2_4
                                         ->  Hash
                                               ->  Seq Scan on t3 t3_4
   ->  Nested Loop
         ->  Nested Loop
               ->  Nested Loop
                     ->  Nested Loop
                           ->  Index Only Scan using t1_pkey on t1 t1_1
                                 Index Cond: (id = $1)
                           ->  Seq Scan on t2 t2_1
                                 Filter: (id = $1)
                     ->  Seq Scan on t3 t3_1
                           Filter: (id = $1)
               ->  Materialize
                     ->  Nested Loop
                           ->  Nested Loop
                                 ->  Index Only Scan using t1_pkey on t1 t1_3
                                       Index Cond: (id = $1)
                                 ->  Seq Scan on t2 t2_3
                                       Filter: (id = $1)
                           ->  Seq Scan on t3 t3_3
                                 Filter: (id = $1)
         ->  Materialize
               ->  Redistribute Motion 1:3  (slice2; segments: 1)
                     Hash Key: (max(t1_5.id))
                     ->  Finalize Aggregate
                           Filter: (max(t1_5.id) = $1)
                           ->  Gather Motion 3:1  (slice3; segments: 3)
                                 ->  Partial Aggregate
                                       ->  Hash Join
                                             Hash Cond: (t1_5.id = t2_5.id)
                                             ->  Seq Scan on t1 t1_5
                                             ->  Hash
                                                   ->  Hash Join
                                                         Hash Cond: (t2_5.id = t3_5.id)
                                                         ->  Seq Scan on t2 t2_5
                                                         ->  Hash
                                                               ->  Seq Scan on t3 t3_5
 Optimizer: Postgres query optimizer
(63 rows)

-- ambigous error
EXPLAIN (COSTS false) SELECT * FROM t1, s0.t1, t2 WHERE public.t1.id = s0.t1.id AND public.t1.id = t2.id;
LOG:  statement: EXPLAIN (COSTS false) SELECT * FROM t1, s0.t1, t2 WHERE public.t1.id = s0.t1.id AND public.t1.id = t2.id;
                    QUERY PLAN                     
---------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t1.id = t1_1.id)
         ->  Seq Scan on t1
         ->  Hash
               ->  Hash Join
                     Hash Cond: (t2.id = t1_1.id)
                     ->  Seq Scan on t2
                     ->  Hash
                           ->  Seq Scan on t1 t1_1
 Optimizer: Postgres query optimizer
(11 rows)

/*+NestLoop(t1 t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, s0.t1, t2 WHERE public.t1.id = s0.t1.id AND public.t1.id = t2.id;
LOG:  statement: /*+NestLoop(t1 t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, s0.t1, t2 WHERE public.t1.id = s0.t1.id AND public.t1.id = t2.id;
INFO:  pg_hint_plan: hint syntax error at or near "NestLoop(t1 t2)"
DETAIL:  Relation name "t1" is ambiguous.
LOG:  pg_hint_plan:
used hint:
not used hint:
duplication hint:
error hint:
NestLoop(t1 t2)
                    QUERY PLAN                     
---------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t1.id = t1_1.id)
         ->  Seq Scan on t1
         ->  Hash
               ->  Hash Join
                     Hash Cond: (t2.id = t1_1.id)
                     ->  Seq Scan on t2
                     ->  Hash
                           ->  Seq Scan on t1 t1_1
 Optimizer: Postgres query optimizer
(11 rows)

/*+Leading(t1 t2 t1)*/
EXPLAIN (COSTS false) SELECT * FROM t1, s0.t1, t2 WHERE public.t1.id = s0.t1.id AND public.t1.id = t2.id;
LOG:  statement: /*+Leading(t1 t2 t1)*/
EXPLAIN (COSTS false) SELECT * FROM t1, s0.t1, t2 WHERE public.t1.id = s0.t1.id AND public.t1.id = t2.id;
INFO:  pg_hint_plan: hint syntax error at or near "Leading(t1 t2 t1)"
DETAIL:  Relation name "t1" is ambiguous.
LOG:  pg_hint_plan:
used hint:
not used hint:
duplication hint:
error hint:
Leading(t1 t2 t1)
                    QUERY PLAN                     
---------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t1.id = t1_1.id)
         ->  Seq Scan on t1
         ->  Hash
               ->  Hash Join
                     Hash Cond: (t2.id = t1_1.id)
                     ->  Seq Scan on t2
                     ->  Hash
                           ->  Seq Scan on t1 t1_1
 Optimizer: Postgres query optimizer
(11 rows)

-- identifier length test
EXPLAIN (COSTS false) SELECT * FROM t1 "123456789012345678901234567890123456789012345678901234567890123" JOIN t2 ON ("123456789012345678901234567890123456789012345678901234567890123".id = t2.id) JOIN t3 ON (t2.id = t3.id);
LOG:  statement: EXPLAIN (COSTS false) SELECT * FROM t1 "123456789012345678901234567890123456789012345678901234567890123" JOIN t2 ON ("123456789012345678901234567890123456789012345678901234567890123".id = t2.id) JOIN t3 ON (t2.id = t3.id);
                                            QUERY PLAN                                             
---------------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: ("123456789012345678901234567890123456789012345678901234567890123".id = t2.id)
         ->  Seq Scan on t1 "123456789012345678901234567890123456789012345678901234567890123"
         ->  Hash
               ->  Hash Join
                     Hash Cond: (t2.id = t3.id)
                     ->  Seq Scan on t2
                     ->  Hash
                           ->  Seq Scan on t3
 Optimizer: Postgres query optimizer
(11 rows)

/*+
Leading(123456789012345678901234567890123456789012345678901234567890123 t2 t3)
SeqScan(123456789012345678901234567890123456789012345678901234567890123)
MergeJoin(123456789012345678901234567890123456789012345678901234567890123 t2)
Set(123456789012345678901234567890123456789012345678901234567890123 1)
*/
EXPLAIN (COSTS false) SELECT * FROM t1 "123456789012345678901234567890123456789012345678901234567890123" JOIN t2 ON ("123456789012345678901234567890123456789012345678901234567890123".id = t2.id) JOIN t3 ON (t2.id = t3.id);
LOG:  statement: /*+
Leading(123456789012345678901234567890123456789012345678901234567890123 t2 t3)
SeqScan(123456789012345678901234567890123456789012345678901234567890123)
MergeJoin(123456789012345678901234567890123456789012345678901234567890123 t2)
Set(123456789012345678901234567890123456789012345678901234567890123 1)
*/
EXPLAIN (COSTS false) SELECT * FROM t1 "123456789012345678901234567890123456789012345678901234567890123" JOIN t2 ON ("123456789012345678901234567890123456789012345678901234567890123".id = t2.id) JOIN t3 ON (t2.id = t3.id);
INFO:  unrecognized configuration parameter "123456789012345678901234567890123456789012345678901234567890123"
WARNING:  "work_mem": setting is deprecated, and may be removed in a future release.
LOG:  pg_hint_plan:
used hint:
SeqScan(123456789012345678901234567890123456789012345678901234567890123)
MergeJoin(123456789012345678901234567890123456789012345678901234567890123 t2)
Leading(123456789012345678901234567890123456789012345678901234567890123 t2 t3)
not used hint:
duplication hint:
error hint:
Set(123456789012345678901234567890123456789012345678901234567890123 1)
                                                QUERY PLAN                                                
----------------------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: ("123456789012345678901234567890123456789012345678901234567890123".id = t3.id)
         ->  Merge Join
               Merge Cond: ("123456789012345678901234567890123456789012345678901234567890123".id = t2.id)
               ->  Sort
                     Sort Key: "123456789012345678901234567890123456789012345678901234567890123".id
                     ->  Seq Scan on t1 "123456789012345678901234567890123456789012345678901234567890123"
               ->  Sort
                     Sort Key: t2.id
                     ->  Seq Scan on t2
         ->  Hash
               ->  Seq Scan on t3
 Optimizer: Postgres query optimizer
(14 rows)

/*+
Leading(1234567890123456789012345678901234567890123456789012345678901234 t2 t3)
SeqScan(1234567890123456789012345678901234567890123456789012345678901234)
MergeJoin(1234567890123456789012345678901234567890123456789012345678901234 t2)
Set(1234567890123456789012345678901234567890123456789012345678901234 1)
Set(cursor_tuple_fraction 0.1234567890123456789012345678901234567890123456789012345678901234)
*/
EXPLAIN (COSTS false) SELECT * FROM t1 "1234567890123456789012345678901234567890123456789012345678901234" JOIN t2 ON ("1234567890123456789012345678901234567890123456789012345678901234".id = t2.id) JOIN t3 ON (t2.id = t3.id);
NOTICE:  identifier "1234567890123456789012345678901234567890123456789012345678901234" will be truncated to "123456789012345678901234567890123456789012345678901234567890123"
NOTICE:  identifier "1234567890123456789012345678901234567890123456789012345678901234" will be truncated to "123456789012345678901234567890123456789012345678901234567890123"
LOG:  statement: /*+
Leading(1234567890123456789012345678901234567890123456789012345678901234 t2 t3)
SeqScan(1234567890123456789012345678901234567890123456789012345678901234)
MergeJoin(1234567890123456789012345678901234567890123456789012345678901234 t2)
Set(1234567890123456789012345678901234567890123456789012345678901234 1)
Set(cursor_tuple_fraction 0.1234567890123456789012345678901234567890123456789012345678901234)
*/
EXPLAIN (COSTS false) SELECT * FROM t1 "1234567890123456789012345678901234567890123456789012345678901234" JOIN t2 ON ("1234567890123456789012345678901234567890123456789012345678901234".id = t2.id) JOIN t3 ON (t2.id = t3.id);
NOTICE:  identifier "1234567890123456789012345678901234567890123456789012345678901234" will be truncated to "123456789012345678901234567890123456789012345678901234567890123"
NOTICE:  identifier "1234567890123456789012345678901234567890123456789012345678901234" will be truncated to "123456789012345678901234567890123456789012345678901234567890123"
NOTICE:  identifier "1234567890123456789012345678901234567890123456789012345678901234" will be truncated to "123456789012345678901234567890123456789012345678901234567890123"
NOTICE:  identifier "1234567890123456789012345678901234567890123456789012345678901234" will be truncated to "123456789012345678901234567890123456789012345678901234567890123"
INFO:  unrecognized configuration parameter "123456789012345678901234567890123456789012345678901234567890123"
WARNING:  "work_mem": setting is deprecated, and may be removed in a future release.
LOG:  pg_hint_plan:
used hint:
SeqScan(123456789012345678901234567890123456789012345678901234567890123)
MergeJoin(123456789012345678901234567890123456789012345678901234567890123 t2)
Leading(123456789012345678901234567890123456789012345678901234567890123 t2 t3)
Set(cursor_tuple_fraction 0.1234567890123456789012345678901234567890123456789012345678901234)
not used hint:
duplication hint:
error hint:
Set(123456789012345678901234567890123456789012345678901234567890123 1)
                                                QUERY PLAN                                                
----------------------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: ("123456789012345678901234567890123456789012345678901234567890123".id = t3.id)
         ->  Merge Join
               Merge Cond: ("123456789012345678901234567890123456789012345678901234567890123".id = t2.id)
               ->  Sort
                     Sort Key: "123456789012345678901234567890123456789012345678901234567890123".id
                     ->  Seq Scan on t1 "123456789012345678901234567890123456789012345678901234567890123"
               ->  Sort
                     Sort Key: t2.id
                     ->  Seq Scan on t2
         ->  Hash
               ->  Seq Scan on t3
 Optimizer: Postgres query optimizer
(14 rows)

SET "123456789012345678901234567890123456789012345678901234567890123" TO 1;
LOG:  statement: SET "123456789012345678901234567890123456789012345678901234567890123" TO 1;
ERROR:  unrecognized configuration parameter "123456789012345678901234567890123456789012345678901234567890123"
SET "1234567890123456789012345678901234567890123456789012345678901234" TO 1;
NOTICE:  identifier "1234567890123456789012345678901234567890123456789012345678901234" will be truncated to "123456789012345678901234567890123456789012345678901234567890123"
LOG:  statement: SET "1234567890123456789012345678901234567890123456789012345678901234" TO 1;
ERROR:  unrecognized configuration parameter "123456789012345678901234567890123456789012345678901234567890123"
SET cursor_tuple_fraction TO 1234567890123456789012345678901234567890123456789012345678901234;
LOG:  statement: SET cursor_tuple_fraction TO 1234567890123456789012345678901234567890123456789012345678901234;
ERROR:  1.23457e+63 is outside the valid range for parameter "cursor_tuple_fraction" (0 .. 1)
-- multi error
/*+ Set(enable_seqscan 100)Set(seq_page_cost on)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id;
LOG:  statement: /*+ Set(enable_seqscan 100)Set(seq_page_cost on)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id;
INFO:  parameter "enable_seqscan" requires a Boolean value
INFO:  invalid value for parameter "seq_page_cost": "on"
LOG:  pg_hint_plan:
used hint:
not used hint:
duplication hint:
error hint:
Set(enable_seqscan 100)
Set(seq_page_cost on)
                QUERY PLAN                
------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t1.id = t2.id)
         ->  Seq Scan on t1
         ->  Hash
               ->  Seq Scan on t2
 Optimizer: Postgres query optimizer
(7 rows)

-- debug log of candidate index to use IndexScan
EXPLAIN (COSTS false) SELECT * FROM t5 WHERE t5.id = 1;
LOG:  statement: EXPLAIN (COSTS false) SELECT * FROM t5 WHERE t5.id = 1;
                                          QUERY PLAN                                          
----------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)
   ->  Index Scan using t5_idaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa on t5
         Index Cond: (id = 1)
 Optimizer: Postgres query optimizer
(4 rows)

/*+IndexScan(t5 t5_id2)*/
EXPLAIN (COSTS false) SELECT * FROM t5 WHERE t5.id = 1;
LOG:  statement: /*+IndexScan(t5 t5_id2)*/
EXPLAIN (COSTS false) SELECT * FROM t5 WHERE t5.id = 1;
LOG:  available indexes for IndexScan(t5): t5_id2
LOG:  pg_hint_plan:
used hint:
IndexScan(t5 t5_id2)
not used hint:
duplication hint:
error hint:
                QUERY PLAN                
------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)
   ->  Index Scan using t5_id2 on t5
         Index Cond: (id = 1)
 Optimizer: Postgres query optimizer
(4 rows)

/*+IndexScan(t5 no_exist)*/
EXPLAIN (COSTS false) SELECT * FROM t5 WHERE t5.id = 1;
LOG:  statement: /*+IndexScan(t5 no_exist)*/
EXPLAIN (COSTS false) SELECT * FROM t5 WHERE t5.id = 1;
LOG:  available indexes for IndexScan(t5):
LOG:  pg_hint_plan:
used hint:
IndexScan(t5 no_exist)
not used hint:
duplication hint:
error hint:
                QUERY PLAN                
------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)
   ->  Seq Scan on t5
         Filter: (id = 1)
 Optimizer: Postgres query optimizer
(4 rows)

/*+IndexScan(t5 t5_id1 t5_id2)*/
EXPLAIN (COSTS false) SELECT * FROM t5 WHERE t5.id = 1;
LOG:  statement: /*+IndexScan(t5 t5_id1 t5_id2)*/
EXPLAIN (COSTS false) SELECT * FROM t5 WHERE t5.id = 1;
LOG:  available indexes for IndexScan(t5): t5_id2 t5_id1
LOG:  pg_hint_plan:
used hint:
IndexScan(t5 t5_id1 t5_id2)
not used hint:
duplication hint:
error hint:
                QUERY PLAN                
------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)
   ->  Index Scan using t5_id2 on t5
         Index Cond: (id = 1)
 Optimizer: Postgres query optimizer
(4 rows)

/*+IndexScan(t5 no_exist t5_id2)*/
EXPLAIN (COSTS false) SELECT * FROM t5 WHERE t5.id = 1;
LOG:  statement: /*+IndexScan(t5 no_exist t5_id2)*/
EXPLAIN (COSTS false) SELECT * FROM t5 WHERE t5.id = 1;
LOG:  available indexes for IndexScan(t5): t5_id2
LOG:  pg_hint_plan:
used hint:
IndexScan(t5 no_exist t5_id2)
not used hint:
duplication hint:
error hint:
                QUERY PLAN                
------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)
   ->  Index Scan using t5_id2 on t5
         Index Cond: (id = 1)
 Optimizer: Postgres query optimizer
(4 rows)

/*+IndexScan(t5 no_exist5 no_exist2)*/
EXPLAIN (COSTS false) SELECT * FROM t5 WHERE t5.id = 1;
LOG:  statement: /*+IndexScan(t5 no_exist5 no_exist2)*/
EXPLAIN (COSTS false) SELECT * FROM t5 WHERE t5.id = 1;
LOG:  available indexes for IndexScan(t5):
LOG:  pg_hint_plan:
used hint:
IndexScan(t5 no_exist5 no_exist2)
not used hint:
duplication hint:
error hint:
                QUERY PLAN                
------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)
   ->  Seq Scan on t5
         Filter: (id = 1)
 Optimizer: Postgres query optimizer
(4 rows)

-- outer inner
EXPLAIN (COSTS false) SELECT * FROM t1, t2, t3 WHERE t1.id = t2.id AND t2.val = t3.val AND t1.id < 10;
LOG:  statement: EXPLAIN (COSTS false) SELECT * FROM t1, t2, t3 WHERE t1.id = t2.id AND t2.val = t3.val AND t1.id < 10;
                               QUERY PLAN                               
------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t3.val = t2.val)
         ->  Seq Scan on t3
         ->  Hash
               ->  Broadcast Motion 3:3  (slice2; segments: 3)
                     ->  Hash Join
                           Hash Cond: (t2.id = t1.id)
                           ->  Seq Scan on t2
                                 Filter: (id < 10)
                           ->  Hash
                                 ->  Bitmap Heap Scan on t1
                                       Recheck Cond: (id < 10)
                                       ->  Bitmap Index Scan on t1_pkey
                                             Index Cond: (id < 10)
 Optimizer: Postgres query optimizer
(16 rows)

/*+Leading((t1))*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2, t3 WHERE t1.id = t2.id AND t2.val = t3.val AND t1.id < 10;
LOG:  statement: /*+Leading((t1))*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2, t3 WHERE t1.id = t2.id AND t2.val = t3.val AND t1.id < 10;
INFO:  pg_hint_plan: hint syntax error at or near "Leading((t1))"
DETAIL:  Leading hint requires two sets of relations when parentheses nests.
LOG:  pg_hint_plan:
used hint:
not used hint:
duplication hint:
error hint:
Leading((t1))
                               QUERY PLAN                               
------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t3.val = t2.val)
         ->  Seq Scan on t3
         ->  Hash
               ->  Broadcast Motion 3:3  (slice2; segments: 3)
                     ->  Hash Join
                           Hash Cond: (t2.id = t1.id)
                           ->  Seq Scan on t2
                                 Filter: (id < 10)
                           ->  Hash
                                 ->  Bitmap Heap Scan on t1
                                       Recheck Cond: (id < 10)
                                       ->  Bitmap Index Scan on t1_pkey
                                             Index Cond: (id < 10)
 Optimizer: Postgres query optimizer
(16 rows)

/*+Leading((t1 t2))*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2, t3 WHERE t1.id = t2.id AND t2.val = t3.val AND t1.id < 10;
LOG:  statement: /*+Leading((t1 t2))*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2, t3 WHERE t1.id = t2.id AND t2.val = t3.val AND t1.id < 10;
WARNING:  "work_mem": setting is deprecated, and may be removed in a future release.
LOG:  pg_hint_plan:
used hint:
Leading((t1 t2))
not used hint:
duplication hint:
error hint:
                         QUERY PLAN                         
------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Nested Loop
         Join Filter: (t2.val = t3.val)
         ->  Broadcast Motion 3:3  (slice2; segments: 3)
               ->  Hash Join
                     Hash Cond: (t1.id = t2.id)
                     ->  Bitmap Heap Scan on t1
                           Recheck Cond: (id < 10)
                           ->  Bitmap Index Scan on t1_pkey
                                 Index Cond: (id < 10)
                     ->  Hash
                           ->  Seq Scan on t2
                                 Filter: (id < 10)
         ->  Materialize
               ->  Seq Scan on t3
 Optimizer: Postgres query optimizer
(16 rows)

/*+Leading((t1 t2 t3))*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2, t3 WHERE t1.id = t2.id AND t2.val = t3.val AND t1.id < 10;
LOG:  statement: /*+Leading((t1 t2 t3))*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2, t3 WHERE t1.id = t2.id AND t2.val = t3.val AND t1.id < 10;
INFO:  pg_hint_plan: hint syntax error at or near "Leading((t1 t2 t3))"
DETAIL:  Leading hint requires two sets of relations when parentheses nests.
LOG:  pg_hint_plan:
used hint:
not used hint:
duplication hint:
error hint:
Leading((t1 t2 t3))
                               QUERY PLAN                               
------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t3.val = t2.val)
         ->  Seq Scan on t3
         ->  Hash
               ->  Broadcast Motion 3:3  (slice2; segments: 3)
                     ->  Hash Join
                           Hash Cond: (t2.id = t1.id)
                           ->  Seq Scan on t2
                                 Filter: (id < 10)
                           ->  Hash
                                 ->  Bitmap Heap Scan on t1
                                       Recheck Cond: (id < 10)
                                       ->  Bitmap Index Scan on t1_pkey
                                             Index Cond: (id < 10)
 Optimizer: Postgres query optimizer
(16 rows)

EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.id < 10;
LOG:  statement: EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.id < 10;
                      QUERY PLAN                      
------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t2.id = t1.id)
         ->  Seq Scan on t2
               Filter: (id < 10)
         ->  Hash
               ->  Bitmap Heap Scan on t1
                     Recheck Cond: (id < 10)
                     ->  Bitmap Index Scan on t1_pkey
                           Index Cond: (id < 10)
 Optimizer: Postgres query optimizer
(11 rows)

/*+Leading((t1 t2))*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.id < 10;
LOG:  statement: /*+Leading((t1 t2))*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.id < 10;
WARNING:  "work_mem": setting is deprecated, and may be removed in a future release.
LOG:  pg_hint_plan:
used hint:
Leading((t1 t2))
not used hint:
duplication hint:
error hint:
                   QUERY PLAN                   
------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t1.id = t2.id)
         ->  Bitmap Heap Scan on t1
               Recheck Cond: (id < 10)
               ->  Bitmap Index Scan on t1_pkey
                     Index Cond: (id < 10)
         ->  Hash
               ->  Seq Scan on t2
                     Filter: (id < 10)
 Optimizer: Postgres query optimizer
(11 rows)

EXPLAIN (COSTS false) SELECT * FROM t1, t2, t3 WHERE t1.id = t2.id AND t2.val = t3.val AND t1.id < 10;
LOG:  statement: EXPLAIN (COSTS false) SELECT * FROM t1, t2, t3 WHERE t1.id = t2.id AND t2.val = t3.val AND t1.id < 10;
                               QUERY PLAN                               
------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t3.val = t2.val)
         ->  Seq Scan on t3
         ->  Hash
               ->  Broadcast Motion 3:3  (slice2; segments: 3)
                     ->  Hash Join
                           Hash Cond: (t2.id = t1.id)
                           ->  Seq Scan on t2
                                 Filter: (id < 10)
                           ->  Hash
                                 ->  Bitmap Heap Scan on t1
                                       Recheck Cond: (id < 10)
                                       ->  Bitmap Index Scan on t1_pkey
                                             Index Cond: (id < 10)
 Optimizer: Postgres query optimizer
(16 rows)

/*+Leading(((t1 t2) t3))*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2, t3 WHERE t1.id = t2.id AND t2.val = t3.val AND t1.id < 10;
LOG:  statement: /*+Leading(((t1 t2) t3))*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2, t3 WHERE t1.id = t2.id AND t2.val = t3.val AND t1.id < 10;
WARNING:  "work_mem": setting is deprecated, and may be removed in a future release.
LOG:  pg_hint_plan:
used hint:
Leading(((t1 t2) t3))
not used hint:
duplication hint:
error hint:
                         QUERY PLAN                         
------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t2.val = t3.val)
         ->  Broadcast Motion 3:3  (slice2; segments: 3)
               ->  Hash Join
                     Hash Cond: (t1.id = t2.id)
                     ->  Bitmap Heap Scan on t1
                           Recheck Cond: (id < 10)
                           ->  Bitmap Index Scan on t1_pkey
                                 Index Cond: (id < 10)
                     ->  Hash
                           ->  Seq Scan on t2
                                 Filter: (id < 10)
         ->  Hash
               ->  Seq Scan on t3
 Optimizer: Postgres query optimizer
(16 rows)

EXPLAIN (COSTS false) SELECT * FROM t1, t2, t3, t4 WHERE t1.id = t2.id AND t3.id = t4.id AND t1.val = t3.val AND t1.id < 10;
LOG:  statement: EXPLAIN (COSTS false) SELECT * FROM t1, t2, t3, t4 WHERE t1.id = t2.id AND t3.id = t4.id AND t1.val = t3.val AND t1.id < 10;
                            QUERY PLAN                            
------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t1.val = t3.val)
         ->  Broadcast Motion 3:3  (slice2; segments: 3)
               ->  Hash Join
                     Hash Cond: (t2.id = t1.id)
                     ->  Seq Scan on t2
                           Filter: (id < 10)
                     ->  Hash
                           ->  Bitmap Heap Scan on t1
                                 Recheck Cond: (id < 10)
                                 ->  Bitmap Index Scan on t1_pkey
                                       Index Cond: (id < 10)
         ->  Hash
               ->  Hash Join
                     Hash Cond: (t3.id = t4.id)
                     ->  Seq Scan on t3
                     ->  Hash
                           ->  Seq Scan on t4
 Optimizer: Postgres query optimizer
(20 rows)

/*+Leading((((t1 t2) t3) t4))*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2, t3, t4 WHERE t1.id = t2.id AND t3.id = t4.id AND t1.val = t3.val AND t1.id < 10;
LOG:  statement: /*+Leading((((t1 t2) t3) t4))*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2, t3, t4 WHERE t1.id = t2.id AND t3.id = t4.id AND t1.val = t3.val AND t1.id < 10;
WARNING:  "work_mem": setting is deprecated, and may be removed in a future release.
LOG:  pg_hint_plan:
used hint:
Leading((((t1 t2) t3) t4))
not used hint:
duplication hint:
error hint:
                            QUERY PLAN                            
------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t3.id = t4.id)
         ->  Hash Join
               Hash Cond: (t1.val = t3.val)
               ->  Broadcast Motion 3:3  (slice2; segments: 3)
                     ->  Hash Join
                           Hash Cond: (t1.id = t2.id)
                           ->  Bitmap Heap Scan on t1
                                 Recheck Cond: (id < 10)
                                 ->  Bitmap Index Scan on t1_pkey
                                       Index Cond: (id < 10)
                           ->  Hash
                                 ->  Seq Scan on t2
                                       Filter: (id < 10)
               ->  Hash
                     ->  Seq Scan on t3
         ->  Hash
               ->  Seq Scan on t4
 Optimizer: Postgres query optimizer
(20 rows)

EXPLAIN (COSTS false) SELECT * FROM t1, t2, t3 WHERE t1.id = t2.id AND t2.val = t3.val AND t1.id < 10;
LOG:  statement: EXPLAIN (COSTS false) SELECT * FROM t1, t2, t3 WHERE t1.id = t2.id AND t2.val = t3.val AND t1.id < 10;
                               QUERY PLAN                               
------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t3.val = t2.val)
         ->  Seq Scan on t3
         ->  Hash
               ->  Broadcast Motion 3:3  (slice2; segments: 3)
                     ->  Hash Join
                           Hash Cond: (t2.id = t1.id)
                           ->  Seq Scan on t2
                                 Filter: (id < 10)
                           ->  Hash
                                 ->  Bitmap Heap Scan on t1
                                       Recheck Cond: (id < 10)
                                       ->  Bitmap Index Scan on t1_pkey
                                             Index Cond: (id < 10)
 Optimizer: Postgres query optimizer
(16 rows)

/*+Leading(((t1 t2) t3))*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2, t3 WHERE t1.id = t2.id AND t2.val = t3.val AND t1.id < 10;
LOG:  statement: /*+Leading(((t1 t2) t3))*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2, t3 WHERE t1.id = t2.id AND t2.val = t3.val AND t1.id < 10;
WARNING:  "work_mem": setting is deprecated, and may be removed in a future release.
LOG:  pg_hint_plan:
used hint:
Leading(((t1 t2) t3))
not used hint:
duplication hint:
error hint:
                         QUERY PLAN                         
------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t2.val = t3.val)
         ->  Broadcast Motion 3:3  (slice2; segments: 3)
               ->  Hash Join
                     Hash Cond: (t1.id = t2.id)
                     ->  Bitmap Heap Scan on t1
                           Recheck Cond: (id < 10)
                           ->  Bitmap Index Scan on t1_pkey
                                 Index Cond: (id < 10)
                     ->  Hash
                           ->  Seq Scan on t2
                                 Filter: (id < 10)
         ->  Hash
               ->  Seq Scan on t3
 Optimizer: Postgres query optimizer
(16 rows)

/*+Leading((t1 (t2 t3)))*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2, t3 WHERE t1.id = t2.id AND t2.val = t3.val AND t1.id < 10;
LOG:  statement: /*+Leading((t1 (t2 t3)))*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2, t3 WHERE t1.id = t2.id AND t2.val = t3.val AND t1.id < 10;
WARNING:  "work_mem": setting is deprecated, and may be removed in a future release.
LOG:  pg_hint_plan:
used hint:
Leading((t1 (t2 t3)))
not used hint:
duplication hint:
error hint:
                                QUERY PLAN                                 
---------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t1.id = t2.id)
         ->  Bitmap Heap Scan on t1
               Recheck Cond: (id < 10)
               ->  Bitmap Index Scan on t1_pkey
                     Index Cond: (id < 10)
         ->  Hash
               ->  Redistribute Motion 3:3  (slice2; segments: 3)
                     Hash Key: t2.id
                     ->  Hash Join
                           Hash Cond: (t2.val = t3.val)
                           ->  Broadcast Motion 3:3  (slice3; segments: 3)
                                 ->  Seq Scan on t2
                                       Filter: (id < 10)
                           ->  Hash
                                 ->  Seq Scan on t3
 Optimizer: Postgres query optimizer
(18 rows)

EXPLAIN (COSTS false) SELECT * FROM t1, t2, t3, t4 WHERE t1.id = t2.id AND t3.id = t4.id AND t1.val = t3.val AND t1.id < 10;
LOG:  statement: EXPLAIN (COSTS false) SELECT * FROM t1, t2, t3, t4 WHERE t1.id = t2.id AND t3.id = t4.id AND t1.val = t3.val AND t1.id < 10;
                            QUERY PLAN                            
------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t1.val = t3.val)
         ->  Broadcast Motion 3:3  (slice2; segments: 3)
               ->  Hash Join
                     Hash Cond: (t2.id = t1.id)
                     ->  Seq Scan on t2
                           Filter: (id < 10)
                     ->  Hash
                           ->  Bitmap Heap Scan on t1
                                 Recheck Cond: (id < 10)
                                 ->  Bitmap Index Scan on t1_pkey
                                       Index Cond: (id < 10)
         ->  Hash
               ->  Hash Join
                     Hash Cond: (t3.id = t4.id)
                     ->  Seq Scan on t3
                     ->  Hash
                           ->  Seq Scan on t4
 Optimizer: Postgres query optimizer
(20 rows)

/*+Leading(((t1 t2) (t3 t4)))*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2, t3, t4 WHERE t1.id = t2.id AND t3.id = t4.id AND t1.val = t3.val AND t1.id < 10;
LOG:  statement: /*+Leading(((t1 t2) (t3 t4)))*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2, t3, t4 WHERE t1.id = t2.id AND t3.id = t4.id AND t1.val = t3.val AND t1.id < 10;
WARNING:  "work_mem": setting is deprecated, and may be removed in a future release.
LOG:  pg_hint_plan:
used hint:
Leading(((t1 t2) (t3 t4)))
not used hint:
duplication hint:
error hint:
                         QUERY PLAN                         
------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t1.val = t3.val)
         ->  Broadcast Motion 3:3  (slice2; segments: 3)
               ->  Hash Join
                     Hash Cond: (t1.id = t2.id)
                     ->  Bitmap Heap Scan on t1
                           Recheck Cond: (id < 10)
                           ->  Bitmap Index Scan on t1_pkey
                                 Index Cond: (id < 10)
                     ->  Hash
                           ->  Seq Scan on t2
                                 Filter: (id < 10)
         ->  Hash
               ->  Hash Join
                     Hash Cond: (t3.id = t4.id)
                     ->  Seq Scan on t3
                     ->  Hash
                           ->  Seq Scan on t4
 Optimizer: Postgres query optimizer
(20 rows)

EXPLAIN (COSTS false) SELECT * FROM t1, t2, t3 WHERE t1.id = t2.id AND t2.val = t3.val AND t1.id < ( SELECT t1_2.id FROM t1 t1_2, t2 t2_2 WHERE t1_2.id = t2_2.id AND t2_2.val > 100 ORDER BY t1_2.id LIMIT 1);
LOG:  statement: EXPLAIN (COSTS false) SELECT * FROM t1, t2, t3 WHERE t1.id = t2.id AND t2.val = t3.val AND t1.id < ( SELECT t1_2.id FROM t1 t1_2, t2 t2_2 WHERE t1_2.id = t2_2.id AND t2_2.val > 100 ORDER BY t1_2.id LIMIT 1);
                            QUERY PLAN                             
-------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   InitPlan 1 (returns $0)  (slice3)
     ->  Limit
           ->  Gather Motion 3:1  (slice4; segments: 3)
                 Merge Key: t1_2.id
                 ->  Limit
                       ->  Sort
                             Sort Key: t1_2.id
                             ->  Hash Join
                                   Hash Cond: (t1_2.id = t2_2.id)
                                   ->  Seq Scan on t1 t1_2
                                   ->  Hash
                                         ->  Seq Scan on t2 t2_2
                                               Filter: (val > 100)
   ->  Hash Join
         Hash Cond: (t3.val = t2.val)
         ->  Broadcast Motion 3:3  (slice2; segments: 3)
               ->  Seq Scan on t3
         ->  Hash
               ->  Hash Join
                     Hash Cond: (t1.id = t2.id)
                     ->  Seq Scan on t1
                           Filter: (id < $0)
                     ->  Hash
                           ->  Seq Scan on t2
                                 Filter: (id < $0)
 Optimizer: Postgres query optimizer
(27 rows)

/*+Leading(((t1 t2) t3)) Leading(((t3 t1) t2))*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2, t3 WHERE t1.id = t2.id AND t1.val = t3.val AND t1.id < ( SELECT t1_2.id FROM t1 t1_2, t2 t2_2 WHERE t1_2.id = t2_2.id AND t2_2.val > 100 ORDER BY t1_2.id LIMIT 1);
LOG:  statement: /*+Leading(((t1 t2) t3)) Leading(((t3 t1) t2))*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2, t3 WHERE t1.id = t2.id AND t1.val = t3.val AND t1.id < ( SELECT t1_2.id FROM t1 t1_2, t2 t2_2 WHERE t1_2.id = t2_2.id AND t2_2.val > 100 ORDER BY t1_2.id LIMIT 1);
INFO:  pg_hint_plan: hint syntax error at or near "Leading(((t1 t2) t3)) Leading(((t3 t1) t2))"
DETAIL:  Conflict leading hint.
WARNING:  "work_mem": setting is deprecated, and may be removed in a future release.
LOG:  pg_hint_plan:
used hint:
Leading(((t3 t1) t2))
not used hint:
duplication hint:
Leading(((t1 t2) t3))
error hint:
                            QUERY PLAN                             
-------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   InitPlan 1 (returns $0)  (slice3)
     ->  Limit
           ->  Gather Motion 3:1  (slice4; segments: 3)
                 Merge Key: t1_2.id
                 ->  Limit
                       ->  Sort
                             Sort Key: t1_2.id
                             ->  Hash Join
                                   Hash Cond: (t1_2.id = t2_2.id)
                                   ->  Seq Scan on t1 t1_2
                                   ->  Hash
                                         ->  Seq Scan on t2 t2_2
                                               Filter: (val > 100)
   ->  Hash Join
         Hash Cond: (t1.id = t2.id)
         ->  Hash Join
               Hash Cond: (t3.val = t1.val)
               ->  Broadcast Motion 3:3  (slice2; segments: 3)
                     ->  Seq Scan on t3
               ->  Hash
                     ->  Seq Scan on t1
                           Filter: (id < $0)
         ->  Hash
               ->  Seq Scan on t2
                     Filter: (id < $0)
 Optimizer: Postgres query optimizer
(27 rows)

/*+Leading(((t1 t2) t3)) Leading((t1_2 t2_2))*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2, t3 WHERE t1.id = t2.id AND t2.val = t3.val AND t1.id < ( SELECT t1_2.id FROM t1 t1_2, t2 t2_2 WHERE t1_2.id = t2_2.id AND t2_2.val > 100 ORDER BY t1_2.id LIMIT 1);
LOG:  statement: /*+Leading(((t1 t2) t3)) Leading((t1_2 t2_2))*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2, t3 WHERE t1.id = t2.id AND t2.val = t3.val AND t1.id < ( SELECT t1_2.id FROM t1 t1_2, t2 t2_2 WHERE t1_2.id = t2_2.id AND t2_2.val > 100 ORDER BY t1_2.id LIMIT 1);
WARNING:  "work_mem": setting is deprecated, and may be removed in a future release.
LOG:  pg_hint_plan:
used hint:
Leading(((t1 t2) t3))
Leading((t1_2 t2_2))
not used hint:
duplication hint:
error hint:
                            QUERY PLAN                             
-------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   InitPlan 1 (returns $0)  (slice3)
     ->  Limit
           ->  Gather Motion 3:1  (slice4; segments: 3)
                 Merge Key: t1_2.id
                 ->  Limit
                       ->  Sort
                             Sort Key: t1_2.id
                             ->  Hash Join
                                   Hash Cond: (t1_2.id = t2_2.id)
                                   ->  Seq Scan on t1 t1_2
                                   ->  Hash
                                         ->  Seq Scan on t2 t2_2
                                               Filter: (val > 100)
   ->  Hash Join
         Hash Cond: (t2.val = t3.val)
         ->  Hash Join
               Hash Cond: (t1.id = t2.id)
               ->  Seq Scan on t1
                     Filter: (id < $0)
               ->  Hash
                     ->  Seq Scan on t2
                           Filter: (id < $0)
         ->  Hash
               ->  Broadcast Motion 3:3  (slice2; segments: 3)
                     ->  Seq Scan on t3
 Optimizer: Postgres query optimizer
(27 rows)

/*+Leading(((((t1 t2) t3) t1_2) t2_2))*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2, t3 WHERE t1.id = t2.id AND t2.val = t3.val AND t1.id < ( SELECT t1_2.id FROM t1 t1_2, t2 t2_2 WHERE t1_2.id = t2_2.id AND t2_2.val > 100 ORDER BY t1_2.id LIMIT 1);
LOG:  statement: /*+Leading(((((t1 t2) t3) t1_2) t2_2))*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2, t3 WHERE t1.id = t2.id AND t2.val = t3.val AND t1.id < ( SELECT t1_2.id FROM t1 t1_2, t2 t2_2 WHERE t1_2.id = t2_2.id AND t2_2.val > 100 ORDER BY t1_2.id LIMIT 1);
LOG:  pg_hint_plan:
used hint:
not used hint:
Leading(((((t1 t2) t3) t1_2) t2_2))
duplication hint:
error hint:
                            QUERY PLAN                             
-------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   InitPlan 1 (returns $0)  (slice3)
     ->  Limit
           ->  Gather Motion 3:1  (slice4; segments: 3)
                 Merge Key: t1_2.id
                 ->  Limit
                       ->  Sort
                             Sort Key: t1_2.id
                             ->  Hash Join
                                   Hash Cond: (t1_2.id = t2_2.id)
                                   ->  Seq Scan on t1 t1_2
                                   ->  Hash
                                         ->  Seq Scan on t2 t2_2
                                               Filter: (val > 100)
   ->  Hash Join
         Hash Cond: (t3.val = t2.val)
         ->  Broadcast Motion 3:3  (slice2; segments: 3)
               ->  Seq Scan on t3
         ->  Hash
               ->  Hash Join
                     Hash Cond: (t1.id = t2.id)
                     ->  Seq Scan on t1
                           Filter: (id < $0)
                     ->  Hash
                           ->  Seq Scan on t2
                                 Filter: (id < $0)
 Optimizer: Postgres query optimizer
(27 rows)

-- Specified outer/inner leading hint and join method hint at the same time
/*+Leading(((t1 t2) t3))*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2, t3 WHERE t1.id = t2.id AND t2.val = t3.val AND t1.id < 10;
LOG:  statement: /*+Leading(((t1 t2) t3))*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2, t3 WHERE t1.id = t2.id AND t2.val = t3.val AND t1.id < 10;
WARNING:  "work_mem": setting is deprecated, and may be removed in a future release.
LOG:  pg_hint_plan:
used hint:
Leading(((t1 t2) t3))
not used hint:
duplication hint:
error hint:
                         QUERY PLAN                         
------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t2.val = t3.val)
         ->  Broadcast Motion 3:3  (slice2; segments: 3)
               ->  Hash Join
                     Hash Cond: (t1.id = t2.id)
                     ->  Bitmap Heap Scan on t1
                           Recheck Cond: (id < 10)
                           ->  Bitmap Index Scan on t1_pkey
                                 Index Cond: (id < 10)
                     ->  Hash
                           ->  Seq Scan on t2
                                 Filter: (id < 10)
         ->  Hash
               ->  Seq Scan on t3
 Optimizer: Postgres query optimizer
(16 rows)

/*+Leading(((t1 t2) t3)) MergeJoin(t1 t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2, t3 WHERE t1.id = t2.id AND t2.val = t3.val AND t1.id < 10;
LOG:  statement: /*+Leading(((t1 t2) t3)) MergeJoin(t1 t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2, t3 WHERE t1.id = t2.id AND t2.val = t3.val AND t1.id < 10;
WARNING:  "work_mem": setting is deprecated, and may be removed in a future release.
LOG:  pg_hint_plan:
used hint:
MergeJoin(t1 t2)
Leading(((t1 t2) t3))
not used hint:
duplication hint:
error hint:
                       QUERY PLAN                        
---------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t2.val = t3.val)
         ->  Broadcast Motion 3:3  (slice2; segments: 3)
               ->  Merge Join
                     Merge Cond: (t1.id = t2.id)
                     ->  Index Scan using t1_pkey on t1
                           Index Cond: (id < 10)
                     ->  Sort
                           Sort Key: t2.id
                           ->  Seq Scan on t2
                                 Filter: (id < 10)
         ->  Hash
               ->  Seq Scan on t3
 Optimizer: Postgres query optimizer
(15 rows)

/*+Leading(((t1 t2) t3)) MergeJoin(t1 t2 t3)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2, t3 WHERE t1.id = t2.id AND t2.val = t3.val AND t1.id < 10;
LOG:  statement: /*+Leading(((t1 t2) t3)) MergeJoin(t1 t2 t3)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2, t3 WHERE t1.id = t2.id AND t2.val = t3.val AND t1.id < 10;
WARNING:  "work_mem": setting is deprecated, and may be removed in a future release.
LOG:  pg_hint_plan:
used hint:
MergeJoin(t1 t2 t3)
Leading(((t1 t2) t3))
not used hint:
duplication hint:
error hint:
                            QUERY PLAN                            
------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Merge Join
         Merge Cond: (t2.val = t3.val)
         ->  Sort
               Sort Key: t2.val
               ->  Broadcast Motion 3:3  (slice2; segments: 3)
                     ->  Hash Join
                           Hash Cond: (t1.id = t2.id)
                           ->  Bitmap Heap Scan on t1
                                 Recheck Cond: (id < 10)
                                 ->  Bitmap Index Scan on t1_pkey
                                       Index Cond: (id < 10)
                           ->  Hash
                                 ->  Seq Scan on t2
                                       Filter: (id < 10)
         ->  Sort
               Sort Key: t3.val
               ->  Seq Scan on t3
 Optimizer: Postgres query optimizer
(19 rows)

/*+Leading(((t1 t2) t3)) MergeJoin(t1 t3)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2, t3 WHERE t1.id = t2.id AND t2.val = t3.val AND t1.id < 10;
LOG:  statement: /*+Leading(((t1 t2) t3)) MergeJoin(t1 t3)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2, t3 WHERE t1.id = t2.id AND t2.val = t3.val AND t1.id < 10;
WARNING:  "work_mem": setting is deprecated, and may be removed in a future release.
LOG:  pg_hint_plan:
used hint:
Leading(((t1 t2) t3))
not used hint:
MergeJoin(t1 t3)
duplication hint:
error hint:
                         QUERY PLAN                         
------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t2.val = t3.val)
         ->  Broadcast Motion 3:3  (slice2; segments: 3)
               ->  Hash Join
                     Hash Cond: (t1.id = t2.id)
                     ->  Bitmap Heap Scan on t1
                           Recheck Cond: (id < 10)
                           ->  Bitmap Index Scan on t1_pkey
                                 Index Cond: (id < 10)
                     ->  Hash
                           ->  Seq Scan on t2
                                 Filter: (id < 10)
         ->  Hash
               ->  Seq Scan on t3
 Optimizer: Postgres query optimizer
(16 rows)

EXPLAIN (COSTS false) SELECT * FROM t1, t2, t3, t4 WHERE t1.id = t2.id AND t3.id = t4.id AND t1.val = t3.val AND t1.id < 10;
LOG:  statement: EXPLAIN (COSTS false) SELECT * FROM t1, t2, t3, t4 WHERE t1.id = t2.id AND t3.id = t4.id AND t1.val = t3.val AND t1.id < 10;
                            QUERY PLAN                            
------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t1.val = t3.val)
         ->  Broadcast Motion 3:3  (slice2; segments: 3)
               ->  Hash Join
                     Hash Cond: (t2.id = t1.id)
                     ->  Seq Scan on t2
                           Filter: (id < 10)
                     ->  Hash
                           ->  Bitmap Heap Scan on t1
                                 Recheck Cond: (id < 10)
                                 ->  Bitmap Index Scan on t1_pkey
                                       Index Cond: (id < 10)
         ->  Hash
               ->  Hash Join
                     Hash Cond: (t3.id = t4.id)
                     ->  Seq Scan on t3
                     ->  Hash
                           ->  Seq Scan on t4
 Optimizer: Postgres query optimizer
(20 rows)

/*+Leading(((t1 t2) t3)) MergeJoin(t3 t4)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2, t3, t4 WHERE t1.id = t2.id AND t3.id = t4.id AND t1.val = t3.val AND t1.id < 10;
LOG:  statement: /*+Leading(((t1 t2) t3)) MergeJoin(t3 t4)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2, t3, t4 WHERE t1.id = t2.id AND t3.id = t4.id AND t1.val = t3.val AND t1.id < 10;
WARNING:  "work_mem": setting is deprecated, and may be removed in a future release.
LOG:  pg_hint_plan:
used hint:
Leading(((t1 t2) t3))
not used hint:
MergeJoin(t3 t4)
duplication hint:
error hint:
                            QUERY PLAN                            
------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Nested Loop
         ->  Hash Join
               Hash Cond: (t1.val = t3.val)
               ->  Broadcast Motion 3:3  (slice2; segments: 3)
                     ->  Hash Join
                           Hash Cond: (t1.id = t2.id)
                           ->  Bitmap Heap Scan on t1
                                 Recheck Cond: (id < 10)
                                 ->  Bitmap Index Scan on t1_pkey
                                       Index Cond: (id < 10)
                           ->  Hash
                                 ->  Seq Scan on t2
                                       Filter: (id < 10)
               ->  Hash
                     ->  Seq Scan on t3
         ->  Index Scan using t4_pkey on t4
               Index Cond: (id = t3.id)
 Optimizer: Postgres query optimizer
(19 rows)

/*+Leading(((t1 t2) t3)) MergeJoin(t1 t2 t3 t4)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2, t3, t4 WHERE t1.id = t2.id AND t3.id = t4.id AND t1.val = t3.val AND t1.id < 10;
LOG:  statement: /*+Leading(((t1 t2) t3)) MergeJoin(t1 t2 t3 t4)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2, t3, t4 WHERE t1.id = t2.id AND t3.id = t4.id AND t1.val = t3.val AND t1.id < 10;
WARNING:  "work_mem": setting is deprecated, and may be removed in a future release.
LOG:  pg_hint_plan:
used hint:
MergeJoin(t1 t2 t3 t4)
Leading(((t1 t2) t3))
not used hint:
duplication hint:
error hint:
                               QUERY PLAN                               
------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Merge Join
         Merge Cond: (t3.id = t4.id)
         ->  Sort
               Sort Key: t3.id
               ->  Hash Join
                     Hash Cond: (t1.val = t3.val)
                     ->  Broadcast Motion 3:3  (slice2; segments: 3)
                           ->  Hash Join
                                 Hash Cond: (t1.id = t2.id)
                                 ->  Bitmap Heap Scan on t1
                                       Recheck Cond: (id < 10)
                                       ->  Bitmap Index Scan on t1_pkey
                                             Index Cond: (id < 10)
                                 ->  Hash
                                       ->  Seq Scan on t2
                                             Filter: (id < 10)
                     ->  Hash
                           ->  Seq Scan on t3
         ->  Sort
               Sort Key: t4.id
               ->  Seq Scan on t4
 Optimizer: Postgres query optimizer
(23 rows)

/*+ Leading ( ( t1 ( t2 t3 ) ) ) */
EXPLAIN (COSTS false) SELECT * FROM t1, t2, t3 WHERE t1.id = t2.id AND t2.val = t3.val AND t1.id < 10;
LOG:  statement: /*+ Leading ( ( t1 ( t2 t3 ) ) ) */
EXPLAIN (COSTS false) SELECT * FROM t1, t2, t3 WHERE t1.id = t2.id AND t2.val = t3.val AND t1.id < 10;
WARNING:  "work_mem": setting is deprecated, and may be removed in a future release.
LOG:  pg_hint_plan:
used hint:
Leading((t1 (t2 t3)))
not used hint:
duplication hint:
error hint:
                                QUERY PLAN                                 
---------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t1.id = t2.id)
         ->  Bitmap Heap Scan on t1
               Recheck Cond: (id < 10)
               ->  Bitmap Index Scan on t1_pkey
                     Index Cond: (id < 10)
         ->  Hash
               ->  Redistribute Motion 3:3  (slice2; segments: 3)
                     Hash Key: t2.id
                     ->  Hash Join
                           Hash Cond: (t2.val = t3.val)
                           ->  Broadcast Motion 3:3  (slice3; segments: 3)
                                 ->  Seq Scan on t2
                                       Filter: (id < 10)
                           ->  Hash
                                 ->  Seq Scan on t3
 Optimizer: Postgres query optimizer
(18 rows)

/*+Leading((t1(t2 t3)))*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2, t3 WHERE t1.id = t2.id AND t2.val = t3.val AND t1.id < 10;
LOG:  statement: /*+Leading((t1(t2 t3)))*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2, t3 WHERE t1.id = t2.id AND t2.val = t3.val AND t1.id < 10;
WARNING:  "work_mem": setting is deprecated, and may be removed in a future release.
LOG:  pg_hint_plan:
used hint:
Leading((t1 (t2 t3)))
not used hint:
duplication hint:
error hint:
                                QUERY PLAN                                 
---------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t1.id = t2.id)
         ->  Bitmap Heap Scan on t1
               Recheck Cond: (id < 10)
               ->  Bitmap Index Scan on t1_pkey
                     Index Cond: (id < 10)
         ->  Hash
               ->  Redistribute Motion 3:3  (slice2; segments: 3)
                     Hash Key: t2.id
                     ->  Hash Join
                           Hash Cond: (t2.val = t3.val)
                           ->  Broadcast Motion 3:3  (slice3; segments: 3)
                                 ->  Seq Scan on t2
                                       Filter: (id < 10)
                           ->  Hash
                                 ->  Seq Scan on t3
 Optimizer: Postgres query optimizer
(18 rows)

/*+Leading(("t1(t2" "t3)"))*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2, t3 WHERE t1.id = t2.id AND t2.val = t3.val AND t1.id < 10;
LOG:  statement: /*+Leading(("t1(t2" "t3)"))*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2, t3 WHERE t1.id = t2.id AND t2.val = t3.val AND t1.id < 10;
LOG:  pg_hint_plan:
used hint:
not used hint:
Leading(("t1(t2" "t3)"))
duplication hint:
error hint:
                               QUERY PLAN                               
------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t3.val = t2.val)
         ->  Seq Scan on t3
         ->  Hash
               ->  Broadcast Motion 3:3  (slice2; segments: 3)
                     ->  Hash Join
                           Hash Cond: (t2.id = t1.id)
                           ->  Seq Scan on t2
                                 Filter: (id < 10)
                           ->  Hash
                                 ->  Bitmap Heap Scan on t1
                                       Recheck Cond: (id < 10)
                                       ->  Bitmap Index Scan on t1_pkey
                                             Index Cond: (id < 10)
 Optimizer: Postgres query optimizer
(16 rows)

/*+ Leading ( ( ( t1 t2 ) t3 ) ) */
EXPLAIN (COSTS false) SELECT * FROM t1, t2, t3 WHERE t1.id = t2.id AND t2.val = t3.val AND t1.id < 10;
LOG:  statement: /*+ Leading ( ( ( t1 t2 ) t3 ) ) */
EXPLAIN (COSTS false) SELECT * FROM t1, t2, t3 WHERE t1.id = t2.id AND t2.val = t3.val AND t1.id < 10;
WARNING:  "work_mem": setting is deprecated, and may be removed in a future release.
LOG:  pg_hint_plan:
used hint:
Leading(((t1 t2) t3))
not used hint:
duplication hint:
error hint:
                         QUERY PLAN                         
------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t2.val = t3.val)
         ->  Broadcast Motion 3:3  (slice2; segments: 3)
               ->  Hash Join
                     Hash Cond: (t1.id = t2.id)
                     ->  Bitmap Heap Scan on t1
                           Recheck Cond: (id < 10)
                           ->  Bitmap Index Scan on t1_pkey
                                 Index Cond: (id < 10)
                     ->  Hash
                           ->  Seq Scan on t2
                                 Filter: (id < 10)
         ->  Hash
               ->  Seq Scan on t3
 Optimizer: Postgres query optimizer
(16 rows)

/*+Leading(((t1 t2)t3))*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2, t3 WHERE t1.id = t2.id AND t2.val = t3.val AND t1.id < 10;
LOG:  statement: /*+Leading(((t1 t2)t3))*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2, t3 WHERE t1.id = t2.id AND t2.val = t3.val AND t1.id < 10;
WARNING:  "work_mem": setting is deprecated, and may be removed in a future release.
LOG:  pg_hint_plan:
used hint:
Leading(((t1 t2) t3))
not used hint:
duplication hint:
error hint:
                         QUERY PLAN                         
------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t2.val = t3.val)
         ->  Broadcast Motion 3:3  (slice2; segments: 3)
               ->  Hash Join
                     Hash Cond: (t1.id = t2.id)
                     ->  Bitmap Heap Scan on t1
                           Recheck Cond: (id < 10)
                           ->  Bitmap Index Scan on t1_pkey
                                 Index Cond: (id < 10)
                     ->  Hash
                           ->  Seq Scan on t2
                                 Filter: (id < 10)
         ->  Hash
               ->  Seq Scan on t3
 Optimizer: Postgres query optimizer
(16 rows)

/*+Leading(("(t1" "t2)t3"))*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2, t3 WHERE t1.id = t2.id AND t2.val = t3.val AND t1.id < 10;
LOG:  statement: /*+Leading(("(t1" "t2)t3"))*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2, t3 WHERE t1.id = t2.id AND t2.val = t3.val AND t1.id < 10;
LOG:  pg_hint_plan:
used hint:
not used hint:
Leading(("(t1" "t2)t3"))
duplication hint:
error hint:
                               QUERY PLAN                               
------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t3.val = t2.val)
         ->  Seq Scan on t3
         ->  Hash
               ->  Broadcast Motion 3:3  (slice2; segments: 3)
                     ->  Hash Join
                           Hash Cond: (t2.id = t1.id)
                           ->  Seq Scan on t2
                                 Filter: (id < 10)
                           ->  Hash
                                 ->  Bitmap Heap Scan on t1
                                       Recheck Cond: (id < 10)
                                       ->  Bitmap Index Scan on t1_pkey
                                             Index Cond: (id < 10)
 Optimizer: Postgres query optimizer
(16 rows)

/*+Leading((t1(t2(t3(t4 t5)))))*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2, t3, t4, t5 WHERE t1.id = t2.id AND t1.id = t3.id AND t1.id = t4.id AND t1.id = t5.id;
LOG:  statement: /*+Leading((t1(t2(t3(t4 t5)))))*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2, t3, t4, t5 WHERE t1.id = t2.id AND t1.id = t3.id AND t1.id = t4.id AND t1.id = t5.id;
WARNING:  "work_mem": setting is deprecated, and may be removed in a future release.
LOG:  pg_hint_plan:
used hint:
Leading((t1 (t2 (t3 (t4 t5)))))
not used hint:
duplication hint:
error hint:
                               QUERY PLAN                               
------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t1.id = t2.id)
         ->  Seq Scan on t1
         ->  Hash
               ->  Hash Join
                     Hash Cond: (t2.id = t3.id)
                     ->  Seq Scan on t2
                     ->  Hash
                           ->  Hash Join
                                 Hash Cond: (t3.id = t4.id)
                                 ->  Seq Scan on t3
                                 ->  Hash
                                       ->  Hash Join
                                             Hash Cond: (t4.id = t5.id)
                                             ->  Seq Scan on t4
                                             ->  Hash
                                                   ->  Seq Scan on t5
 Optimizer: Postgres query optimizer
(19 rows)

/*+Leading((t5(t4(t3(t2 t1)))))*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2, t3, t4, t5 WHERE t1.id = t2.id AND t1.id = t3.id AND t1.id = t4.id AND t1.id = t5.id;
LOG:  statement: /*+Leading((t5(t4(t3(t2 t1)))))*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2, t3, t4, t5 WHERE t1.id = t2.id AND t1.id = t3.id AND t1.id = t4.id AND t1.id = t5.id;
WARNING:  "work_mem": setting is deprecated, and may be removed in a future release.
LOG:  pg_hint_plan:
used hint:
Leading((t5 (t4 (t3 (t2 t1)))))
not used hint:
duplication hint:
error hint:
                               QUERY PLAN                               
------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t5.id = t1.id)
         ->  Seq Scan on t5
         ->  Hash
               ->  Hash Join
                     Hash Cond: (t4.id = t1.id)
                     ->  Seq Scan on t4
                     ->  Hash
                           ->  Hash Join
                                 Hash Cond: (t3.id = t1.id)
                                 ->  Seq Scan on t3
                                 ->  Hash
                                       ->  Hash Join
                                             Hash Cond: (t2.id = t1.id)
                                             ->  Seq Scan on t2
                                             ->  Hash
                                                   ->  Seq Scan on t1
 Optimizer: Postgres query optimizer
(19 rows)

/*+Leading(((((t1 t2)t3)t4)t5))*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2, t3, t4, t5 WHERE t1.id = t2.id AND t1.id = t3.id AND t1.id = t4.id AND t1.id = t5.id;
LOG:  statement: /*+Leading(((((t1 t2)t3)t4)t5))*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2, t3, t4, t5 WHERE t1.id = t2.id AND t1.id = t3.id AND t1.id = t4.id AND t1.id = t5.id;
WARNING:  "work_mem": setting is deprecated, and may be removed in a future release.
LOG:  pg_hint_plan:
used hint:
Leading(((((t1 t2) t3) t4) t5))
not used hint:
duplication hint:
error hint:
                      QUERY PLAN                      
------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t1.id = t5.id)
         ->  Hash Join
               Hash Cond: (t1.id = t4.id)
               ->  Hash Join
                     Hash Cond: (t1.id = t3.id)
                     ->  Hash Join
                           Hash Cond: (t1.id = t2.id)
                           ->  Seq Scan on t1
                           ->  Hash
                                 ->  Seq Scan on t2
                     ->  Hash
                           ->  Seq Scan on t3
               ->  Hash
                     ->  Seq Scan on t4
         ->  Hash
               ->  Seq Scan on t5
 Optimizer: Postgres query optimizer
(19 rows)

/*+Leading(((((t5 t4)t3)t2)t1))*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2, t3, t4, t5 WHERE t1.id = t2.id AND t1.id = t3.id AND t1.id = t4.id AND t1.id = t5.id;
LOG:  statement: /*+Leading(((((t5 t4)t3)t2)t1))*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2, t3, t4, t5 WHERE t1.id = t2.id AND t1.id = t3.id AND t1.id = t4.id AND t1.id = t5.id;
WARNING:  "work_mem": setting is deprecated, and may be removed in a future release.
LOG:  pg_hint_plan:
used hint:
Leading(((((t5 t4) t3) t2) t1))
not used hint:
duplication hint:
error hint:
                      QUERY PLAN                      
------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t2.id = t1.id)
         ->  Hash Join
               Hash Cond: (t3.id = t2.id)
               ->  Hash Join
                     Hash Cond: (t4.id = t3.id)
                     ->  Hash Join
                           Hash Cond: (t5.id = t4.id)
                           ->  Seq Scan on t5
                           ->  Hash
                                 ->  Seq Scan on t4
                     ->  Hash
                           ->  Seq Scan on t3
               ->  Hash
                     ->  Seq Scan on t2
         ->  Hash
               ->  Seq Scan on t1
 Optimizer: Postgres query optimizer
(19 rows)

/*+Leading(((t1 t2)(t3(t4 t5))))*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2, t3, t4, t5 WHERE t1.id = t2.id AND t1.id = t3.id AND t1.id = t4.id AND t1.id = t5.id;
LOG:  statement: /*+Leading(((t1 t2)(t3(t4 t5))))*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2, t3, t4, t5 WHERE t1.id = t2.id AND t1.id = t3.id AND t1.id = t4.id AND t1.id = t5.id;
WARNING:  "work_mem": setting is deprecated, and may be removed in a future release.
LOG:  pg_hint_plan:
used hint:
Leading(((t1 t2) (t3 (t4 t5))))
not used hint:
duplication hint:
error hint:
                         QUERY PLAN                         
------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t1.id = t3.id)
         ->  Hash Join
               Hash Cond: (t1.id = t2.id)
               ->  Seq Scan on t1
               ->  Hash
                     ->  Seq Scan on t2
         ->  Hash
               ->  Hash Join
                     Hash Cond: (t3.id = t4.id)
                     ->  Seq Scan on t3
                     ->  Hash
                           ->  Hash Join
                                 Hash Cond: (t4.id = t5.id)
                                 ->  Seq Scan on t4
                                 ->  Hash
                                       ->  Seq Scan on t5
 Optimizer: Postgres query optimizer
(19 rows)

/*+Leading(((t5 t4)(t3(t2 t1))))*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2, t3, t4, t5 WHERE t1.id = t2.id AND t1.id = t3.id AND t1.id = t4.id AND t1.id = t5.id;
LOG:  statement: /*+Leading(((t5 t4)(t3(t2 t1))))*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2, t3, t4, t5 WHERE t1.id = t2.id AND t1.id = t3.id AND t1.id = t4.id AND t1.id = t5.id;
WARNING:  "work_mem": setting is deprecated, and may be removed in a future release.
LOG:  pg_hint_plan:
used hint:
Leading(((t5 t4) (t3 (t2 t1))))
not used hint:
duplication hint:
error hint:
                         QUERY PLAN                         
------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t4.id = t1.id)
         ->  Hash Join
               Hash Cond: (t5.id = t4.id)
               ->  Seq Scan on t5
               ->  Hash
                     ->  Seq Scan on t4
         ->  Hash
               ->  Hash Join
                     Hash Cond: (t3.id = t1.id)
                     ->  Seq Scan on t3
                     ->  Hash
                           ->  Hash Join
                                 Hash Cond: (t2.id = t1.id)
                                 ->  Seq Scan on t2
                                 ->  Hash
                                       ->  Seq Scan on t1
 Optimizer: Postgres query optimizer
(19 rows)

/*+Leading((((t1 t2)t3)(t4 t5)))*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2, t3, t4, t5 WHERE t1.id = t2.id AND t1.id = t3.id AND t1.id = t4.id AND t1.id = t5.id;
LOG:  statement: /*+Leading((((t1 t2)t3)(t4 t5)))*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2, t3, t4, t5 WHERE t1.id = t2.id AND t1.id = t3.id AND t1.id = t4.id AND t1.id = t5.id;
WARNING:  "work_mem": setting is deprecated, and may be removed in a future release.
LOG:  pg_hint_plan:
used hint:
Leading((((t1 t2) t3) (t4 t5)))
not used hint:
duplication hint:
error hint:
                   QUERY PLAN                   
------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t1.id = t4.id)
         ->  Hash Join
               Hash Cond: (t1.id = t3.id)
               ->  Hash Join
                     Hash Cond: (t1.id = t2.id)
                     ->  Seq Scan on t1
                     ->  Hash
                           ->  Seq Scan on t2
               ->  Hash
                     ->  Seq Scan on t3
         ->  Hash
               ->  Hash Join
                     Hash Cond: (t4.id = t5.id)
                     ->  Seq Scan on t4
                     ->  Hash
                           ->  Seq Scan on t5
 Optimizer: Postgres query optimizer
(19 rows)

/*+Leading((((t5 t4)t3)(t2 t1)))*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2, t3, t4, t5 WHERE t1.id = t2.id AND t1.id = t3.id AND t1.id = t4.id AND t1.id = t5.id;
LOG:  statement: /*+Leading((((t5 t4)t3)(t2 t1)))*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2, t3, t4, t5 WHERE t1.id = t2.id AND t1.id = t3.id AND t1.id = t4.id AND t1.id = t5.id;
WARNING:  "work_mem": setting is deprecated, and may be removed in a future release.
LOG:  pg_hint_plan:
used hint:
Leading((((t5 t4) t3) (t2 t1)))
not used hint:
duplication hint:
error hint:
                   QUERY PLAN                   
------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t3.id = t1.id)
         ->  Hash Join
               Hash Cond: (t4.id = t3.id)
               ->  Hash Join
                     Hash Cond: (t5.id = t4.id)
                     ->  Seq Scan on t5
                     ->  Hash
                           ->  Seq Scan on t4
               ->  Hash
                     ->  Seq Scan on t3
         ->  Hash
               ->  Hash Join
                     Hash Cond: (t2.id = t1.id)
                     ->  Seq Scan on t2
                     ->  Hash
                           ->  Seq Scan on t1
 Optimizer: Postgres query optimizer
(19 rows)

-- inherite table test to specify the index's name
EXPLAIN (COSTS false) SELECT * FROM p2 WHERE id >= 50 AND id <= 51 AND p2.ctid = '(1,1)';
LOG:  statement: EXPLAIN (COSTS false) SELECT * FROM p2 WHERE id >= 50 AND id <= 51 AND p2.ctid = '(1,1)';
NOTICE:  SELECT uses system-defined column "p2.ctid" without the necessary companion column "p2.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
                                 QUERY PLAN                                  
-----------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Append
         ->  Seq Scan on p2
               Filter: ((id >= 50) AND (id <= 51) AND (ctid = '(1,1)'::tid))
         ->  Seq Scan on p2_c1
               Filter: ((id >= 50) AND (id <= 51) AND (ctid = '(1,1)'::tid))
         ->  Seq Scan on p2_c1_c1
               Filter: ((id >= 50) AND (id <= 51) AND (ctid = '(1,1)'::tid))
         ->  Seq Scan on p2_c1_c2
               Filter: ((id >= 50) AND (id <= 51) AND (ctid = '(1,1)'::tid))
 Optimizer: Postgres query optimizer
(11 rows)

/*+IndexScan(p2 p2_pkey)*/
EXPLAIN (COSTS false) SELECT * FROM p2 WHERE id >= 50 AND id <= 51 AND p2.ctid = '(1,1)';
LOG:  statement: /*+IndexScan(p2 p2_pkey)*/
EXPLAIN (COSTS false) SELECT * FROM p2 WHERE id >= 50 AND id <= 51 AND p2.ctid = '(1,1)';
NOTICE:  SELECT uses system-defined column "p2.ctid" without the necessary companion column "p2.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  available indexes for IndexScan(p2): p2_pkey
LOG:  available indexes for IndexScan(p2_c1): p2_c1_pkey
LOG:  available indexes for IndexScan(p2_c1_c1): p2_c1_c1_pkey
LOG:  available indexes for IndexScan(p2_c1_c2): p2_c1_c2_pkey
LOG:  pg_hint_plan:
used hint:
IndexScan(p2 p2_pkey)
not used hint:
duplication hint:
error hint:
                       QUERY PLAN                       
--------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Append
         ->  Index Scan using p2_pkey on p2
               Index Cond: ((id >= 50) AND (id <= 51))
               Filter: (ctid = '(1,1)'::tid)
         ->  Index Scan using p2_c1_pkey on p2_c1
               Index Cond: ((id >= 50) AND (id <= 51))
               Filter: (ctid = '(1,1)'::tid)
         ->  Index Scan using p2_c1_c1_pkey on p2_c1_c1
               Index Cond: ((id >= 50) AND (id <= 51))
               Filter: (ctid = '(1,1)'::tid)
         ->  Index Scan using p2_c1_c2_pkey on p2_c1_c2
               Index Cond: ((id >= 50) AND (id <= 51))
               Filter: (ctid = '(1,1)'::tid)
 Optimizer: Postgres query optimizer
(15 rows)

/*+IndexScan(p2 p2_id_val_idx)*/
EXPLAIN (COSTS false) SELECT * FROM p2 WHERE id >= 50 AND id <= 51 AND p2.ctid = '(1,1)';
LOG:  statement: /*+IndexScan(p2 p2_id_val_idx)*/
EXPLAIN (COSTS false) SELECT * FROM p2 WHERE id >= 50 AND id <= 51 AND p2.ctid = '(1,1)';
NOTICE:  SELECT uses system-defined column "p2.ctid" without the necessary companion column "p2.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  available indexes for IndexScan(p2): p2_id_val_idx
LOG:  available indexes for IndexScan(p2_c1): p2_c1_id_val_idx
LOG:  available indexes for IndexScan(p2_c1_c1): p2_c1_c1_id_val_idx
LOG:  available indexes for IndexScan(p2_c1_c2): p2_c1_c2_id_val_idx
LOG:  pg_hint_plan:
used hint:
IndexScan(p2 p2_id_val_idx)
not used hint:
duplication hint:
error hint:
                          QUERY PLAN                          
--------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Append
         ->  Index Scan using p2_id_val_idx on p2
               Index Cond: ((id >= 50) AND (id <= 51))
               Filter: (ctid = '(1,1)'::tid)
         ->  Index Scan using p2_c1_id_val_idx on p2_c1
               Index Cond: ((id >= 50) AND (id <= 51))
               Filter: (ctid = '(1,1)'::tid)
         ->  Index Scan using p2_c1_c1_id_val_idx on p2_c1_c1
               Index Cond: ((id >= 50) AND (id <= 51))
               Filter: (ctid = '(1,1)'::tid)
         ->  Index Scan using p2_c1_c2_id_val_idx on p2_c1_c2
               Index Cond: ((id >= 50) AND (id <= 51))
               Filter: (ctid = '(1,1)'::tid)
 Optimizer: Postgres query optimizer
(15 rows)

/*+IndexScan(p2 p2_val_id_idx)*/
EXPLAIN (COSTS false) SELECT * FROM p2 WHERE id >= 50 AND id <= 51 AND p2.ctid = '(1,1)';
LOG:  statement: /*+IndexScan(p2 p2_val_id_idx)*/
EXPLAIN (COSTS false) SELECT * FROM p2 WHERE id >= 50 AND id <= 51 AND p2.ctid = '(1,1)';
NOTICE:  SELECT uses system-defined column "p2.ctid" without the necessary companion column "p2.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  available indexes for IndexScan(p2): p2_val_id_idx
LOG:  available indexes for IndexScan(p2_c1): p2_c1_val_id_idx
LOG:  available indexes for IndexScan(p2_c1_c1): p2_c1_c1_val_id_idx
LOG:  available indexes for IndexScan(p2_c1_c2): p2_c1_c2_val_id_idx
LOG:  pg_hint_plan:
used hint:
IndexScan(p2 p2_val_id_idx)
not used hint:
duplication hint:
error hint:
                          QUERY PLAN                          
--------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Append
         ->  Index Scan using p2_val_id_idx on p2
               Index Cond: ((id >= 50) AND (id <= 51))
               Filter: (ctid = '(1,1)'::tid)
         ->  Index Scan using p2_c1_val_id_idx on p2_c1
               Index Cond: ((id >= 50) AND (id <= 51))
               Filter: (ctid = '(1,1)'::tid)
         ->  Index Scan using p2_c1_c1_val_id_idx on p2_c1_c1
               Index Cond: ((id >= 50) AND (id <= 51))
               Filter: (ctid = '(1,1)'::tid)
         ->  Index Scan using p2_c1_c2_val_id_idx on p2_c1_c2
               Index Cond: ((id >= 50) AND (id <= 51))
               Filter: (ctid = '(1,1)'::tid)
 Optimizer: Postgres query optimizer
(15 rows)

EXPLAIN (COSTS false) SELECT val FROM p2 WHERE val >= '50' AND val <= '51' AND p2.ctid = '(1,1)';
LOG:  statement: EXPLAIN (COSTS false) SELECT val FROM p2 WHERE val >= '50' AND val <= '51' AND p2.ctid = '(1,1)';
NOTICE:  SELECT uses system-defined column "p2.ctid" without the necessary companion column "p2.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
                                          QUERY PLAN                                           
-----------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Append
         ->  Seq Scan on p2
               Filter: ((val >= '50'::text) AND (val <= '51'::text) AND (ctid = '(1,1)'::tid))
         ->  Seq Scan on p2_c1
               Filter: ((val >= '50'::text) AND (val <= '51'::text) AND (ctid = '(1,1)'::tid))
         ->  Seq Scan on p2_c2
               Filter: ((val >= '50'::text) AND (val <= '51'::text) AND (ctid = '(1,1)'::tid))
         ->  Seq Scan on p2_c3
               Filter: ((val >= '50'::text) AND (val <= '51'::text) AND (ctid = '(1,1)'::tid))
         ->  Seq Scan on p2_c4
               Filter: ((val >= '50'::text) AND (val <= '51'::text) AND (ctid = '(1,1)'::tid))
         ->  Seq Scan on p2_c1_c1
               Filter: ((val >= '50'::text) AND (val <= '51'::text) AND (ctid = '(1,1)'::tid))
         ->  Seq Scan on p2_c1_c2
               Filter: ((val >= '50'::text) AND (val <= '51'::text) AND (ctid = '(1,1)'::tid))
         ->  Seq Scan on p2_c3_c1
               Filter: ((val >= '50'::text) AND (val <= '51'::text) AND (ctid = '(1,1)'::tid))
         ->  Seq Scan on p2_c3_c2
               Filter: ((val >= '50'::text) AND (val <= '51'::text) AND (ctid = '(1,1)'::tid))
 Optimizer: Postgres query optimizer
(21 rows)

-- Inhibit parallel exection to avoid interfaring the hint
set max_parallel_workers_per_gather to 0;
LOG:  statement: set max_parallel_workers_per_gather to 0;
/*+ IndexScan(p2 p2_val)*/
EXPLAIN (COSTS false) SELECT val FROM p2 WHERE val >= '50' AND val <= '51' AND p2.ctid = '(1,1)';
LOG:  statement: /*+ IndexScan(p2 p2_val)*/
EXPLAIN (COSTS false) SELECT val FROM p2 WHERE val >= '50' AND val <= '51' AND p2.ctid = '(1,1)';
NOTICE:  SELECT uses system-defined column "p2.ctid" without the necessary companion column "p2.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  available indexes for IndexScan(p2):
LOG:  available indexes for IndexScan(p2_c1):
LOG:  available indexes for IndexScan(p2_c2):
LOG:  available indexes for IndexScan(p2_c3):
LOG:  available indexes for IndexScan(p2_c4):
LOG:  available indexes for IndexScan(p2_c1_c1):
LOG:  available indexes for IndexScan(p2_c1_c2):
LOG:  available indexes for IndexScan(p2_c3_c1):
LOG:  available indexes for IndexScan(p2_c3_c2):
LOG:  pg_hint_plan:
used hint:
IndexScan(p2 p2_val)
not used hint:
duplication hint:
error hint:
                                          QUERY PLAN                                           
-----------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Append
         ->  Seq Scan on p2
               Filter: ((val >= '50'::text) AND (val <= '51'::text) AND (ctid = '(1,1)'::tid))
         ->  Seq Scan on p2_c1
               Filter: ((val >= '50'::text) AND (val <= '51'::text) AND (ctid = '(1,1)'::tid))
         ->  Seq Scan on p2_c2
               Filter: ((val >= '50'::text) AND (val <= '51'::text) AND (ctid = '(1,1)'::tid))
         ->  Seq Scan on p2_c3
               Filter: ((val >= '50'::text) AND (val <= '51'::text) AND (ctid = '(1,1)'::tid))
         ->  Seq Scan on p2_c4
               Filter: ((val >= '50'::text) AND (val <= '51'::text) AND (ctid = '(1,1)'::tid))
         ->  Seq Scan on p2_c1_c1
               Filter: ((val >= '50'::text) AND (val <= '51'::text) AND (ctid = '(1,1)'::tid))
         ->  Seq Scan on p2_c1_c2
               Filter: ((val >= '50'::text) AND (val <= '51'::text) AND (ctid = '(1,1)'::tid))
         ->  Seq Scan on p2_c3_c1
               Filter: ((val >= '50'::text) AND (val <= '51'::text) AND (ctid = '(1,1)'::tid))
         ->  Seq Scan on p2_c3_c2
               Filter: ((val >= '50'::text) AND (val <= '51'::text) AND (ctid = '(1,1)'::tid))
 Optimizer: Postgres query optimizer
(21 rows)

/*+IndexScan(p2 p2_pkey)*/
EXPLAIN (COSTS false) SELECT * FROM p2 WHERE id >= 50 AND id <= 51 AND p2.ctid = '(1,1)';
LOG:  statement: /*+IndexScan(p2 p2_pkey)*/
EXPLAIN (COSTS false) SELECT * FROM p2 WHERE id >= 50 AND id <= 51 AND p2.ctid = '(1,1)';
NOTICE:  SELECT uses system-defined column "p2.ctid" without the necessary companion column "p2.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  available indexes for IndexScan(p2): p2_pkey
LOG:  available indexes for IndexScan(p2_c1): p2_c1_pkey
LOG:  available indexes for IndexScan(p2_c1_c1): p2_c1_c1_pkey
LOG:  available indexes for IndexScan(p2_c1_c2): p2_c1_c2_pkey
LOG:  pg_hint_plan:
used hint:
IndexScan(p2 p2_pkey)
not used hint:
duplication hint:
error hint:
                       QUERY PLAN                       
--------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Append
         ->  Index Scan using p2_pkey on p2
               Index Cond: ((id >= 50) AND (id <= 51))
               Filter: (ctid = '(1,1)'::tid)
         ->  Index Scan using p2_c1_pkey on p2_c1
               Index Cond: ((id >= 50) AND (id <= 51))
               Filter: (ctid = '(1,1)'::tid)
         ->  Index Scan using p2_c1_c1_pkey on p2_c1_c1
               Index Cond: ((id >= 50) AND (id <= 51))
               Filter: (ctid = '(1,1)'::tid)
         ->  Index Scan using p2_c1_c2_pkey on p2_c1_c2
               Index Cond: ((id >= 50) AND (id <= 51))
               Filter: (ctid = '(1,1)'::tid)
 Optimizer: Postgres query optimizer
(15 rows)

/*+IndexScan(p2 p2_id2_val)*/
EXPLAIN (COSTS false) SELECT * FROM p2 WHERE id >= 50 AND id <= 51 AND p2.ctid = '(1,1)';
LOG:  statement: /*+IndexScan(p2 p2_id2_val)*/
EXPLAIN (COSTS false) SELECT * FROM p2 WHERE id >= 50 AND id <= 51 AND p2.ctid = '(1,1)';
NOTICE:  SELECT uses system-defined column "p2.ctid" without the necessary companion column "p2.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  available indexes for IndexScan(p2): p2_id2_val
LOG:  available indexes for IndexScan(p2_c1): p2_c1_id2_val
LOG:  available indexes for IndexScan(p2_c1_c1):
LOG:  available indexes for IndexScan(p2_c1_c2):
LOG:  pg_hint_plan:
used hint:
IndexScan(p2 p2_id2_val)
not used hint:
duplication hint:
error hint:
                                 QUERY PLAN                                  
-----------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Append
         ->  Index Scan using p2_id2_val on p2
               Index Cond: ((id >= 50) AND (id <= 51))
               Filter: (ctid = '(1,1)'::tid)
         ->  Index Scan using p2_c1_id2_val on p2_c1
               Index Cond: ((id >= 50) AND (id <= 51))
               Filter: (ctid = '(1,1)'::tid)
         ->  Seq Scan on p2_c1_c1
               Filter: ((id >= 50) AND (id <= 51) AND (ctid = '(1,1)'::tid))
         ->  Seq Scan on p2_c1_c2
               Filter: ((id >= 50) AND (id <= 51) AND (ctid = '(1,1)'::tid))
 Optimizer: Postgres query optimizer
(13 rows)

/*+IndexScan(p2 p2_val2_id)*/
EXPLAIN (COSTS false) SELECT * FROM p2 WHERE id >= 50 AND id <= 51 AND p2.ctid = '(1,1)';
LOG:  statement: /*+IndexScan(p2 p2_val2_id)*/
EXPLAIN (COSTS false) SELECT * FROM p2 WHERE id >= 50 AND id <= 51 AND p2.ctid = '(1,1)';
NOTICE:  SELECT uses system-defined column "p2.ctid" without the necessary companion column "p2.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  available indexes for IndexScan(p2): p2_val2_id
LOG:  available indexes for IndexScan(p2_c1):
LOG:  available indexes for IndexScan(p2_c1_c1):
LOG:  available indexes for IndexScan(p2_c1_c2):
LOG:  pg_hint_plan:
used hint:
IndexScan(p2 p2_val2_id)
not used hint:
duplication hint:
error hint:
                                 QUERY PLAN                                  
-----------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Append
         ->  Index Scan using p2_val2_id on p2
               Index Cond: ((id >= 50) AND (id <= 51))
               Filter: (ctid = '(1,1)'::tid)
         ->  Seq Scan on p2_c1
               Filter: ((id >= 50) AND (id <= 51) AND (ctid = '(1,1)'::tid))
         ->  Seq Scan on p2_c1_c1
               Filter: ((id >= 50) AND (id <= 51) AND (ctid = '(1,1)'::tid))
         ->  Seq Scan on p2_c1_c2
               Filter: ((id >= 50) AND (id <= 51) AND (ctid = '(1,1)'::tid))
 Optimizer: Postgres query optimizer
(12 rows)

/*+IndexScan(p2 p2_pkey)*/
EXPLAIN (COSTS false) SELECT * FROM p2 WHERE id >= 50 AND id <= 51 AND p2.ctid = '(1,1)';
LOG:  statement: /*+IndexScan(p2 p2_pkey)*/
EXPLAIN (COSTS false) SELECT * FROM p2 WHERE id >= 50 AND id <= 51 AND p2.ctid = '(1,1)';
NOTICE:  SELECT uses system-defined column "p2.ctid" without the necessary companion column "p2.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  available indexes for IndexScan(p2): p2_pkey
LOG:  available indexes for IndexScan(p2_c1): p2_c1_pkey
LOG:  available indexes for IndexScan(p2_c1_c1): p2_c1_c1_pkey
LOG:  available indexes for IndexScan(p2_c1_c2): p2_c1_c2_pkey
LOG:  pg_hint_plan:
used hint:
IndexScan(p2 p2_pkey)
not used hint:
duplication hint:
error hint:
                       QUERY PLAN                       
--------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Append
         ->  Index Scan using p2_pkey on p2
               Index Cond: ((id >= 50) AND (id <= 51))
               Filter: (ctid = '(1,1)'::tid)
         ->  Index Scan using p2_c1_pkey on p2_c1
               Index Cond: ((id >= 50) AND (id <= 51))
               Filter: (ctid = '(1,1)'::tid)
         ->  Index Scan using p2_c1_c1_pkey on p2_c1_c1
               Index Cond: ((id >= 50) AND (id <= 51))
               Filter: (ctid = '(1,1)'::tid)
         ->  Index Scan using p2_c1_c2_pkey on p2_c1_c2
               Index Cond: ((id >= 50) AND (id <= 51))
               Filter: (ctid = '(1,1)'::tid)
 Optimizer: Postgres query optimizer
(15 rows)

/*+IndexScan(p2 p2_c1_id_val_idx)*/
EXPLAIN (COSTS false) SELECT * FROM p2 WHERE id >= 50 AND id <= 51 AND p2.ctid = '(1,1)';
LOG:  statement: /*+IndexScan(p2 p2_c1_id_val_idx)*/
EXPLAIN (COSTS false) SELECT * FROM p2 WHERE id >= 50 AND id <= 51 AND p2.ctid = '(1,1)';
NOTICE:  SELECT uses system-defined column "p2.ctid" without the necessary companion column "p2.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  available indexes for IndexScan(p2):
LOG:  available indexes for IndexScan(p2_c1): p2_c1_id_val_idx
LOG:  available indexes for IndexScan(p2_c1_c1):
LOG:  available indexes for IndexScan(p2_c1_c2):
LOG:  pg_hint_plan:
used hint:
IndexScan(p2 p2_c1_id_val_idx)
not used hint:
duplication hint:
error hint:
                                 QUERY PLAN                                  
-----------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Append
         ->  Seq Scan on p2
               Filter: ((id >= 50) AND (id <= 51) AND (ctid = '(1,1)'::tid))
         ->  Index Scan using p2_c1_id_val_idx on p2_c1
               Index Cond: ((id >= 50) AND (id <= 51))
               Filter: (ctid = '(1,1)'::tid)
         ->  Seq Scan on p2_c1_c1
               Filter: ((id >= 50) AND (id <= 51) AND (ctid = '(1,1)'::tid))
         ->  Seq Scan on p2_c1_c2
               Filter: ((id >= 50) AND (id <= 51) AND (ctid = '(1,1)'::tid))
 Optimizer: Postgres query optimizer
(12 rows)

/*+IndexScan(p2 no_exist)*/
EXPLAIN (COSTS false) SELECT * FROM p2 WHERE id >= 50 AND id <= 51 AND p2.ctid = '(1,1)';
LOG:  statement: /*+IndexScan(p2 no_exist)*/
EXPLAIN (COSTS false) SELECT * FROM p2 WHERE id >= 50 AND id <= 51 AND p2.ctid = '(1,1)';
NOTICE:  SELECT uses system-defined column "p2.ctid" without the necessary companion column "p2.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  available indexes for IndexScan(p2):
LOG:  available indexes for IndexScan(p2_c1):
LOG:  available indexes for IndexScan(p2_c1_c1):
LOG:  available indexes for IndexScan(p2_c1_c2):
LOG:  pg_hint_plan:
used hint:
IndexScan(p2 no_exist)
not used hint:
duplication hint:
error hint:
                                 QUERY PLAN                                  
-----------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Append
         ->  Seq Scan on p2
               Filter: ((id >= 50) AND (id <= 51) AND (ctid = '(1,1)'::tid))
         ->  Seq Scan on p2_c1
               Filter: ((id >= 50) AND (id <= 51) AND (ctid = '(1,1)'::tid))
         ->  Seq Scan on p2_c1_c1
               Filter: ((id >= 50) AND (id <= 51) AND (ctid = '(1,1)'::tid))
         ->  Seq Scan on p2_c1_c2
               Filter: ((id >= 50) AND (id <= 51) AND (ctid = '(1,1)'::tid))
 Optimizer: Postgres query optimizer
(11 rows)

/*+IndexScan(p2 p2_pkey p2_c1_id_val_idx)*/
EXPLAIN (COSTS false) SELECT * FROM p2 WHERE id >= 50 AND id <= 51 AND p2.ctid = '(1,1)';
LOG:  statement: /*+IndexScan(p2 p2_pkey p2_c1_id_val_idx)*/
EXPLAIN (COSTS false) SELECT * FROM p2 WHERE id >= 50 AND id <= 51 AND p2.ctid = '(1,1)';
NOTICE:  SELECT uses system-defined column "p2.ctid" without the necessary companion column "p2.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  available indexes for IndexScan(p2): p2_pkey
LOG:  available indexes for IndexScan(p2_c1): p2_c1_id_val_idx p2_c1_pkey
LOG:  available indexes for IndexScan(p2_c1_c1): p2_c1_c1_pkey
LOG:  available indexes for IndexScan(p2_c1_c2): p2_c1_c2_pkey
LOG:  pg_hint_plan:
used hint:
IndexScan(p2 p2_pkey p2_c1_id_val_idx)
not used hint:
duplication hint:
error hint:
                       QUERY PLAN                       
--------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Append
         ->  Index Scan using p2_pkey on p2
               Index Cond: ((id >= 50) AND (id <= 51))
               Filter: (ctid = '(1,1)'::tid)
         ->  Index Scan using p2_c1_id_val_idx on p2_c1
               Index Cond: ((id >= 50) AND (id <= 51))
               Filter: (ctid = '(1,1)'::tid)
         ->  Index Scan using p2_c1_c1_pkey on p2_c1_c1
               Index Cond: ((id >= 50) AND (id <= 51))
               Filter: (ctid = '(1,1)'::tid)
         ->  Index Scan using p2_c1_c2_pkey on p2_c1_c2
               Index Cond: ((id >= 50) AND (id <= 51))
               Filter: (ctid = '(1,1)'::tid)
 Optimizer: Postgres query optimizer
(15 rows)

/*+IndexScan(p2 p2_pkey no_exist)*/
EXPLAIN (COSTS false) SELECT * FROM p2 WHERE id >= 50 AND id <= 51 AND p2.ctid = '(1,1)';
LOG:  statement: /*+IndexScan(p2 p2_pkey no_exist)*/
EXPLAIN (COSTS false) SELECT * FROM p2 WHERE id >= 50 AND id <= 51 AND p2.ctid = '(1,1)';
NOTICE:  SELECT uses system-defined column "p2.ctid" without the necessary companion column "p2.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  available indexes for IndexScan(p2): p2_pkey
LOG:  available indexes for IndexScan(p2_c1): p2_c1_pkey
LOG:  available indexes for IndexScan(p2_c1_c1): p2_c1_c1_pkey
LOG:  available indexes for IndexScan(p2_c1_c2): p2_c1_c2_pkey
LOG:  pg_hint_plan:
used hint:
IndexScan(p2 p2_pkey no_exist)
not used hint:
duplication hint:
error hint:
                       QUERY PLAN                       
--------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Append
         ->  Index Scan using p2_pkey on p2
               Index Cond: ((id >= 50) AND (id <= 51))
               Filter: (ctid = '(1,1)'::tid)
         ->  Index Scan using p2_c1_pkey on p2_c1
               Index Cond: ((id >= 50) AND (id <= 51))
               Filter: (ctid = '(1,1)'::tid)
         ->  Index Scan using p2_c1_c1_pkey on p2_c1_c1
               Index Cond: ((id >= 50) AND (id <= 51))
               Filter: (ctid = '(1,1)'::tid)
         ->  Index Scan using p2_c1_c2_pkey on p2_c1_c2
               Index Cond: ((id >= 50) AND (id <= 51))
               Filter: (ctid = '(1,1)'::tid)
 Optimizer: Postgres query optimizer
(15 rows)

/*+IndexScan(p2 p2_c1_id_val_idx no_exist)*/
EXPLAIN (COSTS false) SELECT * FROM p2 WHERE id >= 50 AND id <= 51 AND p2.ctid = '(1,1)';
LOG:  statement: /*+IndexScan(p2 p2_c1_id_val_idx no_exist)*/
EXPLAIN (COSTS false) SELECT * FROM p2 WHERE id >= 50 AND id <= 51 AND p2.ctid = '(1,1)';
NOTICE:  SELECT uses system-defined column "p2.ctid" without the necessary companion column "p2.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  available indexes for IndexScan(p2):
LOG:  available indexes for IndexScan(p2_c1): p2_c1_id_val_idx
LOG:  available indexes for IndexScan(p2_c1_c1):
LOG:  available indexes for IndexScan(p2_c1_c2):
LOG:  pg_hint_plan:
used hint:
IndexScan(p2 p2_c1_id_val_idx no_exist)
not used hint:
duplication hint:
error hint:
                                 QUERY PLAN                                  
-----------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Append
         ->  Seq Scan on p2
               Filter: ((id >= 50) AND (id <= 51) AND (ctid = '(1,1)'::tid))
         ->  Index Scan using p2_c1_id_val_idx on p2_c1
               Index Cond: ((id >= 50) AND (id <= 51))
               Filter: (ctid = '(1,1)'::tid)
         ->  Seq Scan on p2_c1_c1
               Filter: ((id >= 50) AND (id <= 51) AND (ctid = '(1,1)'::tid))
         ->  Seq Scan on p2_c1_c2
               Filter: ((id >= 50) AND (id <= 51) AND (ctid = '(1,1)'::tid))
 Optimizer: Postgres query optimizer
(12 rows)

/*+IndexScan(p2 p2_pkey p2_c1_id_val_idx no_exist)*/
EXPLAIN (COSTS false) SELECT * FROM p2 WHERE id >= 50 AND id <= 51 AND p2.ctid = '(1,1)';
LOG:  statement: /*+IndexScan(p2 p2_pkey p2_c1_id_val_idx no_exist)*/
EXPLAIN (COSTS false) SELECT * FROM p2 WHERE id >= 50 AND id <= 51 AND p2.ctid = '(1,1)';
NOTICE:  SELECT uses system-defined column "p2.ctid" without the necessary companion column "p2.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  available indexes for IndexScan(p2): p2_pkey
LOG:  available indexes for IndexScan(p2_c1): p2_c1_id_val_idx p2_c1_pkey
LOG:  available indexes for IndexScan(p2_c1_c1): p2_c1_c1_pkey
LOG:  available indexes for IndexScan(p2_c1_c2): p2_c1_c2_pkey
LOG:  pg_hint_plan:
used hint:
IndexScan(p2 p2_pkey p2_c1_id_val_idx no_exist)
not used hint:
duplication hint:
error hint:
                       QUERY PLAN                       
--------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Append
         ->  Index Scan using p2_pkey on p2
               Index Cond: ((id >= 50) AND (id <= 51))
               Filter: (ctid = '(1,1)'::tid)
         ->  Index Scan using p2_c1_id_val_idx on p2_c1
               Index Cond: ((id >= 50) AND (id <= 51))
               Filter: (ctid = '(1,1)'::tid)
         ->  Index Scan using p2_c1_c1_pkey on p2_c1_c1
               Index Cond: ((id >= 50) AND (id <= 51))
               Filter: (ctid = '(1,1)'::tid)
         ->  Index Scan using p2_c1_c2_pkey on p2_c1_c2
               Index Cond: ((id >= 50) AND (id <= 51))
               Filter: (ctid = '(1,1)'::tid)
 Optimizer: Postgres query optimizer
(15 rows)

/*+IndexScan(p2 p2_val_idx)*/
EXPLAIN (COSTS false) SELECT val FROM p2 WHERE val >= '50' AND val <= '51' AND p2.ctid = '(1,1)';
LOG:  statement: /*+IndexScan(p2 p2_val_idx)*/
EXPLAIN (COSTS false) SELECT val FROM p2 WHERE val >= '50' AND val <= '51' AND p2.ctid = '(1,1)';
NOTICE:  SELECT uses system-defined column "p2.ctid" without the necessary companion column "p2.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  available indexes for IndexScan(p2):
LOG:  available indexes for IndexScan(p2_c1):
LOG:  available indexes for IndexScan(p2_c2):
LOG:  available indexes for IndexScan(p2_c3):
LOG:  available indexes for IndexScan(p2_c4):
LOG:  available indexes for IndexScan(p2_c1_c1):
LOG:  available indexes for IndexScan(p2_c1_c2):
LOG:  available indexes for IndexScan(p2_c3_c1):
LOG:  available indexes for IndexScan(p2_c3_c2):
LOG:  pg_hint_plan:
used hint:
IndexScan(p2 p2_val_idx)
not used hint:
duplication hint:
error hint:
                                          QUERY PLAN                                           
-----------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Append
         ->  Seq Scan on p2
               Filter: ((val >= '50'::text) AND (val <= '51'::text) AND (ctid = '(1,1)'::tid))
         ->  Seq Scan on p2_c1
               Filter: ((val >= '50'::text) AND (val <= '51'::text) AND (ctid = '(1,1)'::tid))
         ->  Seq Scan on p2_c2
               Filter: ((val >= '50'::text) AND (val <= '51'::text) AND (ctid = '(1,1)'::tid))
         ->  Seq Scan on p2_c3
               Filter: ((val >= '50'::text) AND (val <= '51'::text) AND (ctid = '(1,1)'::tid))
         ->  Seq Scan on p2_c4
               Filter: ((val >= '50'::text) AND (val <= '51'::text) AND (ctid = '(1,1)'::tid))
         ->  Seq Scan on p2_c1_c1
               Filter: ((val >= '50'::text) AND (val <= '51'::text) AND (ctid = '(1,1)'::tid))
         ->  Seq Scan on p2_c1_c2
               Filter: ((val >= '50'::text) AND (val <= '51'::text) AND (ctid = '(1,1)'::tid))
         ->  Seq Scan on p2_c3_c1
               Filter: ((val >= '50'::text) AND (val <= '51'::text) AND (ctid = '(1,1)'::tid))
         ->  Seq Scan on p2_c3_c2
               Filter: ((val >= '50'::text) AND (val <= '51'::text) AND (ctid = '(1,1)'::tid))
 Optimizer: Postgres query optimizer
(21 rows)

/*+IndexScan(p2 p2_expr)*/
EXPLAIN (COSTS false) SELECT val FROM p2 WHERE val >= '50' AND val <= '51' AND p2.ctid = '(1,1)';
LOG:  statement: /*+IndexScan(p2 p2_expr)*/
EXPLAIN (COSTS false) SELECT val FROM p2 WHERE val >= '50' AND val <= '51' AND p2.ctid = '(1,1)';
NOTICE:  SELECT uses system-defined column "p2.ctid" without the necessary companion column "p2.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  available indexes for IndexScan(p2): p2_expr
LOG:  available indexes for IndexScan(p2_c1): p2_c1_expr_idx
LOG:  available indexes for IndexScan(p2_c2): p2_c2_expr_idx
LOG:  available indexes for IndexScan(p2_c3): p2_c3_expr_idx
LOG:  available indexes for IndexScan(p2_c4): p2_c4_expr_idx
LOG:  available indexes for IndexScan(p2_c1_c1): p2_c1_c1_expr_idx
LOG:  available indexes for IndexScan(p2_c1_c2): p2_c1_c2_expr_idx
LOG:  available indexes for IndexScan(p2_c3_c1): p2_c3_c1_expr_idx
LOG:  available indexes for IndexScan(p2_c3_c2): p2_c3_c2_expr_idx
LOG:  pg_hint_plan:
used hint:
IndexScan(p2 p2_expr)
not used hint:
duplication hint:
error hint:
                                          QUERY PLAN                                           
-----------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Append
         ->  Seq Scan on p2
               Filter: ((val >= '50'::text) AND (val <= '51'::text) AND (ctid = '(1,1)'::tid))
         ->  Seq Scan on p2_c1
               Filter: ((val >= '50'::text) AND (val <= '51'::text) AND (ctid = '(1,1)'::tid))
         ->  Seq Scan on p2_c2
               Filter: ((val >= '50'::text) AND (val <= '51'::text) AND (ctid = '(1,1)'::tid))
         ->  Seq Scan on p2_c3
               Filter: ((val >= '50'::text) AND (val <= '51'::text) AND (ctid = '(1,1)'::tid))
         ->  Seq Scan on p2_c4
               Filter: ((val >= '50'::text) AND (val <= '51'::text) AND (ctid = '(1,1)'::tid))
         ->  Seq Scan on p2_c1_c1
               Filter: ((val >= '50'::text) AND (val <= '51'::text) AND (ctid = '(1,1)'::tid))
         ->  Seq Scan on p2_c1_c2
               Filter: ((val >= '50'::text) AND (val <= '51'::text) AND (ctid = '(1,1)'::tid))
         ->  Seq Scan on p2_c3_c1
               Filter: ((val >= '50'::text) AND (val <= '51'::text) AND (ctid = '(1,1)'::tid))
         ->  Seq Scan on p2_c3_c2
               Filter: ((val >= '50'::text) AND (val <= '51'::text) AND (ctid = '(1,1)'::tid))
 Optimizer: Postgres query optimizer
(21 rows)

/*+IndexScan(p2 p2_val_idx6)*/
EXPLAIN (COSTS false) SELECT val FROM p2 WHERE val >= '50' AND val <= '51' AND p2.ctid = '(1,1)';
LOG:  statement: /*+IndexScan(p2 p2_val_idx6)*/
EXPLAIN (COSTS false) SELECT val FROM p2 WHERE val >= '50' AND val <= '51' AND p2.ctid = '(1,1)';
NOTICE:  SELECT uses system-defined column "p2.ctid" without the necessary companion column "p2.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  available indexes for IndexScan(p2): p2_val_idx6
LOG:  available indexes for IndexScan(p2_c1): p2_c1_val_idx5
LOG:  available indexes for IndexScan(p2_c2): p2_c2_val_idx5
LOG:  available indexes for IndexScan(p2_c3): p2_c3_val_idx5
LOG:  available indexes for IndexScan(p2_c4): p2_c4_val_idx5
LOG:  available indexes for IndexScan(p2_c1_c1): p2_c1_c1_val_idx5
LOG:  available indexes for IndexScan(p2_c1_c2): p2_c1_c2_val_idx5
LOG:  available indexes for IndexScan(p2_c3_c1): p2_c3_c1_val_idx5
LOG:  available indexes for IndexScan(p2_c3_c2): p2_c3_c2_val_idx5
LOG:  pg_hint_plan:
used hint:
IndexScan(p2 p2_val_idx6)
not used hint:
duplication hint:
error hint:
                                          QUERY PLAN                                           
-----------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Append
         ->  Seq Scan on p2
               Filter: ((val >= '50'::text) AND (val <= '51'::text) AND (ctid = '(1,1)'::tid))
         ->  Seq Scan on p2_c1
               Filter: ((val >= '50'::text) AND (val <= '51'::text) AND (ctid = '(1,1)'::tid))
         ->  Seq Scan on p2_c2
               Filter: ((val >= '50'::text) AND (val <= '51'::text) AND (ctid = '(1,1)'::tid))
         ->  Seq Scan on p2_c3
               Filter: ((val >= '50'::text) AND (val <= '51'::text) AND (ctid = '(1,1)'::tid))
         ->  Seq Scan on p2_c4
               Filter: ((val >= '50'::text) AND (val <= '51'::text) AND (ctid = '(1,1)'::tid))
         ->  Seq Scan on p2_c1_c1
               Filter: ((val >= '50'::text) AND (val <= '51'::text) AND (ctid = '(1,1)'::tid))
         ->  Seq Scan on p2_c1_c2
               Filter: ((val >= '50'::text) AND (val <= '51'::text) AND (ctid = '(1,1)'::tid))
         ->  Seq Scan on p2_c3_c1
               Filter: ((val >= '50'::text) AND (val <= '51'::text) AND (ctid = '(1,1)'::tid))
         ->  Seq Scan on p2_c3_c2
               Filter: ((val >= '50'::text) AND (val <= '51'::text) AND (ctid = '(1,1)'::tid))
 Optimizer: Postgres query optimizer
(21 rows)

/*+IndexScan(p2 p2_val_idx p2_val_idx6)*/
EXPLAIN (COSTS false) SELECT val FROM p2 WHERE val >= '50' AND val <= '51' AND p2.ctid = '(1,1)';
LOG:  statement: /*+IndexScan(p2 p2_val_idx p2_val_idx6)*/
EXPLAIN (COSTS false) SELECT val FROM p2 WHERE val >= '50' AND val <= '51' AND p2.ctid = '(1,1)';
NOTICE:  SELECT uses system-defined column "p2.ctid" without the necessary companion column "p2.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  available indexes for IndexScan(p2): p2_val_idx6
LOG:  available indexes for IndexScan(p2_c1): p2_c1_val_idx5
LOG:  available indexes for IndexScan(p2_c2): p2_c2_val_idx5
LOG:  available indexes for IndexScan(p2_c3): p2_c3_val_idx5
LOG:  available indexes for IndexScan(p2_c4): p2_c4_val_idx5
LOG:  available indexes for IndexScan(p2_c1_c1): p2_c1_c1_val_idx5
LOG:  available indexes for IndexScan(p2_c1_c2): p2_c1_c2_val_idx5
LOG:  available indexes for IndexScan(p2_c3_c1): p2_c3_c1_val_idx5
LOG:  available indexes for IndexScan(p2_c3_c2): p2_c3_c2_val_idx5
LOG:  pg_hint_plan:
used hint:
IndexScan(p2 p2_val_idx p2_val_idx6)
not used hint:
duplication hint:
error hint:
                                          QUERY PLAN                                           
-----------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Append
         ->  Seq Scan on p2
               Filter: ((val >= '50'::text) AND (val <= '51'::text) AND (ctid = '(1,1)'::tid))
         ->  Seq Scan on p2_c1
               Filter: ((val >= '50'::text) AND (val <= '51'::text) AND (ctid = '(1,1)'::tid))
         ->  Seq Scan on p2_c2
               Filter: ((val >= '50'::text) AND (val <= '51'::text) AND (ctid = '(1,1)'::tid))
         ->  Seq Scan on p2_c3
               Filter: ((val >= '50'::text) AND (val <= '51'::text) AND (ctid = '(1,1)'::tid))
         ->  Seq Scan on p2_c4
               Filter: ((val >= '50'::text) AND (val <= '51'::text) AND (ctid = '(1,1)'::tid))
         ->  Seq Scan on p2_c1_c1
               Filter: ((val >= '50'::text) AND (val <= '51'::text) AND (ctid = '(1,1)'::tid))
         ->  Seq Scan on p2_c1_c2
               Filter: ((val >= '50'::text) AND (val <= '51'::text) AND (ctid = '(1,1)'::tid))
         ->  Seq Scan on p2_c3_c1
               Filter: ((val >= '50'::text) AND (val <= '51'::text) AND (ctid = '(1,1)'::tid))
         ->  Seq Scan on p2_c3_c2
               Filter: ((val >= '50'::text) AND (val <= '51'::text) AND (ctid = '(1,1)'::tid))
 Optimizer: Postgres query optimizer
(21 rows)

-- regular expression
-- ordinary table
EXPLAIN (COSTS false) SELECT id FROM t5 WHERE id = 1;
LOG:  statement: EXPLAIN (COSTS false) SELECT id FROM t5 WHERE id = 1;
                                            QUERY PLAN                                             
---------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)
   ->  Index Only Scan using t5_idaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa on t5
         Index Cond: (id = 1)
 Optimizer: Postgres query optimizer
(4 rows)

/*+ IndexScanRegexp(t5 t5_[^i].*)*/
EXPLAIN (COSTS false) SELECT id FROM t5 WHERE id = 1;
LOG:  statement: /*+ IndexScanRegexp(t5 t5_[^i].*)*/
EXPLAIN (COSTS false) SELECT id FROM t5 WHERE id = 1;
LOG:  available indexes for IndexScanRegexp(t5): t5_val t5_pkey
LOG:  pg_hint_plan:
used hint:
IndexScanRegexp(t5 t5_[^i].*)
not used hint:
duplication hint:
error hint:
                QUERY PLAN                
------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)
   ->  Index Scan using t5_pkey on t5
         Index Cond: (id = 1)
 Optimizer: Postgres query optimizer
(4 rows)

/*+ IndexScanRegexp(t5 t5_id[0-9].*)*/
EXPLAIN (COSTS false) SELECT id FROM t5 WHERE id = 1;
LOG:  statement: /*+ IndexScanRegexp(t5 t5_id[0-9].*)*/
EXPLAIN (COSTS false) SELECT id FROM t5 WHERE id = 1;
LOG:  available indexes for IndexScanRegexp(t5): t5_id3 t5_id2 t5_id1
LOG:  pg_hint_plan:
used hint:
IndexScanRegexp(t5 t5_id[0-9].*)
not used hint:
duplication hint:
error hint:
                QUERY PLAN                
------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)
   ->  Index Scan using t5_id3 on t5
         Index Cond: (id = 1)
 Optimizer: Postgres query optimizer
(4 rows)

/*+ IndexScanRegexp(t5 t5[^_].*)*/
EXPLAIN (COSTS false) SELECT id FROM t5 WHERE id = 1;
LOG:  statement: /*+ IndexScanRegexp(t5 t5[^_].*)*/
EXPLAIN (COSTS false) SELECT id FROM t5 WHERE id = 1;
LOG:  available indexes for IndexScanRegexp(t5):
LOG:  pg_hint_plan:
used hint:
IndexScanRegexp(t5 t5[^_].*)
not used hint:
duplication hint:
error hint:
                QUERY PLAN                
------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)
   ->  Seq Scan on t5
         Filter: (id = 1)
 Optimizer: Postgres query optimizer
(4 rows)

/*+ IndexScanRegexp(t5 ^.*t5_idaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab)*/
EXPLAIN (COSTS false) SELECT id FROM t5 WHERE id = 1;
LOG:  statement: /*+ IndexScanRegexp(t5 ^.*t5_idaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab)*/
EXPLAIN (COSTS false) SELECT id FROM t5 WHERE id = 1;
LOG:  available indexes for IndexScanRegexp(t5):
LOG:  pg_hint_plan:
used hint:
IndexScanRegexp(t5 ^.*t5_idaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab)
not used hint:
duplication hint:
error hint:
                QUERY PLAN                
------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)
   ->  Seq Scan on t5
         Filter: (id = 1)
 Optimizer: Postgres query optimizer
(4 rows)

/*+ IndexScan(t5 t5_id[0-9].*)*/
EXPLAIN (COSTS false) SELECT id FROM t5 WHERE id = 1;
LOG:  statement: /*+ IndexScan(t5 t5_id[0-9].*)*/
EXPLAIN (COSTS false) SELECT id FROM t5 WHERE id = 1;
LOG:  available indexes for IndexScan(t5):
LOG:  pg_hint_plan:
used hint:
IndexScan(t5 t5_id[0-9].*)
not used hint:
duplication hint:
error hint:
                QUERY PLAN                
------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)
   ->  Seq Scan on t5
         Filter: (id = 1)
 Optimizer: Postgres query optimizer
(4 rows)

/*+ IndexOnlyScanRegexp(t5 t5_[^i].*)*/
EXPLAIN (COSTS false) SELECT id FROM t5 WHERE id = 1;
LOG:  statement: /*+ IndexOnlyScanRegexp(t5 t5_[^i].*)*/
EXPLAIN (COSTS false) SELECT id FROM t5 WHERE id = 1;
LOG:  available indexes for IndexOnlyScanRegexp(t5): t5_val t5_pkey
LOG:  pg_hint_plan:
used hint:
IndexOnlyScanRegexp(t5 t5_[^i].*)
not used hint:
duplication hint:
error hint:
                QUERY PLAN                 
-------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)
   ->  Index Only Scan using t5_pkey on t5
         Index Cond: (id = 1)
 Optimizer: Postgres query optimizer
(4 rows)

/*+ IndexOnlyScanRegexp(t5 t5_id[0-9].*)*/
EXPLAIN (COSTS false) SELECT id FROM t5 WHERE id = 1;
LOG:  statement: /*+ IndexOnlyScanRegexp(t5 t5_id[0-9].*)*/
EXPLAIN (COSTS false) SELECT id FROM t5 WHERE id = 1;
LOG:  available indexes for IndexOnlyScanRegexp(t5): t5_id3 t5_id2 t5_id1
LOG:  pg_hint_plan:
used hint:
IndexOnlyScanRegexp(t5 t5_id[0-9].*)
not used hint:
duplication hint:
error hint:
                QUERY PLAN                
------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)
   ->  Index Only Scan using t5_id3 on t5
         Index Cond: (id = 1)
 Optimizer: Postgres query optimizer
(4 rows)

/*+ IndexOnlyScanRegexp(t5 t5[^_].*)*/
EXPLAIN (COSTS false) SELECT id FROM t5 WHERE id = 1;
LOG:  statement: /*+ IndexOnlyScanRegexp(t5 t5[^_].*)*/
EXPLAIN (COSTS false) SELECT id FROM t5 WHERE id = 1;
LOG:  available indexes for IndexOnlyScanRegexp(t5):
LOG:  pg_hint_plan:
used hint:
IndexOnlyScanRegexp(t5 t5[^_].*)
not used hint:
duplication hint:
error hint:
                QUERY PLAN                
------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)
   ->  Seq Scan on t5
         Filter: (id = 1)
 Optimizer: Postgres query optimizer
(4 rows)

/*+ IndexOnlyScanRegexp(t5 ^.*t5_idaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab)*/
EXPLAIN (COSTS false) SELECT id FROM t5 WHERE id = 1;
LOG:  statement: /*+ IndexOnlyScanRegexp(t5 ^.*t5_idaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab)*/
EXPLAIN (COSTS false) SELECT id FROM t5 WHERE id = 1;
LOG:  available indexes for IndexOnlyScanRegexp(t5):
LOG:  pg_hint_plan:
used hint:
IndexOnlyScanRegexp(t5 ^.*t5_idaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab)
not used hint:
duplication hint:
error hint:
                QUERY PLAN                
------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)
   ->  Seq Scan on t5
         Filter: (id = 1)
 Optimizer: Postgres query optimizer
(4 rows)

/*+ IndexOnlyScan(t5 t5_id[0-9].*)*/
EXPLAIN (COSTS false) SELECT id FROM t5 WHERE id = 1;
LOG:  statement: /*+ IndexOnlyScan(t5 t5_id[0-9].*)*/
EXPLAIN (COSTS false) SELECT id FROM t5 WHERE id = 1;
LOG:  available indexes for IndexOnlyScan(t5):
LOG:  pg_hint_plan:
used hint:
IndexOnlyScan(t5 t5_id[0-9].*)
not used hint:
duplication hint:
error hint:
                QUERY PLAN                
------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)
   ->  Seq Scan on t5
         Filter: (id = 1)
 Optimizer: Postgres query optimizer
(4 rows)

/*+ BitmapScanRegexp(t5 t5_[^i].*)*/
EXPLAIN (COSTS false) SELECT id FROM t5 WHERE id = 1;
LOG:  statement: /*+ BitmapScanRegexp(t5 t5_[^i].*)*/
EXPLAIN (COSTS false) SELECT id FROM t5 WHERE id = 1;
LOG:  available indexes for BitmapScanRegexp(t5): t5_val t5_pkey
LOG:  pg_hint_plan:
used hint:
BitmapScanRegexp(t5 t5_[^i].*)
not used hint:
duplication hint:
error hint:
                QUERY PLAN                
------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)
   ->  Bitmap Heap Scan on t5
         Recheck Cond: (id = 1)
         ->  Bitmap Index Scan on t5_pkey
               Index Cond: (id = 1)
 Optimizer: Postgres query optimizer
(6 rows)

/*+ BitmapScanRegexp(t5 t5_id[0-9].*)*/
EXPLAIN (COSTS false) SELECT id FROM t5 WHERE id = 1;
LOG:  statement: /*+ BitmapScanRegexp(t5 t5_id[0-9].*)*/
EXPLAIN (COSTS false) SELECT id FROM t5 WHERE id = 1;
LOG:  available indexes for BitmapScanRegexp(t5): t5_id3 t5_id2 t5_id1
LOG:  pg_hint_plan:
used hint:
BitmapScanRegexp(t5 t5_id[0-9].*)
not used hint:
duplication hint:
error hint:
                QUERY PLAN                
------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)
   ->  Bitmap Heap Scan on t5
         Recheck Cond: (id = 1)
         ->  Bitmap Index Scan on t5_id3
               Index Cond: (id = 1)
 Optimizer: Postgres query optimizer
(6 rows)

/*+ BitmapScanRegexp(t5 t5[^_].*)*/
EXPLAIN (COSTS false) SELECT id FROM t5 WHERE id = 1;
LOG:  statement: /*+ BitmapScanRegexp(t5 t5[^_].*)*/
EXPLAIN (COSTS false) SELECT id FROM t5 WHERE id = 1;
LOG:  available indexes for BitmapScanRegexp(t5):
LOG:  pg_hint_plan:
used hint:
BitmapScanRegexp(t5 t5[^_].*)
not used hint:
duplication hint:
error hint:
                QUERY PLAN                
------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)
   ->  Seq Scan on t5
         Filter: (id = 1)
 Optimizer: Postgres query optimizer
(4 rows)

/*+ BitmapScanRegexp(t5 ^.*t5_idaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab)*/
EXPLAIN (COSTS false) SELECT id FROM t5 WHERE id = 1;
LOG:  statement: /*+ BitmapScanRegexp(t5 ^.*t5_idaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab)*/
EXPLAIN (COSTS false) SELECT id FROM t5 WHERE id = 1;
LOG:  available indexes for BitmapScanRegexp(t5):
LOG:  pg_hint_plan:
used hint:
BitmapScanRegexp(t5 ^.*t5_idaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab)
not used hint:
duplication hint:
error hint:
                QUERY PLAN                
------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)
   ->  Seq Scan on t5
         Filter: (id = 1)
 Optimizer: Postgres query optimizer
(4 rows)

/*+ BitmapScan(t5 t5_id[0-9].*)*/
EXPLAIN (COSTS false) SELECT id FROM t5 WHERE id = 1;
LOG:  statement: /*+ BitmapScan(t5 t5_id[0-9].*)*/
EXPLAIN (COSTS false) SELECT id FROM t5 WHERE id = 1;
LOG:  available indexes for BitmapScan(t5):
LOG:  pg_hint_plan:
used hint:
BitmapScan(t5 t5_id[0-9].*)
not used hint:
duplication hint:
error hint:
                QUERY PLAN                
------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)
   ->  Seq Scan on t5
         Filter: (id = 1)
 Optimizer: Postgres query optimizer
(4 rows)

-- Inheritance
EXPLAIN (COSTS false) SELECT val FROM p1 WHERE val = 1;
LOG:  statement: EXPLAIN (COSTS false) SELECT val FROM p1 WHERE val = 1;
                QUERY PLAN                
------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Append
         ->  Seq Scan on p1
               Filter: (val = 1)
         ->  Seq Scan on p1_c1
               Filter: (val = 1)
         ->  Seq Scan on p1_c2
               Filter: (val = 1)
         ->  Seq Scan on p1_c3
               Filter: (val = 1)
         ->  Seq Scan on p1_c4
               Filter: (val = 1)
         ->  Seq Scan on p1_c1_c1
               Filter: (val = 1)
         ->  Seq Scan on p1_c1_c2
               Filter: (val = 1)
         ->  Seq Scan on p1_c3_c1
               Filter: (val = 1)
         ->  Seq Scan on p1_c3_c2
               Filter: (val = 1)
 Optimizer: Postgres query optimizer
(21 rows)

/*+ IndexScanRegexp(p1 p1_.*[^0-9]$)*/
EXPLAIN (COSTS false) SELECT val FROM p1 WHERE val = 1;
LOG:  statement: /*+ IndexScanRegexp(p1 p1_.*[^0-9]$)*/
EXPLAIN (COSTS false) SELECT val FROM p1 WHERE val = 1;
LOG:  available indexes for IndexScanRegexp(p1): p1_pkey
LOG:  available indexes for IndexScanRegexp(p1_c1): p1_c1_pkey
LOG:  available indexes for IndexScanRegexp(p1_c2): p1_c2_pkey
LOG:  available indexes for IndexScanRegexp(p1_c3): p1_c3_pkey
LOG:  available indexes for IndexScanRegexp(p1_c4): p1_c4_pkey
LOG:  available indexes for IndexScanRegexp(p1_c1_c1): p1_c1_c1_pkey
LOG:  available indexes for IndexScanRegexp(p1_c1_c2): p1_c1_c2_pkey
LOG:  available indexes for IndexScanRegexp(p1_c3_c1): p1_c3_c1_pkey
LOG:  available indexes for IndexScanRegexp(p1_c3_c2): p1_c3_c2_pkey
LOG:  pg_hint_plan:
used hint:
IndexScanRegexp(p1 p1_.*[^0-9]$)
not used hint:
duplication hint:
error hint:
                QUERY PLAN                
------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Append
         ->  Seq Scan on p1
               Filter: (val = 1)
         ->  Seq Scan on p1_c1
               Filter: (val = 1)
         ->  Seq Scan on p1_c2
               Filter: (val = 1)
         ->  Seq Scan on p1_c3
               Filter: (val = 1)
         ->  Seq Scan on p1_c4
               Filter: (val = 1)
         ->  Seq Scan on p1_c1_c1
               Filter: (val = 1)
         ->  Seq Scan on p1_c1_c2
               Filter: (val = 1)
         ->  Seq Scan on p1_c3_c1
               Filter: (val = 1)
         ->  Seq Scan on p1_c3_c2
               Filter: (val = 1)
 Optimizer: Postgres query optimizer
(21 rows)

/*+ IndexScanRegexp(p1 p1_.*val2.*)*/
EXPLAIN (COSTS false) SELECT val FROM p1 WHERE val = 1;
LOG:  statement: /*+ IndexScanRegexp(p1 p1_.*val2.*)*/
EXPLAIN (COSTS false) SELECT val FROM p1 WHERE val = 1;
LOG:  available indexes for IndexScanRegexp(p1): p1_val2
LOG:  available indexes for IndexScanRegexp(p1_c1): p1_c1_val2
LOG:  available indexes for IndexScanRegexp(p1_c2): p1_c2_val2
LOG:  available indexes for IndexScanRegexp(p1_c3): p1_c3_val2
LOG:  available indexes for IndexScanRegexp(p1_c4): p1_c4_val2
LOG:  available indexes for IndexScanRegexp(p1_c1_c1): p1_c1_c1_val2
LOG:  available indexes for IndexScanRegexp(p1_c1_c2): p1_c1_c2_val2
LOG:  available indexes for IndexScanRegexp(p1_c3_c1): p1_c3_c1_val2
LOG:  available indexes for IndexScanRegexp(p1_c3_c2): p1_c3_c2_val2
LOG:  pg_hint_plan:
used hint:
IndexScanRegexp(p1 p1_.*val2.*)
not used hint:
duplication hint:
error hint:
                       QUERY PLAN                       
--------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Append
         ->  Index Scan using p1_val2 on p1
               Index Cond: (val = 1)
         ->  Index Scan using p1_c1_val2 on p1_c1
               Index Cond: (val = 1)
         ->  Index Scan using p1_c2_val2 on p1_c2
               Index Cond: (val = 1)
         ->  Index Scan using p1_c3_val2 on p1_c3
               Index Cond: (val = 1)
         ->  Index Scan using p1_c4_val2 on p1_c4
               Index Cond: (val = 1)
         ->  Index Scan using p1_c1_c1_val2 on p1_c1_c1
               Index Cond: (val = 1)
         ->  Index Scan using p1_c1_c2_val2 on p1_c1_c2
               Index Cond: (val = 1)
         ->  Index Scan using p1_c3_c1_val2 on p1_c3_c1
               Index Cond: (val = 1)
         ->  Index Scan using p1_c3_c2_val2 on p1_c3_c2
               Index Cond: (val = 1)
 Optimizer: Postgres query optimizer
(21 rows)

/*+ IndexScanRegexp(p1 p1[^_].*)*/
EXPLAIN (COSTS false) SELECT val FROM p1 WHERE val = 1;
LOG:  statement: /*+ IndexScanRegexp(p1 p1[^_].*)*/
EXPLAIN (COSTS false) SELECT val FROM p1 WHERE val = 1;
LOG:  available indexes for IndexScanRegexp(p1):
LOG:  available indexes for IndexScanRegexp(p1_c1):
LOG:  available indexes for IndexScanRegexp(p1_c2):
LOG:  available indexes for IndexScanRegexp(p1_c3):
LOG:  available indexes for IndexScanRegexp(p1_c4):
LOG:  available indexes for IndexScanRegexp(p1_c1_c1):
LOG:  available indexes for IndexScanRegexp(p1_c1_c2):
LOG:  available indexes for IndexScanRegexp(p1_c3_c1):
LOG:  available indexes for IndexScanRegexp(p1_c3_c2):
LOG:  pg_hint_plan:
used hint:
IndexScanRegexp(p1 p1[^_].*)
not used hint:
duplication hint:
error hint:
                QUERY PLAN                
------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Append
         ->  Seq Scan on p1
               Filter: (val = 1)
         ->  Seq Scan on p1_c1
               Filter: (val = 1)
         ->  Seq Scan on p1_c2
               Filter: (val = 1)
         ->  Seq Scan on p1_c3
               Filter: (val = 1)
         ->  Seq Scan on p1_c4
               Filter: (val = 1)
         ->  Seq Scan on p1_c1_c1
               Filter: (val = 1)
         ->  Seq Scan on p1_c1_c2
               Filter: (val = 1)
         ->  Seq Scan on p1_c3_c1
               Filter: (val = 1)
         ->  Seq Scan on p1_c3_c2
               Filter: (val = 1)
 Optimizer: Postgres query optimizer
(21 rows)

/*+ IndexScan(p1 p1_.*val2.*)*/
EXPLAIN (COSTS false) SELECT val FROM p1 WHERE val = 1;
LOG:  statement: /*+ IndexScan(p1 p1_.*val2.*)*/
EXPLAIN (COSTS false) SELECT val FROM p1 WHERE val = 1;
LOG:  available indexes for IndexScan(p1):
LOG:  available indexes for IndexScan(p1_c1):
LOG:  available indexes for IndexScan(p1_c2):
LOG:  available indexes for IndexScan(p1_c3):
LOG:  available indexes for IndexScan(p1_c4):
LOG:  available indexes for IndexScan(p1_c1_c1):
LOG:  available indexes for IndexScan(p1_c1_c2):
LOG:  available indexes for IndexScan(p1_c3_c1):
LOG:  available indexes for IndexScan(p1_c3_c2):
LOG:  pg_hint_plan:
used hint:
IndexScan(p1 p1_.*val2.*)
not used hint:
duplication hint:
error hint:
                QUERY PLAN                
------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Append
         ->  Seq Scan on p1
               Filter: (val = 1)
         ->  Seq Scan on p1_c1
               Filter: (val = 1)
         ->  Seq Scan on p1_c2
               Filter: (val = 1)
         ->  Seq Scan on p1_c3
               Filter: (val = 1)
         ->  Seq Scan on p1_c4
               Filter: (val = 1)
         ->  Seq Scan on p1_c1_c1
               Filter: (val = 1)
         ->  Seq Scan on p1_c1_c2
               Filter: (val = 1)
         ->  Seq Scan on p1_c3_c1
               Filter: (val = 1)
         ->  Seq Scan on p1_c3_c2
               Filter: (val = 1)
 Optimizer: Postgres query optimizer
(21 rows)

/*+ IndexOnlyScanRegexp(p1 p1_.*[^0-9]$)*/
EXPLAIN (COSTS false) SELECT val FROM p1 WHERE val = 1;
LOG:  statement: /*+ IndexOnlyScanRegexp(p1 p1_.*[^0-9]$)*/
EXPLAIN (COSTS false) SELECT val FROM p1 WHERE val = 1;
LOG:  available indexes for IndexOnlyScanRegexp(p1): p1_pkey
LOG:  available indexes for IndexOnlyScanRegexp(p1_c1): p1_c1_pkey
LOG:  available indexes for IndexOnlyScanRegexp(p1_c2): p1_c2_pkey
LOG:  available indexes for IndexOnlyScanRegexp(p1_c3): p1_c3_pkey
LOG:  available indexes for IndexOnlyScanRegexp(p1_c4): p1_c4_pkey
LOG:  available indexes for IndexOnlyScanRegexp(p1_c1_c1): p1_c1_c1_pkey
LOG:  available indexes for IndexOnlyScanRegexp(p1_c1_c2): p1_c1_c2_pkey
LOG:  available indexes for IndexOnlyScanRegexp(p1_c3_c1): p1_c3_c1_pkey
LOG:  available indexes for IndexOnlyScanRegexp(p1_c3_c2): p1_c3_c2_pkey
LOG:  pg_hint_plan:
used hint:
IndexOnlyScanRegexp(p1 p1_.*[^0-9]$)
not used hint:
duplication hint:
error hint:
                QUERY PLAN                
------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Append
         ->  Seq Scan on p1
               Filter: (val = 1)
         ->  Seq Scan on p1_c1
               Filter: (val = 1)
         ->  Seq Scan on p1_c2
               Filter: (val = 1)
         ->  Seq Scan on p1_c3
               Filter: (val = 1)
         ->  Seq Scan on p1_c4
               Filter: (val = 1)
         ->  Seq Scan on p1_c1_c1
               Filter: (val = 1)
         ->  Seq Scan on p1_c1_c2
               Filter: (val = 1)
         ->  Seq Scan on p1_c3_c1
               Filter: (val = 1)
         ->  Seq Scan on p1_c3_c2
               Filter: (val = 1)
 Optimizer: Postgres query optimizer
(21 rows)

/*+ IndexOnlyScanRegexp(p1 p1_.*val2.*)*/
EXPLAIN (COSTS false) SELECT val FROM p1 WHERE val = 1;
LOG:  statement: /*+ IndexOnlyScanRegexp(p1 p1_.*val2.*)*/
EXPLAIN (COSTS false) SELECT val FROM p1 WHERE val = 1;
LOG:  available indexes for IndexOnlyScanRegexp(p1): p1_val2
LOG:  available indexes for IndexOnlyScanRegexp(p1_c1): p1_c1_val2
LOG:  available indexes for IndexOnlyScanRegexp(p1_c2): p1_c2_val2
LOG:  available indexes for IndexOnlyScanRegexp(p1_c3): p1_c3_val2
LOG:  available indexes for IndexOnlyScanRegexp(p1_c4): p1_c4_val2
LOG:  available indexes for IndexOnlyScanRegexp(p1_c1_c1): p1_c1_c1_val2
LOG:  available indexes for IndexOnlyScanRegexp(p1_c1_c2): p1_c1_c2_val2
LOG:  available indexes for IndexOnlyScanRegexp(p1_c3_c1): p1_c3_c1_val2
LOG:  available indexes for IndexOnlyScanRegexp(p1_c3_c2): p1_c3_c2_val2
LOG:  pg_hint_plan:
used hint:
IndexOnlyScanRegexp(p1 p1_.*val2.*)
not used hint:
duplication hint:
error hint:
                         QUERY PLAN                          
-------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Append
         ->  Index Only Scan using p1_val2 on p1
               Index Cond: (val = 1)
         ->  Index Only Scan using p1_c1_val2 on p1_c1
               Index Cond: (val = 1)
         ->  Index Only Scan using p1_c2_val2 on p1_c2
               Index Cond: (val = 1)
         ->  Index Only Scan using p1_c3_val2 on p1_c3
               Index Cond: (val = 1)
         ->  Index Only Scan using p1_c4_val2 on p1_c4
               Index Cond: (val = 1)
         ->  Index Only Scan using p1_c1_c1_val2 on p1_c1_c1
               Index Cond: (val = 1)
         ->  Index Only Scan using p1_c1_c2_val2 on p1_c1_c2
               Index Cond: (val = 1)
         ->  Index Only Scan using p1_c3_c1_val2 on p1_c3_c1
               Index Cond: (val = 1)
         ->  Index Only Scan using p1_c3_c2_val2 on p1_c3_c2
               Index Cond: (val = 1)
 Optimizer: Postgres query optimizer
(21 rows)

/*+ IndexOnlyScanRegexp(p1 p1[^_].*)*/
EXPLAIN (COSTS false) SELECT val FROM p1 WHERE val = 1;
LOG:  statement: /*+ IndexOnlyScanRegexp(p1 p1[^_].*)*/
EXPLAIN (COSTS false) SELECT val FROM p1 WHERE val = 1;
LOG:  available indexes for IndexOnlyScanRegexp(p1):
LOG:  available indexes for IndexOnlyScanRegexp(p1_c1):
LOG:  available indexes for IndexOnlyScanRegexp(p1_c2):
LOG:  available indexes for IndexOnlyScanRegexp(p1_c3):
LOG:  available indexes for IndexOnlyScanRegexp(p1_c4):
LOG:  available indexes for IndexOnlyScanRegexp(p1_c1_c1):
LOG:  available indexes for IndexOnlyScanRegexp(p1_c1_c2):
LOG:  available indexes for IndexOnlyScanRegexp(p1_c3_c1):
LOG:  available indexes for IndexOnlyScanRegexp(p1_c3_c2):
LOG:  pg_hint_plan:
used hint:
IndexOnlyScanRegexp(p1 p1[^_].*)
not used hint:
duplication hint:
error hint:
                QUERY PLAN                
------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Append
         ->  Seq Scan on p1
               Filter: (val = 1)
         ->  Seq Scan on p1_c1
               Filter: (val = 1)
         ->  Seq Scan on p1_c2
               Filter: (val = 1)
         ->  Seq Scan on p1_c3
               Filter: (val = 1)
         ->  Seq Scan on p1_c4
               Filter: (val = 1)
         ->  Seq Scan on p1_c1_c1
               Filter: (val = 1)
         ->  Seq Scan on p1_c1_c2
               Filter: (val = 1)
         ->  Seq Scan on p1_c3_c1
               Filter: (val = 1)
         ->  Seq Scan on p1_c3_c2
               Filter: (val = 1)
 Optimizer: Postgres query optimizer
(21 rows)

/*+ IndexOnlyScan(p1 p1_.*val2.*)*/
EXPLAIN (COSTS false) SELECT val FROM p1 WHERE val = 1;
LOG:  statement: /*+ IndexOnlyScan(p1 p1_.*val2.*)*/
EXPLAIN (COSTS false) SELECT val FROM p1 WHERE val = 1;
LOG:  available indexes for IndexOnlyScan(p1):
LOG:  available indexes for IndexOnlyScan(p1_c1):
LOG:  available indexes for IndexOnlyScan(p1_c2):
LOG:  available indexes for IndexOnlyScan(p1_c3):
LOG:  available indexes for IndexOnlyScan(p1_c4):
LOG:  available indexes for IndexOnlyScan(p1_c1_c1):
LOG:  available indexes for IndexOnlyScan(p1_c1_c2):
LOG:  available indexes for IndexOnlyScan(p1_c3_c1):
LOG:  available indexes for IndexOnlyScan(p1_c3_c2):
LOG:  pg_hint_plan:
used hint:
IndexOnlyScan(p1 p1_.*val2.*)
not used hint:
duplication hint:
error hint:
                QUERY PLAN                
------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Append
         ->  Seq Scan on p1
               Filter: (val = 1)
         ->  Seq Scan on p1_c1
               Filter: (val = 1)
         ->  Seq Scan on p1_c2
               Filter: (val = 1)
         ->  Seq Scan on p1_c3
               Filter: (val = 1)
         ->  Seq Scan on p1_c4
               Filter: (val = 1)
         ->  Seq Scan on p1_c1_c1
               Filter: (val = 1)
         ->  Seq Scan on p1_c1_c2
               Filter: (val = 1)
         ->  Seq Scan on p1_c3_c1
               Filter: (val = 1)
         ->  Seq Scan on p1_c3_c2
               Filter: (val = 1)
 Optimizer: Postgres query optimizer
(21 rows)

/*+ BitmapScanRegexp(p1 p1_.*[^0-9]$)*/
EXPLAIN (COSTS false) SELECT val FROM p1 WHERE val = 1;
LOG:  statement: /*+ BitmapScanRegexp(p1 p1_.*[^0-9]$)*/
EXPLAIN (COSTS false) SELECT val FROM p1 WHERE val = 1;
LOG:  available indexes for BitmapScanRegexp(p1): p1_pkey
LOG:  available indexes for BitmapScanRegexp(p1_c1): p1_c1_pkey
LOG:  available indexes for BitmapScanRegexp(p1_c2): p1_c2_pkey
LOG:  available indexes for BitmapScanRegexp(p1_c3): p1_c3_pkey
LOG:  available indexes for BitmapScanRegexp(p1_c4): p1_c4_pkey
LOG:  available indexes for BitmapScanRegexp(p1_c1_c1): p1_c1_c1_pkey
LOG:  available indexes for BitmapScanRegexp(p1_c1_c2): p1_c1_c2_pkey
LOG:  available indexes for BitmapScanRegexp(p1_c3_c1): p1_c3_c1_pkey
LOG:  available indexes for BitmapScanRegexp(p1_c3_c2): p1_c3_c2_pkey
LOG:  pg_hint_plan:
used hint:
BitmapScanRegexp(p1 p1_.*[^0-9]$)
not used hint:
duplication hint:
error hint:
                QUERY PLAN                
------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Append
         ->  Seq Scan on p1
               Filter: (val = 1)
         ->  Seq Scan on p1_c1
               Filter: (val = 1)
         ->  Seq Scan on p1_c2
               Filter: (val = 1)
         ->  Seq Scan on p1_c3
               Filter: (val = 1)
         ->  Seq Scan on p1_c4
               Filter: (val = 1)
         ->  Seq Scan on p1_c1_c1
               Filter: (val = 1)
         ->  Seq Scan on p1_c1_c2
               Filter: (val = 1)
         ->  Seq Scan on p1_c3_c1
               Filter: (val = 1)
         ->  Seq Scan on p1_c3_c2
               Filter: (val = 1)
 Optimizer: Postgres query optimizer
(21 rows)

/*+ BitmapScanRegexp(p1 p1_.*val2.*)*/
EXPLAIN (COSTS false) SELECT val FROM p1 WHERE val = 1;
LOG:  statement: /*+ BitmapScanRegexp(p1 p1_.*val2.*)*/
EXPLAIN (COSTS false) SELECT val FROM p1 WHERE val = 1;
LOG:  available indexes for BitmapScanRegexp(p1): p1_val2
LOG:  available indexes for BitmapScanRegexp(p1_c1): p1_c1_val2
LOG:  available indexes for BitmapScanRegexp(p1_c2): p1_c2_val2
LOG:  available indexes for BitmapScanRegexp(p1_c3): p1_c3_val2
LOG:  available indexes for BitmapScanRegexp(p1_c4): p1_c4_val2
LOG:  available indexes for BitmapScanRegexp(p1_c1_c1): p1_c1_c1_val2
LOG:  available indexes for BitmapScanRegexp(p1_c1_c2): p1_c1_c2_val2
LOG:  available indexes for BitmapScanRegexp(p1_c3_c1): p1_c3_c1_val2
LOG:  available indexes for BitmapScanRegexp(p1_c3_c2): p1_c3_c2_val2
LOG:  pg_hint_plan:
used hint:
BitmapScanRegexp(p1 p1_.*val2.*)
not used hint:
duplication hint:
error hint:
                      QUERY PLAN                      
------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Append
         ->  Bitmap Heap Scan on p1
               Recheck Cond: (val = 1)
               ->  Bitmap Index Scan on p1_val2
                     Index Cond: (val = 1)
         ->  Bitmap Heap Scan on p1_c1
               Recheck Cond: (val = 1)
               ->  Bitmap Index Scan on p1_c1_val2
                     Index Cond: (val = 1)
         ->  Bitmap Heap Scan on p1_c2
               Recheck Cond: (val = 1)
               ->  Bitmap Index Scan on p1_c2_val2
                     Index Cond: (val = 1)
         ->  Bitmap Heap Scan on p1_c3
               Recheck Cond: (val = 1)
               ->  Bitmap Index Scan on p1_c3_val2
                     Index Cond: (val = 1)
         ->  Bitmap Heap Scan on p1_c4
               Recheck Cond: (val = 1)
               ->  Bitmap Index Scan on p1_c4_val2
                     Index Cond: (val = 1)
         ->  Bitmap Heap Scan on p1_c1_c1
               Recheck Cond: (val = 1)
               ->  Bitmap Index Scan on p1_c1_c1_val2
                     Index Cond: (val = 1)
         ->  Bitmap Heap Scan on p1_c1_c2
               Recheck Cond: (val = 1)
               ->  Bitmap Index Scan on p1_c1_c2_val2
                     Index Cond: (val = 1)
         ->  Bitmap Heap Scan on p1_c3_c1
               Recheck Cond: (val = 1)
               ->  Bitmap Index Scan on p1_c3_c1_val2
                     Index Cond: (val = 1)
         ->  Bitmap Heap Scan on p1_c3_c2
               Recheck Cond: (val = 1)
               ->  Bitmap Index Scan on p1_c3_c2_val2
                     Index Cond: (val = 1)
 Optimizer: Postgres query optimizer
(39 rows)

/*+ BitmapScanRegexp(p1 p1[^_].*)*/
EXPLAIN (COSTS false) SELECT val FROM p1 WHERE val = 1;
LOG:  statement: /*+ BitmapScanRegexp(p1 p1[^_].*)*/
EXPLAIN (COSTS false) SELECT val FROM p1 WHERE val = 1;
LOG:  available indexes for BitmapScanRegexp(p1):
LOG:  available indexes for BitmapScanRegexp(p1_c1):
LOG:  available indexes for BitmapScanRegexp(p1_c2):
LOG:  available indexes for BitmapScanRegexp(p1_c3):
LOG:  available indexes for BitmapScanRegexp(p1_c4):
LOG:  available indexes for BitmapScanRegexp(p1_c1_c1):
LOG:  available indexes for BitmapScanRegexp(p1_c1_c2):
LOG:  available indexes for BitmapScanRegexp(p1_c3_c1):
LOG:  available indexes for BitmapScanRegexp(p1_c3_c2):
LOG:  pg_hint_plan:
used hint:
BitmapScanRegexp(p1 p1[^_].*)
not used hint:
duplication hint:
error hint:
                QUERY PLAN                
------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Append
         ->  Seq Scan on p1
               Filter: (val = 1)
         ->  Seq Scan on p1_c1
               Filter: (val = 1)
         ->  Seq Scan on p1_c2
               Filter: (val = 1)
         ->  Seq Scan on p1_c3
               Filter: (val = 1)
         ->  Seq Scan on p1_c4
               Filter: (val = 1)
         ->  Seq Scan on p1_c1_c1
               Filter: (val = 1)
         ->  Seq Scan on p1_c1_c2
               Filter: (val = 1)
         ->  Seq Scan on p1_c3_c1
               Filter: (val = 1)
         ->  Seq Scan on p1_c3_c2
               Filter: (val = 1)
 Optimizer: Postgres query optimizer
(21 rows)

/*+ BitmapScan(p1 p1_.*val2.*)*/
EXPLAIN (COSTS false) SELECT val FROM p1 WHERE val = 1;
LOG:  statement: /*+ BitmapScan(p1 p1_.*val2.*)*/
EXPLAIN (COSTS false) SELECT val FROM p1 WHERE val = 1;
LOG:  available indexes for BitmapScan(p1):
LOG:  available indexes for BitmapScan(p1_c1):
LOG:  available indexes for BitmapScan(p1_c2):
LOG:  available indexes for BitmapScan(p1_c3):
LOG:  available indexes for BitmapScan(p1_c4):
LOG:  available indexes for BitmapScan(p1_c1_c1):
LOG:  available indexes for BitmapScan(p1_c1_c2):
LOG:  available indexes for BitmapScan(p1_c3_c1):
LOG:  available indexes for BitmapScan(p1_c3_c2):
LOG:  pg_hint_plan:
used hint:
BitmapScan(p1 p1_.*val2.*)
not used hint:
duplication hint:
error hint:
                QUERY PLAN                
------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Append
         ->  Seq Scan on p1
               Filter: (val = 1)
         ->  Seq Scan on p1_c1
               Filter: (val = 1)
         ->  Seq Scan on p1_c2
               Filter: (val = 1)
         ->  Seq Scan on p1_c3
               Filter: (val = 1)
         ->  Seq Scan on p1_c4
               Filter: (val = 1)
         ->  Seq Scan on p1_c1_c1
               Filter: (val = 1)
         ->  Seq Scan on p1_c1_c2
               Filter: (val = 1)
         ->  Seq Scan on p1_c3_c1
               Filter: (val = 1)
         ->  Seq Scan on p1_c3_c2
               Filter: (val = 1)
 Optimizer: Postgres query optimizer
(21 rows)

-- search from hint table
INSERT INTO hint_plan.hints (norm_query_string, application_name, hints) VALUES ('EXPLAIN (COSTS false) SELECT * FROM t1 WHERE t1.id = ?;', '', 'SeqScan(t1)');
LOG:  statement: INSERT INTO hint_plan.hints (norm_query_string, application_name, hints) VALUES ('EXPLAIN (COSTS false) SELECT * FROM t1 WHERE t1.id = ?;', '', 'SeqScan(t1)');
INSERT INTO hint_plan.hints (norm_query_string, application_name, hints) VALUES ('EXPLAIN (COSTS false) SELECT id FROM t1 WHERE t1.id = ?;', '', 'IndexScan(t1)');
LOG:  statement: INSERT INTO hint_plan.hints (norm_query_string, application_name, hints) VALUES ('EXPLAIN (COSTS false) SELECT id FROM t1 WHERE t1.id = ?;', '', 'IndexScan(t1)');
INSERT INTO hint_plan.hints (norm_query_string, application_name, hints) VALUES ('EXPLAIN SELECT * FROM t1 WHERE t1.id = ?;', '', 'BitmapScan(t1)');
LOG:  statement: INSERT INTO hint_plan.hints (norm_query_string, application_name, hints) VALUES ('EXPLAIN SELECT * FROM t1 WHERE t1.id = ?;', '', 'BitmapScan(t1)');
SELECT * FROM hint_plan.hints ORDER BY id;
LOG:  statement: SELECT * FROM hint_plan.hints ORDER BY id;
 id |                    norm_query_string                     | application_name |     hints      
----+----------------------------------------------------------+------------------+----------------
  1 | EXPLAIN (COSTS false) SELECT * FROM t1 WHERE t1.id = ?;  |                  | SeqScan(t1)
  2 | EXPLAIN (COSTS false) SELECT id FROM t1 WHERE t1.id = ?; |                  | IndexScan(t1)
  3 | EXPLAIN SELECT * FROM t1 WHERE t1.id = ?;                |                  | BitmapScan(t1)
(3 rows)

SET pg_hint_plan.enable_hint_table = on;
LOG:  statement: SET pg_hint_plan.enable_hint_table = on;
EXPLAIN (COSTS false) SELECT * FROM t1 WHERE t1.id = 1;
LOG:  statement: EXPLAIN (COSTS false) SELECT * FROM t1 WHERE t1.id = 1;
LOG:  pg_hint_plan:
used hint:
SeqScan(t1)
not used hint:
duplication hint:
error hint:
                QUERY PLAN                
------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)
   ->  Seq Scan on t1
         Filter: (id = 1)
 Optimizer: Postgres query optimizer
(4 rows)

SET pg_hint_plan.enable_hint_table = off;
LOG:  statement: SET pg_hint_plan.enable_hint_table = off;
EXPLAIN (COSTS false) SELECT * FROM t1 WHERE t1.id = 1;
LOG:  statement: EXPLAIN (COSTS false) SELECT * FROM t1 WHERE t1.id = 1;
                QUERY PLAN                
------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)
   ->  Index Scan using t1_pkey on t1
         Index Cond: (id = 1)
 Optimizer: Postgres query optimizer
(4 rows)

TRUNCATE hint_plan.hints;
LOG:  statement: TRUNCATE hint_plan.hints;
VACUUM ANALYZE hint_plan.hints;
LOG:  statement: VACUUM ANALYZE hint_plan.hints;
-- plpgsql test
EXPLAIN (COSTS false) SELECT id FROM t1 WHERE t1.id = 1;
LOG:  statement: EXPLAIN (COSTS false) SELECT id FROM t1 WHERE t1.id = 1;
                QUERY PLAN                 
-------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)
   ->  Index Only Scan using t1_pkey on t1
         Index Cond: (id = 1)
 Optimizer: Postgres query optimizer
(4 rows)

-- static function
CREATE FUNCTION testfunc() RETURNS RECORD AS $$
DECLARE
  ret record;
BEGIN
  SELECT /*+ SeqScan(t1) */ * INTO ret FROM t1 LIMIT 1;
  RETURN ret;
END;
$$ LANGUAGE plpgsql;
LOG:  statement: CREATE FUNCTION testfunc() RETURNS RECORD AS $$
DECLARE
  ret record;
BEGIN
  SELECT /*+ SeqScan(t1) */ * INTO ret FROM t1 LIMIT 1;
  RETURN ret;
END;
$$ LANGUAGE plpgsql;
SELECT testfunc();
LOG:  statement: SELECT testfunc();
LOG:  pg_hint_plan:
used hint:
SeqScan(t1)
not used hint:
duplication hint:
error hint:
CONTEXT:  SQL statement "SELECT /*+ SeqScan(t1) */ *          FROM t1 LIMIT 1"
PL/pgSQL function testfunc() line 5 at SQL statement
 testfunc 
----------
 (2,2)
(1 row)

-- dynamic function
DROP FUNCTION testfunc();
LOG:  statement: DROP FUNCTION testfunc();
CREATE FUNCTION testfunc() RETURNS void AS $$
BEGIN
  EXECUTE format('/*+ SeqScan(t1) */ SELECT * FROM t1');
END;
$$ LANGUAGE plpgsql;
LOG:  statement: CREATE FUNCTION testfunc() RETURNS void AS $$
BEGIN
  EXECUTE format('/*+ SeqScan(t1) */ SELECT * FROM t1');
END;
$$ LANGUAGE plpgsql;
SELECT testfunc();
LOG:  statement: SELECT testfunc();
LOG:  pg_hint_plan:
used hint:
SeqScan(t1)
not used hint:
duplication hint:
error hint:
CONTEXT:  SQL statement "/*+ SeqScan(t1) */ SELECT * FROM t1"
PL/pgSQL function testfunc() line 3 at EXECUTE
 testfunc 
----------
 
(1 row)

-- This should not use SeqScan(t1)
/*+ IndexScan(t1) */ SELECT * from t1 LIMIT 1;
LOG:  statement: /*+ IndexScan(t1) */ SELECT * from t1 LIMIT 1;
LOG:  pg_hint_plan:
used hint:
IndexScan(t1)
not used hint:
duplication hint:
error hint:
 id | val 
----+-----
  2 |   2
(1 row)

-- Perform
DROP FUNCTION testfunc();
LOG:  statement: DROP FUNCTION testfunc();
CREATE FUNCTION testfunc() RETURNS void AS $$
BEGIN
  PERFORM  1, /*+ SeqScan(t1) */ * from t1;
END;
$$ LANGUAGE plpgsql;
LOG:  statement: CREATE FUNCTION testfunc() RETURNS void AS $$
BEGIN
  PERFORM  1, /*+ SeqScan(t1) */ * from t1;
END;
$$ LANGUAGE plpgsql;
SELECT testfunc();
LOG:  statement: SELECT testfunc();
LOG:  pg_hint_plan:
used hint:
SeqScan(t1)
not used hint:
duplication hint:
error hint:
CONTEXT:  SQL statement "SELECT 1, /*+ SeqScan(t1) */ * from t1"
PL/pgSQL function testfunc() line 3 at PERFORM
 testfunc 
----------
 
(1 row)

-- FOR loop
DROP FUNCTION testfunc();
LOG:  statement: DROP FUNCTION testfunc();
CREATE FUNCTION testfunc() RETURNS int AS $$
DECLARE
  sum int;
  v int;
BEGIN
  sum := 0;
  FOR v IN SELECT /*+ SeqScan(t1) */ v FROM t1 ORDER BY id LOOP
    sum := sum + v;
  END LOOP;
  RETURN v;
END;
$$ LANGUAGE plpgsql;
LOG:  statement: CREATE FUNCTION testfunc() RETURNS int AS $$
DECLARE
  sum int;
  v int;
BEGIN
  sum := 0;
  FOR v IN SELECT /*+ SeqScan(t1) */ v FROM t1 ORDER BY id LOOP
    sum := sum + v;
  END LOOP;
  RETURN v;
END;
$$ LANGUAGE plpgsql;
SELECT testfunc();
LOG:  statement: SELECT testfunc();
LOG:  pg_hint_plan:
used hint:
SeqScan(t1)
not used hint:
duplication hint:
error hint:
CONTEXT:  SQL statement "SELECT /*+ SeqScan(t1) */ v FROM t1 ORDER BY id"
PL/pgSQL function testfunc() line 7 at FOR over SELECT rows
LOG:  Dump syncmate : 110 snapshot to slot 0  (seg0 127.0.0.1:7002 pid=87746)
LOG:  Dump syncmate : 110 snapshot to slot 0  (seg1 127.0.0.1:7003 pid=87747)
LOG:  Dump syncmate : 110 snapshot to slot 0  (seg2 127.0.0.1:7004 pid=87748)
LOG:  Dump syncmate : 110 snapshot to slot 0
CONTEXT:  SQL statement "SELECT /*+ SeqScan(t1) */ v FROM t1 ORDER BY id"
PL/pgSQL function testfunc() line 7 at FOR over SELECT rows
 testfunc 
----------
         
(1 row)

-- Dynamic FOR loop
DROP FUNCTION testfunc();
LOG:  statement: DROP FUNCTION testfunc();
CREATE FUNCTION testfunc() RETURNS int AS $$
DECLARE
  sum int;
  v int;
  i   int;
BEGIN
  sum := 0;
  FOR v IN EXECUTE 'SELECT /*+ SeqScan(t1) */ val FROM t1 ORDER BY id' LOOP
    sum := sum + v;
  END LOOP;
  RETURN v;
END;
$$ LANGUAGE plpgsql;
LOG:  statement: CREATE FUNCTION testfunc() RETURNS int AS $$
DECLARE
  sum int;
  v int;
  i   int;
BEGIN
  sum := 0;
  FOR v IN EXECUTE 'SELECT /*+ SeqScan(t1) */ val FROM t1 ORDER BY id' LOOP
    sum := sum + v;
  END LOOP;
  RETURN v;
END;
$$ LANGUAGE plpgsql;
SELECT testfunc();
LOG:  statement: SELECT testfunc();
LOG:  pg_hint_plan:
used hint:
SeqScan(t1)
not used hint:
duplication hint:
error hint:
CONTEXT:  SQL statement "SELECT /*+ SeqScan(t1) */ val FROM t1 ORDER BY id"
PL/pgSQL function testfunc() line 8 at FOR over EXECUTE statement
LOG:  Dump syncmate : 113 snapshot to slot 0  (seg0 127.0.0.1:7002 pid=87746)
LOG:  Dump syncmate : 113 snapshot to slot 0  (seg1 127.0.0.1:7003 pid=87747)
LOG:  Dump syncmate : 113 snapshot to slot 0  (seg2 127.0.0.1:7004 pid=87748)
LOG:  Dump syncmate : 113 snapshot to slot 0
CONTEXT:  SQL statement "SELECT /*+ SeqScan(t1) */ val FROM t1 ORDER BY id"
PL/pgSQL function testfunc() line 8 at FOR over EXECUTE statement
 testfunc 
----------
        0
(1 row)

-- Cursor FOR loop
DROP FUNCTION testfunc();
LOG:  statement: DROP FUNCTION testfunc();
CREATE FUNCTION testfunc() RETURNS int AS $$
DECLARE
  ref CURSOR FOR SELECT /*+ SeqScan(t1) */ * FROM t1 ORDER BY id;
  rec record;
  sum int := 0;
BEGIN
  FOR rec IN ref LOOP
    sum := sum + rec.val;
  END LOOP;
  RETURN sum;
END;
$$ LANGUAGE plpgsql;
LOG:  statement: CREATE FUNCTION testfunc() RETURNS int AS $$
DECLARE
  ref CURSOR FOR SELECT /*+ SeqScan(t1) */ * FROM t1 ORDER BY id;
  rec record;
  sum int := 0;
BEGIN
  FOR rec IN ref LOOP
    sum := sum + rec.val;
  END LOOP;
  RETURN sum;
END;
$$ LANGUAGE plpgsql;
SELECT testfunc();
LOG:  statement: SELECT testfunc();
LOG:  pg_hint_plan:
used hint:
SeqScan(t1)
not used hint:
duplication hint:
error hint:
CONTEXT:  SQL statement "SELECT /*+ SeqScan(t1) */ * FROM t1 ORDER BY id"
PL/pgSQL function testfunc() line 7 at FOR over cursor
LOG:  Dump syncmate : 116 snapshot to slot 0  (seg0 127.0.0.1:7002 pid=87746)
LOG:  Dump syncmate : 116 snapshot to slot 0  (seg1 127.0.0.1:7003 pid=87747)
LOG:  Dump syncmate : 116 snapshot to slot 0  (seg2 127.0.0.1:7004 pid=87748)
LOG:  Dump syncmate : 116 snapshot to slot 0
CONTEXT:  SQL statement "SELECT /*+ SeqScan(t1) */ * FROM t1 ORDER BY id"
PL/pgSQL function testfunc() line 7 at FOR over cursor
 testfunc 
----------
   495000
(1 row)

-- RETURN QUERY
DROP FUNCTION testfunc();
LOG:  statement: DROP FUNCTION testfunc();
CREATE FUNCTION testfunc() RETURNS SETOF t1 AS $$
BEGIN
  RETURN QUERY SELECT /*+ SeqScan(t1) */ * FROM t1 ORDER BY id;
END;
$$ LANGUAGE plpgsql;
LOG:  statement: CREATE FUNCTION testfunc() RETURNS SETOF t1 AS $$
BEGIN
  RETURN QUERY SELECT /*+ SeqScan(t1) */ * FROM t1 ORDER BY id;
END;
$$ LANGUAGE plpgsql;
SELECT * FROM testfunc() LIMIT 1;
LOG:  statement: SELECT * FROM testfunc() LIMIT 1;
LOG:  pg_hint_plan:
used hint:
SeqScan(t1)
not used hint:
duplication hint:
error hint:
CONTEXT:  SQL statement "SELECT /*+ SeqScan(t1) */ * FROM t1 ORDER BY id"
PL/pgSQL function testfunc() line 3 at RETURN QUERY
LOG:  Dump syncmate : 119 snapshot to slot 0  (seg0 127.0.0.1:7002 pid=87746)
LOG:  Dump syncmate : 119 snapshot to slot 0  (seg1 127.0.0.1:7003 pid=87747)
LOG:  Dump syncmate : 119 snapshot to slot 0  (seg2 127.0.0.1:7004 pid=87748)
LOG:  Dump syncmate : 119 snapshot to slot 0
CONTEXT:  SQL statement "SELECT /*+ SeqScan(t1) */ * FROM t1 ORDER BY id"
PL/pgSQL function testfunc() line 3 at RETURN QUERY
 id | val 
----+-----
  1 |   1
(1 row)

-- Test for error exit from inner SQL statement.
DROP FUNCTION testfunc();
LOG:  statement: DROP FUNCTION testfunc();
CREATE FUNCTION testfunc() RETURNS SETOF t1 AS $$
BEGIN
  RETURN QUERY SELECT /*+ SeqScan(t1) */ * FROM ttx ORDER BY id;
END;
$$ LANGUAGE plpgsql;
LOG:  statement: CREATE FUNCTION testfunc() RETURNS SETOF t1 AS $$
BEGIN
  RETURN QUERY SELECT /*+ SeqScan(t1) */ * FROM ttx ORDER BY id;
END;
$$ LANGUAGE plpgsql;
SELECT * FROM testfunc() LIMIT 1;
LOG:  statement: SELECT * FROM testfunc() LIMIT 1;
ERROR:  relation "ttx" does not exist
LINE 1: SELECT /*+ SeqScan(t1) */ * FROM ttx ORDER BY id
                                         ^
QUERY:  SELECT /*+ SeqScan(t1) */ * FROM ttx ORDER BY id
CONTEXT:  PL/pgSQL function testfunc() line 3 at RETURN QUERY
-- this should not use SeqScan(t1) hint.
/*+ IndexScan(t1) */ SELECT * from t1 LIMIT 1;
LOG:  statement: /*+ IndexScan(t1) */ SELECT * from t1 LIMIT 1;
LOG:  pg_hint_plan:
used hint:
IndexScan(t1)
not used hint:
duplication hint:
error hint:
 id | val 
----+-----
  2 |   2
(1 row)

DROP FUNCTION testfunc();
LOG:  statement: DROP FUNCTION testfunc();
DROP EXTENSION pg_hint_plan;
LOG:  statement: DROP EXTENSION pg_hint_plan;
CREATE FUNCTION reset_stats_and_wait() RETURNS void AS $$
DECLARE
  rows int;
BEGIN
  rows = 1;
  while rows > 0 LOOP
   PERFORM pg_stat_reset();
   PERFORM pg_sleep(0.5);
   SELECT sum(seq_scan + idx_scan) from pg_stat_user_tables into rows;
  END LOOP;
END;
$$ LANGUAGE plpgsql;
LOG:  statement: CREATE FUNCTION reset_stats_and_wait() RETURNS void AS $$
DECLARE
  rows int;
BEGIN
  rows = 1;
  while rows > 0 LOOP
   PERFORM pg_stat_reset();
   PERFORM pg_sleep(0.5);
   SELECT sum(seq_scan + idx_scan) from pg_stat_user_tables into rows;
  END LOOP;
END;
$$ LANGUAGE plpgsql;
-- Dynamic query in pl/pgsql
CREATE OR REPLACE FUNCTION dynsql1(x int) RETURNS int AS $$
DECLARE c int;
BEGIN
  EXECUTE '/*+ IndexScan(t1) */ SELECT count(*) FROM t1 WHERE id < $1'
  	INTO c USING x;
  RETURN c;
END;
$$ VOLATILE LANGUAGE plpgsql;
LOG:  statement: CREATE OR REPLACE FUNCTION dynsql1(x int) RETURNS int AS $$
DECLARE c int;
BEGIN
  EXECUTE '/*+ IndexScan(t1) */ SELECT count(*) FROM t1 WHERE id < $1'
  	INTO c USING x;
  RETURN c;
END;
$$ VOLATILE LANGUAGE plpgsql;
vacuum analyze t1;
LOG:  statement: vacuum analyze t1;
SET pg_hint_plan.enable_hint = false;
LOG:  statement: SET pg_hint_plan.enable_hint = false;
SELECT pg_sleep(1);
LOG:  statement: SELECT pg_sleep(1);
 pg_sleep 
----------
 
(1 row)

SELECT reset_stats_and_wait();
LOG:  statement: SELECT reset_stats_and_wait();
LOG:  statement: SELECT sum(seq_scan + idx_scan) from pg_stat_user_tables  (entry db 127.0.0.1:7000 pid=87765)
LOG:  statement: SELECT sum(seq_scan + idx_scan) from pg_stat_user_tables  (entry db 127.0.0.1:7000 pid=87765)
LOG:  statement: SELECT sum(seq_scan + idx_scan) from pg_stat_user_tables  (entry db 127.0.0.1:7000 pid=87765)
LOG:  statement: SELECT sum(seq_scan + idx_scan) from pg_stat_user_tables  (entry db 127.0.0.1:7000 pid=87765)
LOG:  statement: SELECT sum(seq_scan + idx_scan) from pg_stat_user_tables  (entry db 127.0.0.1:7000 pid=87765)
LOG:  statement: SELECT sum(seq_scan + idx_scan) from pg_stat_user_tables  (entry db 127.0.0.1:7000 pid=87765)
LOG:  statement: SELECT sum(seq_scan + idx_scan) from pg_stat_user_tables  (entry db 127.0.0.1:7000 pid=87765)
LOG:  statement: SELECT sum(seq_scan + idx_scan) from pg_stat_user_tables  (entry db 127.0.0.1:7000 pid=87765)
LOG:  statement: SELECT sum(seq_scan + idx_scan) from pg_stat_user_tables  (entry db 127.0.0.1:7000 pid=87765)
LOG:  statement: SELECT sum(seq_scan + idx_scan) from pg_stat_user_tables  (entry db 127.0.0.1:7000 pid=87765)
LOG:  statement: SELECT sum(seq_scan + idx_scan) from pg_stat_user_tables  (entry db 127.0.0.1:7000 pid=87765)
LOG:  statement: SELECT sum(seq_scan + idx_scan) from pg_stat_user_tables  (entry db 127.0.0.1:7000 pid=87765)
LOG:  statement: SELECT sum(seq_scan + idx_scan) from pg_stat_user_tables  (entry db 127.0.0.1:7000 pid=87765)
LOG:  statement: SELECT sum(seq_scan + idx_scan) from pg_stat_user_tables  (entry db 127.0.0.1:7000 pid=87765)
LOG:  statement: SELECT sum(seq_scan + idx_scan) from pg_stat_user_tables  (entry db 127.0.0.1:7000 pid=87765)
LOG:  statement: SELECT sum(seq_scan + idx_scan) from pg_stat_user_tables  (entry db 127.0.0.1:7000 pid=87765)
LOG:  statement: SELECT sum(seq_scan + idx_scan) from pg_stat_user_tables  (entry db 127.0.0.1:7000 pid=87765)
LOG:  statement: SELECT sum(seq_scan + idx_scan) from pg_stat_user_tables  (entry db 127.0.0.1:7000 pid=87765)
LOG:  statement: SELECT sum(seq_scan + idx_scan) from pg_stat_user_tables  (entry db 127.0.0.1:7000 pid=87765)
LOG:  statement: SELECT sum(seq_scan + idx_scan) from pg_stat_user_tables  (entry db 127.0.0.1:7000 pid=87765)
LOG:  statement: SELECT sum(seq_scan + idx_scan) from pg_stat_user_tables  (entry db 127.0.0.1:7000 pid=87765)
LOG:  statement: SELECT sum(seq_scan + idx_scan) from pg_stat_user_tables  (entry db 127.0.0.1:7000 pid=87765)
LOG:  statement: SELECT sum(seq_scan + idx_scan) from pg_stat_user_tables  (entry db 127.0.0.1:7000 pid=87765)
LOG:  statement: SELECT sum(seq_scan + idx_scan) from pg_stat_user_tables  (entry db 127.0.0.1:7000 pid=87765)
LOG:  statement: SELECT sum(seq_scan + idx_scan) from pg_stat_user_tables  (entry db 127.0.0.1:7000 pid=87765)
LOG:  statement: SELECT sum(seq_scan + idx_scan) from pg_stat_user_tables  (entry db 127.0.0.1:7000 pid=87765)
LOG:  statement: SELECT sum(seq_scan + idx_scan) from pg_stat_user_tables  (entry db 127.0.0.1:7000 pid=87765)
LOG:  statement: SELECT sum(seq_scan + idx_scan) from pg_stat_user_tables  (entry db 127.0.0.1:7000 pid=87765)
LOG:  statement: SELECT sum(seq_scan + idx_scan) from pg_stat_user_tables  (entry db 127.0.0.1:7000 pid=87765)
LOG:  statement: SELECT sum(seq_scan + idx_scan) from pg_stat_user_tables  (entry db 127.0.0.1:7000 pid=87765)
LOG:  statement: SELECT sum(seq_scan + idx_scan) from pg_stat_user_tables  (entry db 127.0.0.1:7000 pid=87765)
LOG:  statement: SELECT sum(seq_scan + idx_scan) from pg_stat_user_tables  (entry db 127.0.0.1:7000 pid=87765)
LOG:  statement: SELECT sum(seq_scan + idx_scan) from pg_stat_user_tables  (entry db 127.0.0.1:7000 pid=87765)
LOG:  statement: SELECT sum(seq_scan + idx_scan) from pg_stat_user_tables  (entry db 127.0.0.1:7000 pid=87765)
LOG:  statement: SELECT sum(seq_scan + idx_scan) from pg_stat_user_tables  (entry db 127.0.0.1:7000 pid=87765)
LOG:  statement: SELECT sum(seq_scan + idx_scan) from pg_stat_user_tables  (entry db 127.0.0.1:7000 pid=87765)
LOG:  statement: SELECT sum(seq_scan + idx_scan) from pg_stat_user_tables  (entry db 127.0.0.1:7000 pid=87765)
LOG:  statement: SELECT sum(seq_scan + idx_scan) from pg_stat_user_tables  (entry db 127.0.0.1:7000 pid=87765)
LOG:  statement: SELECT sum(seq_scan + idx_scan) from pg_stat_user_tables  (entry db 127.0.0.1:7000 pid=87765)
LOG:  statement: SELECT sum(seq_scan + idx_scan) from pg_stat_user_tables  (entry db 127.0.0.1:7000 pid=87765)
LOG:  statement: SELECT sum(seq_scan + idx_scan) from pg_stat_user_tables  (entry db 127.0.0.1:7000 pid=87765)
LOG:  statement: SELECT sum(seq_scan + idx_scan) from pg_stat_user_tables  (entry db 127.0.0.1:7000 pid=87765)
LOG:  statement: SELECT sum(seq_scan + idx_scan) from pg_stat_user_tables  (entry db 127.0.0.1:7000 pid=87765)
LOG:  statement: SELECT sum(seq_scan + idx_scan) from pg_stat_user_tables  (entry db 127.0.0.1:7000 pid=87765)
LOG:  statement: SELECT sum(seq_scan + idx_scan) from pg_stat_user_tables  (entry db 127.0.0.1:7000 pid=87765)
LOG:  statement: SELECT sum(seq_scan + idx_scan) from pg_stat_user_tables  (entry db 127.0.0.1:7000 pid=87765)
LOG:  statement: SELECT sum(seq_scan + idx_scan) from pg_stat_user_tables  (entry db 127.0.0.1:7000 pid=87765)
LOG:  statement: SELECT sum(seq_scan + idx_scan) from pg_stat_user_tables  (entry db 127.0.0.1:7000 pid=87765)
LOG:  statement: SELECT sum(seq_scan + idx_scan) from pg_stat_user_tables  (entry db 127.0.0.1:7000 pid=87765)
LOG:  statement: SELECT sum(seq_scan + idx_scan) from pg_stat_user_tables  (entry db 127.0.0.1:7000 pid=87765)
LOG:  statement: SELECT sum(seq_scan + idx_scan) from pg_stat_user_tables  (entry db 127.0.0.1:7000 pid=87765)
LOG:  statement: SELECT sum(seq_scan + idx_scan) from pg_stat_user_tables  (entry db 127.0.0.1:7000 pid=87765)
LOG:  statement: SELECT sum(seq_scan + idx_scan) from pg_stat_user_tables  (entry db 127.0.0.1:7000 pid=87765)
LOG:  statement: SELECT sum(seq_scan + idx_scan) from pg_stat_user_tables  (entry db 127.0.0.1:7000 pid=87765)
LOG:  statement: SELECT sum(seq_scan + idx_scan) from pg_stat_user_tables  (entry db 127.0.0.1:7000 pid=87765)
LOG:  statement: SELECT sum(seq_scan + idx_scan) from pg_stat_user_tables  (entry db 127.0.0.1:7000 pid=87765)
LOG:  statement: SELECT sum(seq_scan + idx_scan) from pg_stat_user_tables  (entry db 127.0.0.1:7000 pid=87765)
LOG:  statement: SELECT sum(seq_scan + idx_scan) from pg_stat_user_tables  (entry db 127.0.0.1:7000 pid=87765)
LOG:  statement: SELECT sum(seq_scan + idx_scan) from pg_stat_user_tables  (entry db 127.0.0.1:7000 pid=87765)
LOG:  statement: SELECT sum(seq_scan + idx_scan) from pg_stat_user_tables  (entry db 127.0.0.1:7000 pid=87765)
LOG:  statement: SELECT sum(seq_scan + idx_scan) from pg_stat_user_tables  (entry db 127.0.0.1:7000 pid=87765)
LOG:  statement: SELECT sum(seq_scan + idx_scan) from pg_stat_user_tables  (entry db 127.0.0.1:7000 pid=87765)
LOG:  statement: SELECT sum(seq_scan + idx_scan) from pg_stat_user_tables  (entry db 127.0.0.1:7000 pid=87765)
LOG:  statement: SELECT sum(seq_scan + idx_scan) from pg_stat_user_tables  (entry db 127.0.0.1:7000 pid=87765)
LOG:  statement: SELECT sum(seq_scan + idx_scan) from pg_stat_user_tables  (entry db 127.0.0.1:7000 pid=87765)
LOG:  statement: SELECT sum(seq_scan + idx_scan) from pg_stat_user_tables  (entry db 127.0.0.1:7000 pid=87765)
LOG:  statement: SELECT sum(seq_scan + idx_scan) from pg_stat_user_tables  (entry db 127.0.0.1:7000 pid=87765)
LOG:  statement: SELECT sum(seq_scan + idx_scan) from pg_stat_user_tables  (entry db 127.0.0.1:7000 pid=87765)
LOG:  statement: SELECT sum(seq_scan + idx_scan) from pg_stat_user_tables  (entry db 127.0.0.1:7000 pid=87765)
LOG:  statement: SELECT sum(seq_scan + idx_scan) from pg_stat_user_tables  (entry db 127.0.0.1:7000 pid=87765)
LOG:  statement: SELECT sum(seq_scan + idx_scan) from pg_stat_user_tables  (entry db 127.0.0.1:7000 pid=87765)
LOG:  statement: SELECT sum(seq_scan + idx_scan) from pg_stat_user_tables  (entry db 127.0.0.1:7000 pid=87765)
LOG:  statement: SELECT sum(seq_scan + idx_scan) from pg_stat_user_tables  (entry db 127.0.0.1:7000 pid=87765)
LOG:  statement: SELECT sum(seq_scan + idx_scan) from pg_stat_user_tables  (entry db 127.0.0.1:7000 pid=87765)
LOG:  statement: SELECT sum(seq_scan + idx_scan) from pg_stat_user_tables  (entry db 127.0.0.1:7000 pid=87765)
LOG:  statement: SELECT sum(seq_scan + idx_scan) from pg_stat_user_tables  (entry db 127.0.0.1:7000 pid=87765)
LOG:  statement: SELECT sum(seq_scan + idx_scan) from pg_stat_user_tables  (entry db 127.0.0.1:7000 pid=87765)
LOG:  statement: SELECT sum(seq_scan + idx_scan) from pg_stat_user_tables  (entry db 127.0.0.1:7000 pid=87765)
LOG:  statement: SELECT sum(seq_scan + idx_scan) from pg_stat_user_tables  (entry db 127.0.0.1:7000 pid=87765)
LOG:  statement: SELECT sum(seq_scan + idx_scan) from pg_stat_user_tables  (entry db 127.0.0.1:7000 pid=87765)
LOG:  statement: SELECT sum(seq_scan + idx_scan) from pg_stat_user_tables  (entry db 127.0.0.1:7000 pid=87765)
LOG:  statement: SELECT sum(seq_scan + idx_scan) from pg_stat_user_tables  (entry db 127.0.0.1:7000 pid=87765)
LOG:  statement: SELECT sum(seq_scan + idx_scan) from pg_stat_user_tables  (entry db 127.0.0.1:7000 pid=87765)
LOG:  statement: SELECT sum(seq_scan + idx_scan) from pg_stat_user_tables  (entry db 127.0.0.1:7000 pid=87765)
LOG:  statement: SELECT sum(seq_scan + idx_scan) from pg_stat_user_tables  (entry db 127.0.0.1:7000 pid=87765)
LOG:  statement: SELECT sum(seq_scan + idx_scan) from pg_stat_user_tables  (entry db 127.0.0.1:7000 pid=87765)
LOG:  statement: SELECT sum(seq_scan + idx_scan) from pg_stat_user_tables  (entry db 127.0.0.1:7000 pid=87765)
LOG:  statement: SELECT sum(seq_scan + idx_scan) from pg_stat_user_tables  (entry db 127.0.0.1:7000 pid=87765)
LOG:  statement: SELECT sum(seq_scan + idx_scan) from pg_stat_user_tables  (entry db 127.0.0.1:7000 pid=87765)
LOG:  statement: SELECT sum(seq_scan + idx_scan) from pg_stat_user_tables  (entry db 127.0.0.1:7000 pid=87765)
LOG:  statement: SELECT sum(seq_scan + idx_scan) from pg_stat_user_tables  (entry db 127.0.0.1:7000 pid=87765)
LOG:  statement: SELECT sum(seq_scan + idx_scan) from pg_stat_user_tables  (entry db 127.0.0.1:7000 pid=87765)
LOG:  statement: SELECT sum(seq_scan + idx_scan) from pg_stat_user_tables  (entry db 127.0.0.1:7000 pid=87765)
LOG:  statement: SELECT sum(seq_scan + idx_scan) from pg_stat_user_tables  (entry db 127.0.0.1:7000 pid=87765)
LOG:  statement: SELECT sum(seq_scan + idx_scan) from pg_stat_user_tables  (entry db 127.0.0.1:7000 pid=87765)
LOG:  statement: SELECT sum(seq_scan + idx_scan) from pg_stat_user_tables  (entry db 127.0.0.1:7000 pid=87765)
LOG:  statement: SELECT sum(seq_scan + idx_scan) from pg_stat_user_tables  (entry db 127.0.0.1:7000 pid=87765)
LOG:  statement: SELECT sum(seq_scan + idx_scan) from pg_stat_user_tables  (entry db 127.0.0.1:7000 pid=87765)
LOG:  statement: SELECT sum(seq_scan + idx_scan) from pg_stat_user_tables  (entry db 127.0.0.1:7000 pid=87765)
LOG:  statement: SELECT sum(seq_scan + idx_scan) from pg_stat_user_tables  (entry db 127.0.0.1:7000 pid=87765)
LOG:  statement: SELECT sum(seq_scan + idx_scan) from pg_stat_user_tables  (entry db 127.0.0.1:7000 pid=87765)
LOG:  statement: SELECT sum(seq_scan + idx_scan) from pg_stat_user_tables  (entry db 127.0.0.1:7000 pid=87765)
Cancel request sent
LOG:  Process interrupt for 'query cancel pending' (misc.c:385)
CONTEXT:  SQL statement "SELECT pg_sleep(0.5)"
PL/pgSQL function reset_stats_and_wait() line 8 at PERFORM
ERROR:  canceling statement due to user request
CONTEXT:  SQL statement "SELECT pg_sleep(0.5)"
PL/pgSQL function reset_stats_and_wait() line 8 at PERFORM
